/* tslint:disable */
/* eslint-disable */
/**
 * API V1
 * A RestFull API for Decidim, to be able to CRUD resources from Decidim.   _current version: 0.2.3_  ## Authentication [Get a token](https://octree-gva.github.io/decidim-rest-full/category/authentication) from our `/oauth/token` routes, following OAuth specs on Credential Flows or Resource Owner Password Credentials Flow.  ### Permissions A permission system is attached to the created OAuth application, that is designed in two levels:  - **scope**: a broad permission to access a collection of endpoints - **abilities**: a fine grained permission system that allow actions.  The scopes and abilities are manageable in your System Admin Panel.  ### Multi-tenant Decidim is multi-tenant, and this API supports it. - The **`system` scope** endpoints are available in any tenant - The tenant `host` attribute will be used to guess which tenant you are requesting.   For example, given a tenant `example.org` and `foobar.org`, the endpoint   * `example.org/oauth/token` will ask a token for the example.org organization   * `foobar.org/oauth/token` for foobar.org.
 *
 * The version of the OpenAPI document: v0.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Blog
 */
export interface Blog {
  /**
   * Blog Post Id
   * @type {string}
   * @memberof Blog
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Blog
   */
  type: BlogTypeEnum;
  /**
   *
   * @type {BlogPostAttributes}
   * @memberof Blog
   */
  attributes: BlogPostAttributes;
  /**
   *
   * @type {BlogPostMetadata}
   * @memberof Blog
   */
  meta: BlogPostMetadata;
  /**
   *
   * @type {BlogPostLinks}
   * @memberof Blog
   */
  links: BlogPostLinks;
  /**
   *
   * @type {BlogPostRelationships}
   * @memberof Blog
   */
  relationships?: BlogPostRelationships;
}

export const BlogTypeEnum = {
  Blog: "blog",
} as const;

export type BlogTypeEnum = (typeof BlogTypeEnum)[keyof typeof BlogTypeEnum];

/**
 *
 * @export
 * @interface BlogComponent
 */
export interface BlogComponent {
  /**
   * Blog Post Component Id
   * @type {string}
   * @memberof BlogComponent
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof BlogComponent
   */
  type?: BlogComponentTypeEnum;
  /**
   *
   * @type {BlogComponentAttributes}
   * @memberof BlogComponent
   */
  attributes?: BlogComponentAttributes;
  /**
   *
   * @type {BlogPostComponentMetadata}
   * @memberof BlogComponent
   */
  meta?: BlogPostComponentMetadata;
  /**
   *
   * @type {BlogPostComponentLinks}
   * @memberof BlogComponent
   */
  links?: BlogPostComponentLinks;
  /**
   *
   * @type {BlogPostComponentRelationships}
   * @memberof BlogComponent
   */
  relationships?: BlogPostComponentRelationships;
}

export const BlogComponentTypeEnum = {
  BlogComponent: "blog_component",
} as const;

export type BlogComponentTypeEnum =
  (typeof BlogComponentTypeEnum)[keyof typeof BlogComponentTypeEnum];

/**
 *
 * @export
 * @interface BlogComponentAttributes
 */
export interface BlogComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof BlogComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  manifest_name: BlogComponentAttributesManifestNameEnum;
}

export const BlogComponentAttributesManifestNameEnum = {
  Blogs: "blogs",
} as const;

export type BlogComponentAttributesManifestNameEnum =
  (typeof BlogComponentAttributesManifestNameEnum)[keyof typeof BlogComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface BlogComponentIndexResponse
 */
export interface BlogComponentIndexResponse {
  /**
   *
   * @type {Array<BlogComponent>}
   * @memberof BlogComponentIndexResponse
   */
  data: Array<BlogComponent>;
}
/**
 *
 * @export
 * @interface BlogComponentItemResponse
 */
export interface BlogComponentItemResponse {
  /**
   *
   * @type {BlogComponent}
   * @memberof BlogComponentItemResponse
   */
  data: BlogComponent;
}
/**
 *
 * @export
 * @interface BlogIndexResponse
 */
export interface BlogIndexResponse {
  /**
   *
   * @type {Array<Blog>}
   * @memberof BlogIndexResponse
   */
  data: Array<Blog>;
}
/**
 *
 * @export
 * @interface BlogItemResponse
 */
export interface BlogItemResponse {
  /**
   *
   * @type {Blog}
   * @memberof BlogItemResponse
   */
  data: Blog;
}
/**
 *
 * @export
 * @interface BlogPostAttributes
 */
export interface BlogPostAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogPostAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogPostAttributes
   */
  body: TranslatedProp;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof BlogPostAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof BlogPostAttributes
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface BlogPostComponentLinkedResources
 */
export interface BlogPostComponentLinkedResources {
  /**
   *
   * @type {Array<ComponentLinkedResourcesDataInner>}
   * @memberof BlogPostComponentLinkedResources
   */
  data: Array<ComponentLinkedResourcesDataInner>;
  /**
   *
   * @type {BlogPostComponentLinkedResourcesMetadata}
   * @memberof BlogPostComponentLinkedResources
   */
  meta: BlogPostComponentLinkedResourcesMetadata;
}
/**
 *
 * @export
 * @interface BlogPostComponentLinkedResourcesMetadata
 */
export interface BlogPostComponentLinkedResourcesMetadata {
  /**
   * Total count of resources
   * @type {number}
   * @memberof BlogPostComponentLinkedResourcesMetadata
   */
  count: number;
}
/**
 *
 * @export
 * @interface BlogPostComponentLinks
 */
export interface BlogPostComponentLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostComponentLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostComponentLinks
   */
  related?: ResourceLink;
}
/**
 *
 * @export
 * @interface BlogPostComponentMetadata
 */
export interface BlogPostComponentMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof BlogPostComponentMetadata
   */
  published: boolean;
  /**
   * Blog Post Component handle scopes?
   * @type {boolean}
   * @memberof BlogPostComponentMetadata
   */
  scopes_enabled: boolean;
}
/**
 *
 * @export
 * @interface BlogPostComponentRelationships
 */
export interface BlogPostComponentRelationships {
  /**
   *
   * @type {BlogPostComponentLinkedResources}
   * @memberof BlogPostComponentRelationships
   */
  resources?: BlogPostComponentLinkedResources;
}
/**
 *
 * @export
 * @interface BlogPostLinks
 */
export interface BlogPostLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  collection: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  related: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  prev?: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  next?: ResourceLink;
}
/**
 *
 * @export
 * @interface BlogPostMetadata
 */
export interface BlogPostMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof BlogPostMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof BlogPostMetadata
   */
  scope?: number;
}
/**
 * @type BlogPostMetadataValue
 * @export
 */
export type BlogPostMetadataValue = TranslatedProp | boolean | number | string;

/**
 *
 * @export
 * @interface BlogPostRelationships
 */
export interface BlogPostRelationships {
  /**
   *
   * @type {LinkedSpace}
   * @memberof BlogPostRelationships
   */
  space: LinkedSpace;
  /**
   *
   * @type {LinkedBlogComponent}
   * @memberof BlogPostRelationships
   */
  component: LinkedBlogComponent;
}
/**
 *
 * @export
 * @interface ClientCredential
 */
export interface ClientCredential {
  /**
   * Client Credential Flow, for **machine-to-machine**
   * @type {string}
   * @memberof ClientCredential
   */
  grant_type: ClientCredentialGrantTypeEnum;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof ClientCredential
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof ClientCredential
   */
  client_secret: string;
  /**
   * Requested scopes
   * @type {string}
   * @memberof ClientCredential
   */
  scope: ClientCredentialScopeEnum;
}

export const ClientCredentialGrantTypeEnum = {
  ClientCredentials: "client_credentials",
} as const;

export type ClientCredentialGrantTypeEnum =
  (typeof ClientCredentialGrantTypeEnum)[keyof typeof ClientCredentialGrantTypeEnum];
export const ClientCredentialScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  System: "system",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type ClientCredentialScopeEnum =
  (typeof ClientCredentialScopeEnum)[keyof typeof ClientCredentialScopeEnum];

/**
 * @type Component
 * @export
 */
export type Component = BlogComponent | OtherComponent | ProposalComponent;

/**
 *
 * @export
 * @interface ComponentIndexResponse
 */
export interface ComponentIndexResponse {
  /**
   *
   * @type {Array<Component>}
   * @memberof ComponentIndexResponse
   */
  data: Array<Component>;
}
/**
 *
 * @export
 * @interface ComponentItemResponse
 */
export interface ComponentItemResponse {
  /**
   *
   * @type {Component}
   * @memberof ComponentItemResponse
   */
  data: Component;
}
/**
 *
 * @export
 * @interface ComponentLinkedResources
 */
export interface ComponentLinkedResources {
  /**
   *
   * @type {Array<ComponentLinkedResourcesDataInner>}
   * @memberof ComponentLinkedResources
   */
  data: Array<ComponentLinkedResourcesDataInner>;
  /**
   *
   * @type {ComponentLinkedResourcesMetadata}
   * @memberof ComponentLinkedResources
   */
  meta: ComponentLinkedResourcesMetadata;
}
/**
 *
 * @export
 * @interface ComponentLinkedResourcesDataInner
 */
export interface ComponentLinkedResourcesDataInner {
  /**
   * Resource Id
   * @type {string}
   * @memberof ComponentLinkedResourcesDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ComponentLinkedResourcesDataInner
   */
  type: string;
}
/**
 *
 * @export
 * @interface ComponentLinkedResourcesMetadata
 */
export interface ComponentLinkedResourcesMetadata {
  /**
   * Total count of resources
   * @type {number}
   * @memberof ComponentLinkedResourcesMetadata
   */
  count: number;
}
/**
 *
 * @export
 * @interface ComponentLinks
 */
export interface ComponentLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof ComponentLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ComponentLinks
   */
  related?: ResourceLink;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComponentManifest = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type ComponentManifest =
  (typeof ComponentManifest)[keyof typeof ComponentManifest];

/**
 *
 * @export
 * @interface ComponentMetadata
 */
export interface ComponentMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  published: boolean;
  /**
   * Component handle scopes?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  scopes_enabled: boolean;
}
/**
 *
 * @export
 * @interface ComponentRelationships
 */
export interface ComponentRelationships {
  /**
   *
   * @type {ComponentLinkedResources}
   * @memberof ComponentRelationships
   */
  resources?: ComponentLinkedResources;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComponentType = {
  PageComponent: "page_component",
  ProposalComponent: "proposal_component",
  MeetingComponent: "meeting_component",
  BudgetComponent: "budget_component",
  SurveyComponent: "survey_component",
  AccountabilityComponent: "accountability_component",
  DebateComponent: "debate_component",
  SortitionComponent: "sortition_component",
  BlogComponent: "blog_component",
  AwesomeMapComponent: "awesome_map_component",
  AwesomeIframeComponent: "awesome_iframe_component",
} as const;

export type ComponentType = (typeof ComponentType)[keyof typeof ComponentType];

/**
 *
 * @export
 * @interface CreateDraftProposalPayload
 */
export interface CreateDraftProposalPayload {
  /**
   *
   * @type {DraftProposalData}
   * @memberof CreateDraftProposalPayload
   */
  data: DraftProposalData;
}
/**
 *
 * @export
 * @interface CurrentUserProposalVoteMetadata
 */
export interface CurrentUserProposalVoteMetadata {
  /**
   * Vote weight
   * @type {number}
   * @memberof CurrentUserProposalVoteMetadata
   */
  weight: number;
}
/**
 *
 * @export
 * @interface DraftProposal
 */
export interface DraftProposal {
  /**
   * Draft Proposal Id
   * @type {string}
   * @memberof DraftProposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DraftProposal
   */
  type: DraftProposalTypeEnum;
  /**
   *
   * @type {DraftProposalAttributes}
   * @memberof DraftProposal
   */
  attributes: DraftProposalAttributes;
  /**
   *
   * @type {DraftPropositionMetadata}
   * @memberof DraftProposal
   */
  meta: DraftPropositionMetadata;
  /**
   *
   * @type {ProposalLinks}
   * @memberof DraftProposal
   */
  links: ProposalLinks;
  /**
   *
   * @type {DraftProposalRelationships}
   * @memberof DraftProposal
   */
  relationships?: DraftProposalRelationships;
}

export const DraftProposalTypeEnum = {
  DraftProposal: "draft_proposal",
} as const;

export type DraftProposalTypeEnum =
  (typeof DraftProposalTypeEnum)[keyof typeof DraftProposalTypeEnum];

/**
 *
 * @export
 * @interface DraftProposalAttributes
 */
export interface DraftProposalAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  body: TranslatedProp;
  /**
   *
   * @type {DraftProposalValidationErrors}
   * @memberof DraftProposalAttributes
   */
  errors?: DraftProposalValidationErrors;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface DraftProposalAuthor
 */
export interface DraftProposalAuthor {
  /**
   *
   * @type {DraftProposalAuthorData}
   * @memberof DraftProposalAuthor
   */
  data: DraftProposalAuthorData;
}
/**
 *
 * @export
 * @interface DraftProposalAuthorData
 */
export interface DraftProposalAuthorData {
  /**
   * Resource Id
   * @type {string}
   * @memberof DraftProposalAuthorData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DraftProposalAuthorData
   */
  type: DraftProposalAuthorDataTypeEnum;
}

export const DraftProposalAuthorDataTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type DraftProposalAuthorDataTypeEnum =
  (typeof DraftProposalAuthorDataTypeEnum)[keyof typeof DraftProposalAuthorDataTypeEnum];

/**
 *
 * @export
 * @interface DraftProposalCoauthors
 */
export interface DraftProposalCoauthors {
  /**
   *
   * @type {Array<DraftProposalCoauthorsDataInner>}
   * @memberof DraftProposalCoauthors
   */
  data: Array<DraftProposalCoauthorsDataInner>;
}
/**
 *
 * @export
 * @interface DraftProposalCoauthorsDataInner
 */
export interface DraftProposalCoauthorsDataInner {
  /**
   * Resource Id
   * @type {string}
   * @memberof DraftProposalCoauthorsDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DraftProposalCoauthorsDataInner
   */
  type: DraftProposalCoauthorsDataInnerTypeEnum;
}

export const DraftProposalCoauthorsDataInnerTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type DraftProposalCoauthorsDataInnerTypeEnum =
  (typeof DraftProposalCoauthorsDataInnerTypeEnum)[keyof typeof DraftProposalCoauthorsDataInnerTypeEnum];

/**
 * Payload to update in the proposal
 * @export
 * @interface DraftProposalData
 */
export interface DraftProposalData {
  /**
   * Component ID
   * @type {number}
   * @memberof DraftProposalData
   */
  component_id: number;
}
/**
 *
 * @export
 * @interface DraftProposalIndexResponse
 */
export interface DraftProposalIndexResponse {
  /**
   *
   * @type {Array<DraftProposal>}
   * @memberof DraftProposalIndexResponse
   */
  data: Array<DraftProposal>;
}
/**
 *
 * @export
 * @interface DraftProposalItemResponse
 */
export interface DraftProposalItemResponse {
  /**
   *
   * @type {DraftProposal}
   * @memberof DraftProposalItemResponse
   */
  data: DraftProposal;
}
/**
 *
 * @export
 * @interface DraftProposalRelatedComponent
 */
export interface DraftProposalRelatedComponent {
  /**
   *
   * @type {DraftProposalRelatedComponentData}
   * @memberof DraftProposalRelatedComponent
   */
  data: DraftProposalRelatedComponentData;
}
/**
 *
 * @export
 * @interface DraftProposalRelatedComponentData
 */
export interface DraftProposalRelatedComponentData {
  /**
   * Resource Id
   * @type {string}
   * @memberof DraftProposalRelatedComponentData
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof DraftProposalRelatedComponentData
   */
  type: ComponentType;
}

/**
 *
 * @export
 * @interface DraftProposalRelatedSpace
 */
export interface DraftProposalRelatedSpace {
  /**
   *
   * @type {DraftProposalRelatedSpaceData}
   * @memberof DraftProposalRelatedSpace
   */
  data: DraftProposalRelatedSpaceData;
}
/**
 *
 * @export
 * @interface DraftProposalRelatedSpaceData
 */
export interface DraftProposalRelatedSpaceData {
  /**
   * Resource Id
   * @type {string}
   * @memberof DraftProposalRelatedSpaceData
   */
  id: string;
  /**
   *
   * @type {SpaceType}
   * @memberof DraftProposalRelatedSpaceData
   */
  type: SpaceType;
}

/**
 *
 * @export
 * @interface DraftProposalRelationships
 */
export interface DraftProposalRelationships {
  /**
   *
   * @type {DraftProposalRelatedSpace}
   * @memberof DraftProposalRelationships
   */
  space: DraftProposalRelatedSpace;
  /**
   *
   * @type {DraftProposalRelatedComponent}
   * @memberof DraftProposalRelationships
   */
  component: DraftProposalRelatedComponent;
  /**
   *
   * @type {DraftProposalAuthor}
   * @memberof DraftProposalRelationships
   */
  author?: DraftProposalAuthor;
  /**
   *
   * @type {DraftProposalCoauthors}
   * @memberof DraftProposalRelationships
   */
  coauthors?: DraftProposalCoauthors;
}
/**
 * Draft current errors
 * @export
 * @interface DraftProposalValidationErrors
 */
export interface DraftProposalValidationErrors {
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalValidationErrors
   */
  title: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalValidationErrors
   */
  body: Array<string>;
}
/**
 *
 * @export
 * @interface DraftPropositionMetadata
 */
export interface DraftPropositionMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Draft is published as it is now?
   * @type {boolean}
   * @memberof DraftPropositionMetadata
   */
  publishable: boolean;
  /**
   * Attached client_id
   * @type {string}
   * @memberof DraftPropositionMetadata
   */
  client_id: string;
  /**
   * Scope Id
   * @type {number}
   * @memberof DraftPropositionMetadata
   */
  scope?: number;
  /**
   * Editable field names
   * @type {Array<string>}
   * @memberof DraftPropositionMetadata
   */
  fields: Array<string>;
}
/**
 *
 * @export
 * @interface GenerateMagicLinkPayload
 */
export interface GenerateMagicLinkPayload {
  /**
   *
   * @type {GenerateMagicLinkPayloadData}
   * @memberof GenerateMagicLinkPayload
   */
  data?: GenerateMagicLinkPayloadData;
}
/**
 * Optional payload to configure the magic link
 * @export
 * @interface GenerateMagicLinkPayloadData
 */
export interface GenerateMagicLinkPayloadData {
  /**
   * Redirect url after sign-in
   * @type {string}
   * @memberof GenerateMagicLinkPayloadData
   */
  redirect_url: string;
}
/**
 *
 * @export
 * @interface GenericComponent
 */
export interface GenericComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof GenericComponent
   */
  id?: string;
  /**
   *
   * @type {ComponentType}
   * @memberof GenericComponent
   */
  type?: ComponentType;
  /**
   *
   * @type {GenericComponentAttributes}
   * @memberof GenericComponent
   */
  attributes?: GenericComponentAttributes;
  /**
   *
   * @type {ComponentMetadata}
   * @memberof GenericComponent
   */
  meta?: ComponentMetadata;
  /**
   *
   * @type {ComponentLinks}
   * @memberof GenericComponent
   */
  links?: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof GenericComponent
   */
  relationships?: ComponentRelationships;
}

/**
 *
 * @export
 * @interface GenericComponentAttributes
 */
export interface GenericComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof GenericComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof GenericComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof GenericComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  updated_at: string;
}

/**
 *
 * @export
 * @interface GenericComponentLinkedResources
 */
export interface GenericComponentLinkedResources {
  /**
   *
   * @type {Array<ComponentLinkedResourcesDataInner>}
   * @memberof GenericComponentLinkedResources
   */
  data: Array<ComponentLinkedResourcesDataInner>;
  /**
   *
   * @type {GenericComponentLinkedResourcesMetadata}
   * @memberof GenericComponentLinkedResources
   */
  meta: GenericComponentLinkedResourcesMetadata;
}
/**
 *
 * @export
 * @interface GenericComponentLinkedResourcesMetadata
 */
export interface GenericComponentLinkedResourcesMetadata {
  /**
   * Total count of resources
   * @type {number}
   * @memberof GenericComponentLinkedResourcesMetadata
   */
  count: number;
}
/**
 *
 * @export
 * @interface GenericComponentLinks
 */
export interface GenericComponentLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof GenericComponentLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof GenericComponentLinks
   */
  related?: ResourceLink;
}
/**
 *
 * @export
 * @interface GenericComponentMetadata
 */
export interface GenericComponentMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof GenericComponentMetadata
   */
  published: boolean;
  /**
   * Generic Component handle scopes?
   * @type {boolean}
   * @memberof GenericComponentMetadata
   */
  scopes_enabled: boolean;
}
/**
 *
 * @export
 * @interface GenericComponentRelationships
 */
export interface GenericComponentRelationships {
  /**
   *
   * @type {GenericComponentLinkedResources}
   * @memberof GenericComponentRelationships
   */
  resources?: GenericComponentLinkedResources;
}
/**
 *
 * @export
 * @interface GetActionLink
 */
export interface GetActionLink {
  /**
   * Action Name
   * @type {string}
   * @memberof GetActionLink
   */
  title: string;
  /**
   * Full URL
   * @type {string}
   * @memberof GetActionLink
   */
  href: string;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof GetActionLink
   */
  describedby?: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof GetActionLink
   */
  hreflang?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetActionLink
   */
  rel: GetActionLinkRelEnum;
  /**
   *
   * @type {MetaForReadRequest}
   * @memberof GetActionLink
   */
  meta: MetaForReadRequest;
}

export const GetActionLinkRelEnum = {
  Action: "action",
} as const;

export type GetActionLinkRelEnum =
  (typeof GetActionLinkRelEnum)[keyof typeof GetActionLinkRelEnum];

/**
 *
 * @export
 * @interface Health
 */
export interface Health {
  /**
   *
   * @type {string}
   * @memberof Health
   */
  message?: HealthMessageEnum;
}

export const HealthMessageEnum = {
  Ok: "OK",
  Error: "ERROR",
} as const;

export type HealthMessageEnum =
  (typeof HealthMessageEnum)[keyof typeof HealthMessageEnum];

/**
 *
 * @export
 * @interface IntrospectData
 */
export interface IntrospectData {
  /**
   * Access token id
   * @type {number}
   * @memberof IntrospectData
   */
  sub: number;
  /**
   * If the token can be used
   * @type {boolean}
   * @memberof IntrospectData
   */
  active: boolean;
  /**
   * Where this token can be used (organization host)
   * @type {string}
   * @memberof IntrospectData
   */
  aud: string;
  /**
   *
   * @type {ResourceDetails}
   * @memberof IntrospectData
   */
  resource?: ResourceDetails;
}
/**
 *
 * @export
 * @interface IntrospectTokenRequest
 */
export interface IntrospectTokenRequest {
  /**
   *
   * @type {string}
   * @memberof IntrospectTokenRequest
   */
  token: string;
}
/**
 *
 * @export
 * @interface LinkedBlogComponent
 */
export interface LinkedBlogComponent {
  /**
   *
   * @type {LinkedBlogComponentData}
   * @memberof LinkedBlogComponent
   */
  data: LinkedBlogComponentData;
}
/**
 *
 * @export
 * @interface LinkedBlogComponentData
 */
export interface LinkedBlogComponentData {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedBlogComponentData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedBlogComponentData
   */
  type: LinkedBlogComponentDataTypeEnum;
}

export const LinkedBlogComponentDataTypeEnum = {
  BlogComponent: "blog_component",
} as const;

export type LinkedBlogComponentDataTypeEnum =
  (typeof LinkedBlogComponentDataTypeEnum)[keyof typeof LinkedBlogComponentDataTypeEnum];

/**
 *
 * @export
 * @interface LinkedProposalComponent
 */
export interface LinkedProposalComponent {
  /**
   *
   * @type {LinkedProposalComponentData}
   * @memberof LinkedProposalComponent
   */
  data: LinkedProposalComponentData;
}
/**
 *
 * @export
 * @interface LinkedProposalComponentData
 */
export interface LinkedProposalComponentData {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedProposalComponentData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedProposalComponentData
   */
  type: LinkedProposalComponentDataTypeEnum;
}

export const LinkedProposalComponentDataTypeEnum = {
  ProposalComponent: "proposal_component",
} as const;

export type LinkedProposalComponentDataTypeEnum =
  (typeof LinkedProposalComponentDataTypeEnum)[keyof typeof LinkedProposalComponentDataTypeEnum];

/**
 *
 * @export
 * @interface LinkedSpace
 */
export interface LinkedSpace {
  /**
   *
   * @type {LinkedSpaceData}
   * @memberof LinkedSpace
   */
  data: LinkedSpaceData;
}
/**
 *
 * @export
 * @interface LinkedSpace1
 */
export interface LinkedSpace1 {
  /**
   *
   * @type {LinkedSpaceData1}
   * @memberof LinkedSpace1
   */
  data: LinkedSpaceData1;
}
/**
 *
 * @export
 * @interface LinkedSpaceData
 */
export interface LinkedSpaceData {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedSpaceData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedSpaceData
   */
  type: LinkedSpaceDataTypeEnum;
}

export const LinkedSpaceDataTypeEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type LinkedSpaceDataTypeEnum =
  (typeof LinkedSpaceDataTypeEnum)[keyof typeof LinkedSpaceDataTypeEnum];

/**
 *
 * @export
 * @interface LinkedSpaceData1
 */
export interface LinkedSpaceData1 {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedSpaceData1
   */
  id: string;
  /**
   *
   * @type {SpaceType}
   * @memberof LinkedSpaceData1
   */
  type: SpaceType;
}

/**
 *
 * @export
 * @enum {string}
 */

export const Locale = {
  En: "en",
  Fr: "fr",
} as const;

export type Locale = (typeof Locale)[keyof typeof Locale];

/**
 *
 * @export
 * @interface MagicLink
 */
export interface MagicLink {
  /**
   * Magic Token ID
   * @type {string}
   * @memberof MagicLink
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MagicLink
   */
  type: MagicLinkTypeEnum;
  /**
   *
   * @type {MagicLinkAttributes}
   * @memberof MagicLink
   */
  attributes: MagicLinkAttributes;
  /**
   *
   * @type {MagicLinkLinks}
   * @memberof MagicLink
   */
  links: MagicLinkLinks;
}

export const MagicLinkTypeEnum = {
  MagicLink: "magic_link",
} as const;

export type MagicLinkTypeEnum =
  (typeof MagicLinkTypeEnum)[keyof typeof MagicLinkTypeEnum];

/**
 *
 * @export
 * @interface MagicLinkAttributes
 */
export interface MagicLinkAttributes {
  /**
   * Magic Link Token
   * @type {string}
   * @memberof MagicLinkAttributes
   */
  token: string;
  /**
   * Magic Link description
   * @type {string}
   * @memberof MagicLinkAttributes
   */
  label: string;
}
/**
 *
 * @export
 * @interface MagicLinkAttributes1
 */
export interface MagicLinkAttributes1 {
  /**
   * Redirection destination
   * @type {string}
   * @memberof MagicLinkAttributes1
   */
  redirect_url: string;
  /**
   * Magic Link description
   * @type {string}
   * @memberof MagicLinkAttributes1
   */
  label: string;
}
/**
 *
 * @export
 * @interface MagicLinkIndexResponse
 */
export interface MagicLinkIndexResponse {
  /**
   *
   * @type {Array<MagicLink>}
   * @memberof MagicLinkIndexResponse
   */
  data: Array<MagicLink>;
}
/**
 *
 * @export
 * @interface MagicLinkItemResponse
 */
export interface MagicLinkItemResponse {
  /**
   *
   * @type {MagicLink}
   * @memberof MagicLinkItemResponse
   */
  data: MagicLink;
}
/**
 *
 * @export
 * @interface MagicLinkLinks
 */
export interface MagicLinkLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof MagicLinkLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof MagicLinkLinks
   */
  sign_in: ResourceLink;
}
/**
 *
 * @export
 * @interface MagicLinkLinks1
 */
export interface MagicLinkLinks1 {
  /**
   *
   * @type {GetActionLink}
   * @memberof MagicLinkLinks1
   */
  self: GetActionLink;
  /**
   *
   * @type {GetActionLink}
   * @memberof MagicLinkLinks1
   */
  magic_link: GetActionLink;
}
/**
 *
 * @export
 * @interface MagicLinkRedirect
 */
export interface MagicLinkRedirect {
  /**
   * Magic Token ID
   * @type {string}
   * @memberof MagicLinkRedirect
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MagicLinkRedirect
   */
  type: MagicLinkRedirectTypeEnum;
  /**
   *
   * @type {MagicLinkAttributes1}
   * @memberof MagicLinkRedirect
   */
  attributes: MagicLinkAttributes1;
  /**
   *
   * @type {MagicLinkLinks1}
   * @memberof MagicLinkRedirect
   */
  links: MagicLinkLinks1;
}

export const MagicLinkRedirectTypeEnum = {
  MagicLinkRedirect: "magic_link_redirect",
} as const;

export type MagicLinkRedirectTypeEnum =
  (typeof MagicLinkRedirectTypeEnum)[keyof typeof MagicLinkRedirectTypeEnum];

/**
 *
 * @export
 * @interface MetaForReadRequest
 */
export interface MetaForReadRequest {
  /**
   * Component ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof MetaForReadRequest
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof MetaForReadRequest
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  resource_id?: string;
  /**
   * Action HTTP method
   * @type {string}
   * @memberof MetaForReadRequest
   */
  action_method: MetaForReadRequestActionMethodEnum;
}

export const MetaForReadRequestActionMethodEnum = {
  Get: "GET",
} as const;

export type MetaForReadRequestActionMethodEnum =
  (typeof MetaForReadRequestActionMethodEnum)[keyof typeof MetaForReadRequestActionMethodEnum];

/**
 *
 * @export
 * @interface MetaForWriteRequest
 */
export interface MetaForWriteRequest {
  /**
   * Component ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  resource_id?: string;
  /**
   * Action HTTP method
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_method: MetaForWriteRequestActionMethodEnum;
  /**
   * Encoding of the payload
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_enctype: MetaForWriteRequestActionEnctypeEnum;
  /**
   * URL to goes after submitting a valid request
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_target?: string;
}

export const MetaForWriteRequestActionMethodEnum = {
  Post: "POST",
  Delete: "DELETE",
  Put: "PUT",
} as const;

export type MetaForWriteRequestActionMethodEnum =
  (typeof MetaForWriteRequestActionMethodEnum)[keyof typeof MetaForWriteRequestActionMethodEnum];
export const MetaForWriteRequestActionEnctypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  MultipartFormData: "multipart/form-data",
} as const;

export type MetaForWriteRequestActionEnctypeEnum =
  (typeof MetaForWriteRequestActionEnctypeEnum)[keyof typeof MetaForWriteRequestActionEnctypeEnum];

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Error title, starting with HTTP Code, like 400: bad request
   * @type {string}
   * @memberof ModelError
   */
  error: string;
  /**
   * Error detail, mostly validation error
   * @type {string}
   * @memberof ModelError
   */
  error_description: string;
  /**
   * authentification state
   * @type {string}
   * @memberof ModelError
   */
  state?: string;
}
/**
 * @type OauthGrantParam
 * @export
 */
export type OauthGrantParam =
  | ClientCredential
  | PasswordGrantImpersonate
  | PasswordGrantLogin;

/**
 *
 * @export
 * @interface Organization
 */
export interface Organization {
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  type: OrganizationTypeEnum;
  /**
   *
   * @type {OrganizationAttributes}
   * @memberof Organization
   */
  attributes: OrganizationAttributes;
  /**
   *
   * @type {OrganizationMetadata}
   * @memberof Organization
   */
  meta: OrganizationMetadata;
}

export const OrganizationTypeEnum = {
  Organization: "organization",
} as const;

export type OrganizationTypeEnum =
  (typeof OrganizationTypeEnum)[keyof typeof OrganizationTypeEnum];

/**
 *
 * @export
 * @interface OrganizationAttributes
 */
export interface OrganizationAttributes {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof OrganizationAttributes
   */
  name: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof OrganizationAttributes
   */
  description?: { [key: string]: string };
  /**
   * Prefix for the organization. Used to prefix uplodaded files and reference resources
   * @type {string}
   * @memberof OrganizationAttributes
   */
  reference_prefix?: string;
  /**
   *
   * @type {string}
   * @memberof OrganizationAttributes
   */
  host: string;
  /**
   * True if welcome email is sent to users
   * @type {boolean}
   * @memberof OrganizationAttributes
   */
  send_welcome_notification?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationAttributes
   */
  secondary_hosts?: Array<string>;
  /**
   *
   * @type {Array<Locale>}
   * @memberof OrganizationAttributes
   */
  available_locales: Array<Locale>;
  /**
   * defaut locale for the organization
   * @type {string}
   * @memberof OrganizationAttributes
   */
  default_locale: string;
  /**
   * Define user registration mode:  - `enabled`: Enable users registration - `existing`: Existing users will be able to login. Registration will be disabled. - `disabled`: No registration enabled
   * @type {string}
   * @memberof OrganizationAttributes
   */
  users_registration_mode?: OrganizationAttributesUsersRegistrationModeEnum;
  /**
   * Force users to authenticate before accessing the organization (disabled if users_registration_mode is `disabled`)
   * @type {boolean}
   * @memberof OrganizationAttributes
   */
  force_users_to_authenticate_before_access_organization?: boolean;
  /**
   * Enable badges for public views
   * @type {boolean}
   * @memberof OrganizationAttributes
   */
  badges_enabled?: boolean;
  /**
   * Display areas and scopes filter in public views.
   * @type {boolean}
   * @memberof OrganizationAttributes
   */
  enable_participatory_space_filters?: boolean;
  /**
   * Enable machine translations (must be configured, see [Using machine translations](https://docs.decidim.org/en/develop/develop/machine_translations.html))
   * @type {boolean}
   * @memberof OrganizationAttributes
   */
  enable_machine_translations?: boolean;
  /**
   * Enable user groups in public views
   * @type {boolean}
   * @memberof OrganizationAttributes
   */
  user_groups_enabled?: boolean;
  /**
   *
   * @type {TimeZone}
   * @memberof OrganizationAttributes
   */
  time_zone?: TimeZone;
  /**
   * Default maximum length of comments
   * @type {number}
   * @memberof OrganizationAttributes
   */
  comments_max_length?: number;
  /**
   * Enable rich text editor in public views
   * @type {boolean}
   * @memberof OrganizationAttributes
   */
  rich_text_editor_in_public_views?: boolean;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  created_at?: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  updated_at?: string;
  /**
   * Extended data for the organization
   * @type {object}
   * @memberof OrganizationAttributes
   */
  extended_data?: object;
}

export const OrganizationAttributesUsersRegistrationModeEnum = {
  Enabled: "enabled",
  Existing: "existing",
  Disabled: "disabled",
} as const;

export type OrganizationAttributesUsersRegistrationModeEnum =
  (typeof OrganizationAttributesUsersRegistrationModeEnum)[keyof typeof OrganizationAttributesUsersRegistrationModeEnum];

/**
 *
 * @export
 * @interface OrganizationIndexResponse
 */
export interface OrganizationIndexResponse {
  /**
   *
   * @type {Array<Organization>}
   * @memberof OrganizationIndexResponse
   */
  data: Array<Organization>;
}
/**
 *
 * @export
 * @interface OrganizationItemResponse
 */
export interface OrganizationItemResponse {
  /**
   *
   * @type {Organization}
   * @memberof OrganizationItemResponse
   */
  data: Organization;
}
/**
 *
 * @export
 * @interface OrganizationMetadata
 */
export interface OrganizationMetadata {
  /**
   *
   * @type {Array<Locale>}
   * @memberof OrganizationMetadata
   */
  locales: Array<Locale>;
  /**
   * If host update is pending, unconfirmed host for the organization
   * @type {string}
   * @memberof OrganizationMetadata
   */
  unconfirmed_host?: string;
}
/**
 *
 * @export
 * @interface OtherComponent
 */
export interface OtherComponent {
  /**
   * Generic Component Id
   * @type {string}
   * @memberof OtherComponent
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof OtherComponent
   */
  type?: OtherComponentTypeEnum;
  /**
   *
   * @type {OtherComponentAttributes}
   * @memberof OtherComponent
   */
  attributes?: OtherComponentAttributes;
  /**
   *
   * @type {GenericComponentMetadata}
   * @memberof OtherComponent
   */
  meta?: GenericComponentMetadata;
  /**
   *
   * @type {GenericComponentLinks}
   * @memberof OtherComponent
   */
  links?: GenericComponentLinks;
  /**
   *
   * @type {GenericComponentRelationships}
   * @memberof OtherComponent
   */
  relationships?: GenericComponentRelationships;
}

export const OtherComponentTypeEnum = {
  PageComponent: "page_component",
  MeetingComponent: "meeting_component",
  BudgetComponent: "budget_component",
  SurveyComponent: "survey_component",
  AccountabilityComponent: "accountability_component",
  DebateComponent: "debate_component",
  SortitionComponent: "sortition_component",
  AwesomeMapComponent: "awesome_map_component",
  AwesomeIframeComponent: "awesome_iframe_component",
} as const;

export type OtherComponentTypeEnum =
  (typeof OtherComponentTypeEnum)[keyof typeof OtherComponentTypeEnum];

/**
 *
 * @export
 * @interface OtherComponentAttributes
 */
export interface OtherComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof OtherComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof OtherComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof OtherComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  manifest_name: OtherComponentAttributesManifestNameEnum;
}

export const OtherComponentAttributesManifestNameEnum = {
  Pages: "pages",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type OtherComponentAttributesManifestNameEnum =
  (typeof OtherComponentAttributesManifestNameEnum)[keyof typeof OtherComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface PasswordGrantImpersonate
 */
export interface PasswordGrantImpersonate {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user impersonation**
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  grant_type: PasswordGrantImpersonateGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  auth_type: PasswordGrantImpersonateAuthTypeEnum;
  /**
   * User nickname, unique and at least 6 alphanumeric chars.
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  username?: string;
  /**
   * User id, will find over id and ignore username. Fails if register_on_missing=true.
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  id?: string;
  /**
   *
   * @type {UserImpersonationSettings}
   * @memberof PasswordGrantImpersonate
   */
  meta?: UserImpersonationSettings;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  scope: PasswordGrantImpersonateScopeEnum;
}

export const PasswordGrantImpersonateGrantTypeEnum = {
  Password: "password",
} as const;

export type PasswordGrantImpersonateGrantTypeEnum =
  (typeof PasswordGrantImpersonateGrantTypeEnum)[keyof typeof PasswordGrantImpersonateGrantTypeEnum];
export const PasswordGrantImpersonateAuthTypeEnum = {
  Impersonate: "impersonate",
} as const;

export type PasswordGrantImpersonateAuthTypeEnum =
  (typeof PasswordGrantImpersonateAuthTypeEnum)[keyof typeof PasswordGrantImpersonateAuthTypeEnum];
export const PasswordGrantImpersonateScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type PasswordGrantImpersonateScopeEnum =
  (typeof PasswordGrantImpersonateScopeEnum)[keyof typeof PasswordGrantImpersonateScopeEnum];

/**
 *
 * @export
 * @interface PasswordGrantLogin
 */
export interface PasswordGrantLogin {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user login**
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  grant_type: PasswordGrantLoginGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  auth_type: PasswordGrantLoginAuthTypeEnum;
  /**
   * User nickname
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  username: string;
  /**
   * User password
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  password: string;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  scope: PasswordGrantLoginScopeEnum;
}

export const PasswordGrantLoginGrantTypeEnum = {
  Password: "password",
} as const;

export type PasswordGrantLoginGrantTypeEnum =
  (typeof PasswordGrantLoginGrantTypeEnum)[keyof typeof PasswordGrantLoginGrantTypeEnum];
export const PasswordGrantLoginAuthTypeEnum = {
  Login: "login",
} as const;

export type PasswordGrantLoginAuthTypeEnum =
  (typeof PasswordGrantLoginAuthTypeEnum)[keyof typeof PasswordGrantLoginAuthTypeEnum];
export const PasswordGrantLoginScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type PasswordGrantLoginScopeEnum =
  (typeof PasswordGrantLoginScopeEnum)[keyof typeof PasswordGrantLoginScopeEnum];

/**
 * @type PasswordGrantParam
 * @export
 */
export type PasswordGrantParam = PasswordGrantImpersonate | PasswordGrantLogin;

/**
 *
 * @export
 * @interface PostActionLink
 */
export interface PostActionLink {
  /**
   * Action Name
   * @type {string}
   * @memberof PostActionLink
   */
  title: string;
  /**
   * Full URL
   * @type {string}
   * @memberof PostActionLink
   */
  href: string;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof PostActionLink
   */
  describedby?: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof PostActionLink
   */
  hreflang?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof PostActionLink
   */
  rel: PostActionLinkRelEnum;
  /**
   *
   * @type {MetaForWriteRequest}
   * @memberof PostActionLink
   */
  meta: MetaForWriteRequest;
}

export const PostActionLinkRelEnum = {
  Action: "action",
} as const;

export type PostActionLinkRelEnum =
  (typeof PostActionLinkRelEnum)[keyof typeof PostActionLinkRelEnum];

/**
 *
 * @export
 * @interface Proposal
 */
export interface Proposal {
  /**
   * Proposal Id
   * @type {string}
   * @memberof Proposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Proposal
   */
  type: ProposalTypeEnum;
  /**
   *
   * @type {ProposalAttributes}
   * @memberof Proposal
   */
  attributes: ProposalAttributes;
  /**
   *
   * @type {ProposalMetadata}
   * @memberof Proposal
   */
  meta: ProposalMetadata;
  /**
   *
   * @type {ProposalLinks1}
   * @memberof Proposal
   */
  links: ProposalLinks1;
  /**
   *
   * @type {ProposalRelationships}
   * @memberof Proposal
   */
  relationships?: ProposalRelationships;
}

export const ProposalTypeEnum = {
  Proposal: "proposal",
} as const;

export type ProposalTypeEnum =
  (typeof ProposalTypeEnum)[keyof typeof ProposalTypeEnum];

/**
 *
 * @export
 * @interface ProposalAttributes
 */
export interface ProposalAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalAttributes
   */
  body: TranslatedProp;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof ProposalAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof ProposalAttributes
   */
  updated_at: string;
}
/**
 * A proposal component can host proposals from participants, and official proposals (proposals from the organization). This component have many metadatas that explain what are the restrictions regarding proposing, voting, commenting, amending or endorsing.   Features toggles:  - `can_create_proposals`: If participants can create proposals - `can_vote`: If participants can vote - `can_comment`: If participants can comments - .... and some more
 * @export
 * @interface ProposalComponent
 */
export interface ProposalComponent {
  /**
   * Proposal Component Id
   * @type {string}
   * @memberof ProposalComponent
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ProposalComponent
   */
  type?: ProposalComponentTypeEnum;
  /**
   *
   * @type {ProposalComponentAttributes}
   * @memberof ProposalComponent
   */
  attributes?: ProposalComponentAttributes;
  /**
   *
   * @type {ProposalComponentMetadata}
   * @memberof ProposalComponent
   */
  meta?: ProposalComponentMetadata;
  /**
   *
   * @type {ProposalComponentLinks}
   * @memberof ProposalComponent
   */
  links?: ProposalComponentLinks;
  /**
   *
   * @type {ProposalComponentRelationships}
   * @memberof ProposalComponent
   */
  relationships?: ProposalComponentRelationships;
}

export const ProposalComponentTypeEnum = {
  ProposalComponent: "proposal_component",
} as const;

export type ProposalComponentTypeEnum =
  (typeof ProposalComponentTypeEnum)[keyof typeof ProposalComponentTypeEnum];

/**
 *
 * @export
 * @interface ProposalComponentAttributes
 */
export interface ProposalComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof ProposalComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  manifest_name: ProposalComponentAttributesManifestNameEnum;
}

export const ProposalComponentAttributesManifestNameEnum = {
  Proposals: "proposals",
} as const;

export type ProposalComponentAttributesManifestNameEnum =
  (typeof ProposalComponentAttributesManifestNameEnum)[keyof typeof ProposalComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface ProposalComponentIndexResponse
 */
export interface ProposalComponentIndexResponse {
  /**
   *
   * @type {Array<ProposalComponent>}
   * @memberof ProposalComponentIndexResponse
   */
  data: Array<ProposalComponent>;
}
/**
 *
 * @export
 * @interface ProposalComponentItemResponse
 */
export interface ProposalComponentItemResponse {
  /**
   *
   * @type {ProposalComponent}
   * @memberof ProposalComponentItemResponse
   */
  data: ProposalComponent;
}
/**
 *
 * @export
 * @interface ProposalComponentLinkedResources
 */
export interface ProposalComponentLinkedResources {
  /**
   *
   * @type {Array<ComponentLinkedResourcesDataInner>}
   * @memberof ProposalComponentLinkedResources
   */
  data: Array<ComponentLinkedResourcesDataInner>;
  /**
   *
   * @type {ProposalComponentLinkedResourcesMetadata}
   * @memberof ProposalComponentLinkedResources
   */
  meta: ProposalComponentLinkedResourcesMetadata;
}
/**
 *
 * @export
 * @interface ProposalComponentLinkedResourcesMetadata
 */
export interface ProposalComponentLinkedResourcesMetadata {
  /**
   * Total count of resources
   * @type {number}
   * @memberof ProposalComponentLinkedResourcesMetadata
   */
  count: number;
}
/**
 *
 * @export
 * @interface ProposalComponentLinks
 */
export interface ProposalComponentLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalComponentLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalComponentLinks
   */
  related?: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalComponentLinks
   */
  draft?: ResourceLink;
}
/**
 *
 * @export
 * @interface ProposalComponentMetadata
 */
export interface ProposalComponentMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  published: boolean;
  /**
   * Proposal Component handle scopes?
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  scopes_enabled: boolean;
  /**
   * If the current user can create proposal (component allows, and user did not reach publication limit)
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  can_create_proposals: boolean;
  /**
   * If the current user can vote on the component
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  can_vote: boolean;
  /**
   * If the current user comment on the component
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  can_comment: boolean;
  /**
   * If the component needs a map to display its resources
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  geocoding_enabled: boolean;
  /**
   * If the component allows to attach files to resources
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  attachments_allowed: boolean;
  /**
   * If you can create collaborative draft for the proposal
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  collaborative_drafts_enabled?: boolean;
  /**
   * If you can comment on proposals
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  comments_enabled?: boolean;
  /**
   * Characters limit for comment
   * @type {number}
   * @memberof ProposalComponentMetadata
   */
  comments_max_length?: number;
  /**
   * Default order of proposals
   * @type {string}
   * @memberof ProposalComponentMetadata
   */
  default_sort_order?: ProposalComponentMetadataDefaultSortOrderEnum;
  /**
   * If proposals can be official
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  official_proposals_enabled?: boolean;
  /**
   * If proposals are based on a text modification
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  participatory_texts_enabled?: boolean;
  /**
   * Time in minute participant can edit the proposal
   * @type {number}
   * @memberof ProposalComponentMetadata
   */
  proposal_edit_before_minutes?: number;
  /**
   * Type of restriction for proposal edition
   * @type {string}
   * @memberof ProposalComponentMetadata
   */
  proposal_edit_time?: ProposalComponentMetadataProposalEditTimeEnum;
  /**
   * Max proposal per participant. No maximum if value is 0
   * @type {number}
   * @memberof ProposalComponentMetadata
   */
  proposal_limit?: number;
  /**
   * If authorizations can be defined per proposal
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  resources_permissions_enabled?: boolean;
  /**
   * Threshold to compare similar proposals
   * @type {number}
   * @memberof ProposalComponentMetadata
   */
  threshold_per_proposal?: number;
  /**
   * Max Number of vote per participant. 0 if no limit
   * @type {number}
   * @memberof ProposalComponentMetadata
   */
  vote_limit: number;
  /**
   * If endorsements are enabled
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  endorsements_enabled?: boolean;
  /**
   * If votes on proposal are enabled
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  votes_enabled?: boolean;
  /**
   * If participant can create proposal are enabled
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  creation_enabled?: boolean;
  /**
   * If officials can answer proposals
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  proposal_answering_enabled?: boolean;
  /**
   * If participant can propose an amendment to a proposal
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  amendment_creation_enabled?: boolean;
  /**
   * If participant can react to an amendment of a proposal
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  amendment_reaction_enabled?: boolean;
  /**
   * If participant choose an amendment to replace their initial proposal
   * @type {boolean}
   * @memberof ProposalComponentMetadata
   */
  amendment_promotion_enabled?: boolean;
  /**
   * Vote weight, if can_vote is true.
   * @type {Array<ProposalVoteWeight>}
   * @memberof ProposalComponentMetadata
   */
  votes?: Array<ProposalVoteWeight>;
}

export const ProposalComponentMetadataDefaultSortOrderEnum = {
  Random: "random",
  Recent: "recent",
  MostVoted: "most_voted",
  MostEndorsed: "most_endorsed",
  MostCommented: "most_commented",
  MostFollowed: "most_followed",
  WithMoreAuthors: "with_more_authors",
  Automatic: "automatic",
  Default: "default",
} as const;

export type ProposalComponentMetadataDefaultSortOrderEnum =
  (typeof ProposalComponentMetadataDefaultSortOrderEnum)[keyof typeof ProposalComponentMetadataDefaultSortOrderEnum];
export const ProposalComponentMetadataProposalEditTimeEnum = {
  Infinite: "infinite",
  Limited: "limited",
} as const;

export type ProposalComponentMetadataProposalEditTimeEnum =
  (typeof ProposalComponentMetadataProposalEditTimeEnum)[keyof typeof ProposalComponentMetadataProposalEditTimeEnum];

/**
 *
 * @export
 * @interface ProposalComponentRelationships
 */
export interface ProposalComponentRelationships {
  /**
   *
   * @type {ProposalComponentLinkedResources}
   * @memberof ProposalComponentRelationships
   */
  resources?: ProposalComponentLinkedResources;
}
/**
 *
 * @export
 * @interface ProposalIndexResponse
 */
export interface ProposalIndexResponse {
  /**
   *
   * @type {Array<Proposal>}
   * @memberof ProposalIndexResponse
   */
  data: Array<Proposal>;
}
/**
 *
 * @export
 * @interface ProposalItemResponse
 */
export interface ProposalItemResponse {
  /**
   *
   * @type {Proposal}
   * @memberof ProposalItemResponse
   */
  data: Proposal;
}
/**
 *
 * @export
 * @interface ProposalLinks
 */
export interface ProposalLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks
   */
  collection: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks
   */
  related: ResourceLink;
}
/**
 *
 * @export
 * @interface ProposalLinks1
 */
export interface ProposalLinks1 {
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  collection: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  related: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  prev?: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  next?: ResourceLink;
}
/**
 *
 * @export
 * @interface ProposalMetadata
 */
export interface ProposalMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof ProposalMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof ProposalMetadata
   */
  scope?: number;
  /**
   *
   * @type {CurrentUserProposalVoteMetadata}
   * @memberof ProposalMetadata
   */
  voted?: CurrentUserProposalVoteMetadata | null;
}
/**
 *
 * @export
 * @interface ProposalRelationships
 */
export interface ProposalRelationships {
  /**
   *
   * @type {ProposalStateRelationship}
   * @memberof ProposalRelationships
   */
  state?: ProposalStateRelationship;
  /**
   *
   * @type {LinkedSpace1}
   * @memberof ProposalRelationships
   */
  space: LinkedSpace1;
  /**
   *
   * @type {LinkedProposalComponent}
   * @memberof ProposalRelationships
   */
  component: LinkedProposalComponent;
  /**
   *
   * @type {ProposalSAuthor}
   * @memberof ProposalRelationships
   */
  author?: ProposalSAuthor;
  /**
   *
   * @type {ProposalSCoauthors}
   * @memberof ProposalRelationships
   */
  coauthors?: ProposalSCoauthors;
}
/**
 *
 * @export
 * @interface ProposalSAuthor
 */
export interface ProposalSAuthor {
  /**
   *
   * @type {ProposalSAuthorData}
   * @memberof ProposalSAuthor
   */
  data: ProposalSAuthorData;
}
/**
 *
 * @export
 * @interface ProposalSAuthorData
 */
export interface ProposalSAuthorData {
  /**
   * Resource Id
   * @type {string}
   * @memberof ProposalSAuthorData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ProposalSAuthorData
   */
  type: ProposalSAuthorDataTypeEnum;
}

export const ProposalSAuthorDataTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type ProposalSAuthorDataTypeEnum =
  (typeof ProposalSAuthorDataTypeEnum)[keyof typeof ProposalSAuthorDataTypeEnum];

/**
 *
 * @export
 * @interface ProposalSCoauthors
 */
export interface ProposalSCoauthors {
  /**
   *
   * @type {Array<DraftProposalCoauthorsDataInner>}
   * @memberof ProposalSCoauthors
   */
  data: Array<DraftProposalCoauthorsDataInner>;
}
/**
 *
 * @export
 * @interface ProposalStateRelationship
 */
export interface ProposalStateRelationship {
  /**
   *
   * @type {ProposalStateRelationshipData}
   * @memberof ProposalStateRelationship
   */
  data: ProposalStateRelationshipData;
  /**
   *
   * @type {ProposalStateRelationshipMetadata}
   * @memberof ProposalStateRelationship
   */
  meta: ProposalStateRelationshipMetadata;
}
/**
 *
 * @export
 * @interface ProposalStateRelationshipData
 */
export interface ProposalStateRelationshipData {
  /**
   * Resource Id
   * @type {string}
   * @memberof ProposalStateRelationshipData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ProposalStateRelationshipData
   */
  type: ProposalStateRelationshipDataTypeEnum;
}

export const ProposalStateRelationshipDataTypeEnum = {
  ProposalState: "proposal_state",
} as const;

export type ProposalStateRelationshipDataTypeEnum =
  (typeof ProposalStateRelationshipDataTypeEnum)[keyof typeof ProposalStateRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface ProposalStateRelationshipMetadata
 */
export interface ProposalStateRelationshipMetadata {
  /**
   * Proposal State token
   * @type {string}
   * @memberof ProposalStateRelationshipMetadata
   */
  token: string;
}
/**
 *
 * @export
 * @interface ProposalVoteWeight
 */
export interface ProposalVoteWeight {
  /**
   * Label to voting button
   * @type {string}
   * @memberof ProposalVoteWeight
   */
  label: string;
  /**
   * Value to add to the vote. 0 for abstention
   * @type {number}
   * @memberof ProposalVoteWeight
   */
  weight: number;
}
/**
 *
 * @export
 * @interface ResourceAttributes
 */
export interface ResourceAttributes {
  /**
   * Email
   * @type {string}
   * @memberof ResourceAttributes
   */
  email: string;
  /**
   * Last update date
   * @type {string}
   * @memberof ResourceAttributes
   */
  updated_at: string;
  /**
   * Creation date
   * @type {string}
   * @memberof ResourceAttributes
   */
  created_at: string;
  /**
   * Personal url (social link, website, etc.)
   * @type {string}
   * @memberof ResourceAttributes
   */
  personal_url?: string;
  /**
   * Current prefered locale
   * @type {string}
   * @memberof ResourceAttributes
   */
  locale?: ResourceAttributesLocaleEnum;
}

export const ResourceAttributesLocaleEnum = {
  En: "en",
  Fr: "fr",
} as const;

export type ResourceAttributesLocaleEnum =
  (typeof ResourceAttributesLocaleEnum)[keyof typeof ResourceAttributesLocaleEnum];

/**
 *
 * @export
 * @interface ResourceDetails
 */
export interface ResourceDetails {
  /**
   * resource id
   * @type {string}
   * @memberof ResourceDetails
   */
  id: string;
  /**
   * resource type
   * @type {string}
   * @memberof ResourceDetails
   */
  type: ResourceDetailsTypeEnum;
  /**
   *
   * @type {ResourceAttributes}
   * @memberof ResourceDetails
   */
  attributes?: ResourceAttributes;
}

export const ResourceDetailsTypeEnum = {
  User: "user",
} as const;

export type ResourceDetailsTypeEnum =
  (typeof ResourceDetailsTypeEnum)[keyof typeof ResourceDetailsTypeEnum];

/**
 *
 * @export
 * @interface ResourceLink
 */
export interface ResourceLink {
  /**
   * Full URL
   * @type {string}
   * @memberof ResourceLink
   */
  href: string;
  /**
   * Page Title
   * @type {string}
   * @memberof ResourceLink
   */
  title: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof ResourceLink
   */
  hreflang?: Array<string>;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof ResourceLink
   */
  describedby?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceLink
   */
  rel: ResourceLinkRelEnum;
  /**
   *
   * @type {ResourceURLMetadata}
   * @memberof ResourceLink
   */
  meta: ResourceURLMetadata;
}

export const ResourceLinkRelEnum = {
  PublicPage: "public_page",
  Resource: "resource",
} as const;

export type ResourceLinkRelEnum =
  (typeof ResourceLinkRelEnum)[keyof typeof ResourceLinkRelEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const ResourceManifest = {
  Page: "page",
  Proposal: "proposal",
  Meeting: "meeting",
  Budget: "budget",
  Survey: "survey",
  Accountability: "accountability",
  Debate: "debate",
  Sortition: "sortition",
  Blog: "blog",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type ResourceManifest =
  (typeof ResourceManifest)[keyof typeof ResourceManifest];

/**
 *
 * @export
 * @interface ResourceURLMetadata
 */
export interface ResourceURLMetadata {
  /**
   * Component ID
   * @type {string}
   * @memberof ResourceURLMetadata
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof ResourceURLMetadata
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof ResourceURLMetadata
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof ResourceURLMetadata
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof ResourceURLMetadata
   */
  resource_id?: string;
}
/**
 *
 * @export
 * @interface Space
 */
export interface Space {
  /**
   * Space Id
   * @type {string}
   * @memberof Space
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Space
   */
  type: SpaceTypeEnum;
  /**
   *
   * @type {SpaceAttributes}
   * @memberof Space
   */
  attributes: SpaceAttributes;
  /**
   *
   * @type {SpaceRelationships}
   * @memberof Space
   */
  relationships: SpaceRelationships;
  /**
   *
   * @type {SpaceLinks}
   * @memberof Space
   */
  links: SpaceLinks;
}

export const SpaceTypeEnum = {
  Space: "space",
} as const;

export type SpaceTypeEnum = (typeof SpaceTypeEnum)[keyof typeof SpaceTypeEnum];

/**
 *
 * @export
 * @interface SpaceAttributes
 */
export interface SpaceAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  subtitle?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  short_description?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  description?: TranslatedProp;
  /**
   *
   * @type {SpaceManifest}
   * @memberof SpaceAttributes
   */
  manifest_name: SpaceManifest;
  /**
   *
   * @type {string}
   * @memberof SpaceAttributes
   */
  participatory_space_type?: string;
  /**
   * Space visibility
   * @type {string}
   * @memberof SpaceAttributes
   */
  visibility: SpaceAttributesVisibilityEnum;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  updated_at: string;
}

export const SpaceAttributesVisibilityEnum = {
  Public: "public",
  Transparent: "transparent",
  Private: "private",
} as const;

export type SpaceAttributesVisibilityEnum =
  (typeof SpaceAttributesVisibilityEnum)[keyof typeof SpaceAttributesVisibilityEnum];

/**
 * space class name. Part of the polymorphic association (participatory_space_type,participatory_space_id)
 * @export
 * @enum {string}
 */

export const SpaceClasses = {
  ParticipatoryProcess: "Decidim::ParticipatoryProcess",
  Assembly: "Decidim::Assembly",
} as const;

export type SpaceClasses = (typeof SpaceClasses)[keyof typeof SpaceClasses];

/**
 *
 * @export
 * @interface SpaceComponentLinks
 */
export interface SpaceComponentLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof SpaceComponentLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof SpaceComponentLinks
   */
  related?: ResourceLink;
}
/**
 *
 * @export
 * @interface SpaceComponentMetadata
 */
export interface SpaceComponentMetadata {
  /**
   * Total count for components association
   * @type {number}
   * @memberof SpaceComponentMetadata
   */
  count: number;
}
/**
 *
 * @export
 * @interface SpaceComponentRelationships
 */
export interface SpaceComponentRelationships {
  /**
   *
   * @type {Array<SpaceComponentRelationshipsDataInner>}
   * @memberof SpaceComponentRelationships
   */
  data: Array<SpaceComponentRelationshipsDataInner>;
  /**
   *
   * @type {SpaceComponentMetadata}
   * @memberof SpaceComponentRelationships
   */
  meta: SpaceComponentMetadata;
  /**
   *
   * @type {SpaceComponentLinks}
   * @memberof SpaceComponentRelationships
   */
  links: SpaceComponentLinks;
}
/**
 *
 * @export
 * @interface SpaceComponentRelationshipsDataInner
 */
export interface SpaceComponentRelationshipsDataInner {
  /**
   * Resource Id
   * @type {string}
   * @memberof SpaceComponentRelationshipsDataInner
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof SpaceComponentRelationshipsDataInner
   */
  type: ComponentType;
}

/**
 *
 * @export
 * @interface SpaceIndexResponse
 */
export interface SpaceIndexResponse {
  /**
   *
   * @type {Array<Space>}
   * @memberof SpaceIndexResponse
   */
  data: Array<Space>;
}
/**
 *
 * @export
 * @interface SpaceItemResponse
 */
export interface SpaceItemResponse {
  /**
   *
   * @type {Space}
   * @memberof SpaceItemResponse
   */
  data: Space;
}
/**
 *
 * @export
 * @interface SpaceLinks
 */
export interface SpaceLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof SpaceLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof SpaceLinks
   */
  related: ResourceLink;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SpaceManifest = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceManifest = (typeof SpaceManifest)[keyof typeof SpaceManifest];

/**
 *
 * @export
 * @interface SpaceRelationships
 */
export interface SpaceRelationships {
  /**
   *
   * @type {SpaceComponentRelationships}
   * @memberof SpaceRelationships
   */
  components?: SpaceComponentRelationships;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SpaceType = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceType = (typeof SpaceType)[keyof typeof SpaceType];

/**
 * Time Zone identifier
 * @export
 * @enum {string}
 */

export const TimeZone = {
  AfricaAlgiers: "Africa/Algiers",
  AfricaCairo: "Africa/Cairo",
  AfricaCasablanca: "Africa/Casablanca",
  AfricaHarare: "Africa/Harare",
  AfricaJohannesburg: "Africa/Johannesburg",
  AfricaMonrovia: "Africa/Monrovia",
  AfricaNairobi: "Africa/Nairobi",
  AmericaArgentinaBuenosAires: "America/Argentina/Buenos_Aires",
  AmericaBogota: "America/Bogota",
  AmericaCaracas: "America/Caracas",
  AmericaChicago: "America/Chicago",
  AmericaChihuahua: "America/Chihuahua",
  AmericaDenver: "America/Denver",
  AmericaGodthab: "America/Godthab",
  AmericaGuatemala: "America/Guatemala",
  AmericaGuyana: "America/Guyana",
  AmericaHalifax: "America/Halifax",
  AmericaIndianaIndianapolis: "America/Indiana/Indianapolis",
  AmericaJuneau: "America/Juneau",
  AmericaLaPaz: "America/La_Paz",
  AmericaLima: "America/Lima",
  AmericaLima2: "America/Lima",
  AmericaLosAngeles: "America/Los_Angeles",
  AmericaMazatlan: "America/Mazatlan",
  AmericaMexicoCity: "America/Mexico_City",
  AmericaMexicoCity2: "America/Mexico_City",
  AmericaMonterrey: "America/Monterrey",
  AmericaMontevideo: "America/Montevideo",
  AmericaNewYork: "America/New_York",
  AmericaPhoenix: "America/Phoenix",
  AmericaPuertoRico: "America/Puerto_Rico",
  AmericaRegina: "America/Regina",
  AmericaSantiago: "America/Santiago",
  AmericaSaoPaulo: "America/Sao_Paulo",
  AmericaStJohns: "America/St_Johns",
  AmericaTijuana: "America/Tijuana",
  AsiaAlmaty: "Asia/Almaty",
  AsiaBaghdad: "Asia/Baghdad",
  AsiaBaku: "Asia/Baku",
  AsiaBangkok: "Asia/Bangkok",
  AsiaBangkok2: "Asia/Bangkok",
  AsiaChongqing: "Asia/Chongqing",
  AsiaColombo: "Asia/Colombo",
  AsiaDhaka: "Asia/Dhaka",
  AsiaDhaka2: "Asia/Dhaka",
  AsiaHongKong: "Asia/Hong_Kong",
  AsiaIrkutsk: "Asia/Irkutsk",
  AsiaJakarta: "Asia/Jakarta",
  AsiaJerusalem: "Asia/Jerusalem",
  AsiaKabul: "Asia/Kabul",
  AsiaKamchatka: "Asia/Kamchatka",
  AsiaKarachi: "Asia/Karachi",
  AsiaKarachi2: "Asia/Karachi",
  AsiaKathmandu: "Asia/Kathmandu",
  AsiaKolkata: "Asia/Kolkata",
  AsiaKolkata2: "Asia/Kolkata",
  AsiaKolkata3: "Asia/Kolkata",
  AsiaKolkata4: "Asia/Kolkata",
  AsiaKrasnoyarsk: "Asia/Krasnoyarsk",
  AsiaKualaLumpur: "Asia/Kuala_Lumpur",
  AsiaKuwait: "Asia/Kuwait",
  AsiaMagadan: "Asia/Magadan",
  AsiaMuscat: "Asia/Muscat",
  AsiaMuscat2: "Asia/Muscat",
  AsiaNovosibirsk: "Asia/Novosibirsk",
  AsiaRangoon: "Asia/Rangoon",
  AsiaRiyadh: "Asia/Riyadh",
  AsiaSeoul: "Asia/Seoul",
  AsiaShanghai: "Asia/Shanghai",
  AsiaSingapore: "Asia/Singapore",
  AsiaSrednekolymsk: "Asia/Srednekolymsk",
  AsiaTaipei: "Asia/Taipei",
  AsiaTashkent: "Asia/Tashkent",
  AsiaTbilisi: "Asia/Tbilisi",
  AsiaTehran: "Asia/Tehran",
  AsiaTokyo: "Asia/Tokyo",
  AsiaTokyo2: "Asia/Tokyo",
  AsiaTokyo3: "Asia/Tokyo",
  AsiaUlaanbaatar: "Asia/Ulaanbaatar",
  AsiaUrumqi: "Asia/Urumqi",
  AsiaVladivostok: "Asia/Vladivostok",
  AsiaYakutsk: "Asia/Yakutsk",
  AsiaYekaterinburg: "Asia/Yekaterinburg",
  AsiaYerevan: "Asia/Yerevan",
  AtlanticAzores: "Atlantic/Azores",
  AtlanticCapeVerde: "Atlantic/Cape_Verde",
  AtlanticSouthGeorgia: "Atlantic/South_Georgia",
  AustraliaAdelaide: "Australia/Adelaide",
  AustraliaBrisbane: "Australia/Brisbane",
  AustraliaDarwin: "Australia/Darwin",
  AustraliaHobart: "Australia/Hobart",
  AustraliaMelbourne: "Australia/Melbourne",
  AustraliaMelbourne2: "Australia/Melbourne",
  AustraliaPerth: "Australia/Perth",
  AustraliaSydney: "Australia/Sydney",
  EtcGmt12: "Etc/GMT+12",
  EtcUtc: "Etc/UTC",
  EuropeAmsterdam: "Europe/Amsterdam",
  EuropeAthens: "Europe/Athens",
  EuropeBelgrade: "Europe/Belgrade",
  EuropeBerlin: "Europe/Berlin",
  EuropeBratislava: "Europe/Bratislava",
  EuropeBrussels: "Europe/Brussels",
  EuropeBucharest: "Europe/Bucharest",
  EuropeBudapest: "Europe/Budapest",
  EuropeCopenhagen: "Europe/Copenhagen",
  EuropeDublin: "Europe/Dublin",
  EuropeHelsinki: "Europe/Helsinki",
  EuropeIstanbul: "Europe/Istanbul",
  EuropeKaliningrad: "Europe/Kaliningrad",
  EuropeKiev: "Europe/Kiev",
  EuropeLisbon: "Europe/Lisbon",
  EuropeLjubljana: "Europe/Ljubljana",
  EuropeLondon: "Europe/London",
  EuropeLondon2: "Europe/London",
  EuropeMadrid: "Europe/Madrid",
  EuropeMinsk: "Europe/Minsk",
  EuropeMoscow: "Europe/Moscow",
  EuropeMoscow2: "Europe/Moscow",
  EuropeParis: "Europe/Paris",
  EuropePrague: "Europe/Prague",
  EuropeRiga: "Europe/Riga",
  EuropeRome: "Europe/Rome",
  EuropeSamara: "Europe/Samara",
  EuropeSarajevo: "Europe/Sarajevo",
  EuropeSkopje: "Europe/Skopje",
  EuropeSofia: "Europe/Sofia",
  EuropeStockholm: "Europe/Stockholm",
  EuropeTallinn: "Europe/Tallinn",
  EuropeVienna: "Europe/Vienna",
  EuropeVilnius: "Europe/Vilnius",
  EuropeVolgograd: "Europe/Volgograd",
  EuropeWarsaw: "Europe/Warsaw",
  EuropeZagreb: "Europe/Zagreb",
  EuropeZurich: "Europe/Zurich",
  EuropeZurich2: "Europe/Zurich",
  PacificApia: "Pacific/Apia",
  PacificAuckland: "Pacific/Auckland",
  PacificAuckland2: "Pacific/Auckland",
  PacificChatham: "Pacific/Chatham",
  PacificFakaofo: "Pacific/Fakaofo",
  PacificFiji: "Pacific/Fiji",
  PacificGuadalcanal: "Pacific/Guadalcanal",
  PacificGuam: "Pacific/Guam",
  PacificHonolulu: "Pacific/Honolulu",
  PacificMajuro: "Pacific/Majuro",
  PacificMidway: "Pacific/Midway",
  PacificNoumea: "Pacific/Noumea",
  PacificPagoPago: "Pacific/Pago_Pago",
  PacificPortMoresby: "Pacific/Port_Moresby",
  PacificTongatapu: "Pacific/Tongatapu",
  Utc: "UTC",
} as const;

export type TimeZone = (typeof TimeZone)[keyof typeof TimeZone];

/**
 * Hash with translated data, key=locale value=translation
 * @export
 * @interface TranslatedProp
 */
export interface TranslatedProp {
  /**
   * Translation in en
   * @type {string}
   * @memberof TranslatedProp
   */
  en?: string;
  /**
   * Translation in fr
   * @type {string}
   * @memberof TranslatedProp
   */
  fr?: string;
}
/**
 *
 * @export
 * @interface UpdateDraftProposalPayload
 */
export interface UpdateDraftProposalPayload {
  /**
   *
   * @type {UpdateDraftProposalPayloadData}
   * @memberof UpdateDraftProposalPayload
   */
  data: UpdateDraftProposalPayloadData;
}
/**
 * Payload to update in the proposal
 * @export
 * @interface UpdateDraftProposalPayloadData
 */
export interface UpdateDraftProposalPayloadData {
  /**
   * Title of the draft
   * @type {string}
   * @memberof UpdateDraftProposalPayloadData
   */
  title?: string;
  /**
   * Content of the draft
   * @type {string}
   * @memberof UpdateDraftProposalPayloadData
   */
  body?: string;
  /**
   * Locale of the draft. default to user locale
   * @type {string}
   * @memberof UpdateDraftProposalPayloadData
   */
  locale?: UpdateDraftProposalPayloadDataLocaleEnum;
}

export const UpdateDraftProposalPayloadDataLocaleEnum = {
  En: "en",
  Fr: "fr",
} as const;

export type UpdateDraftProposalPayloadDataLocaleEnum =
  (typeof UpdateDraftProposalPayloadDataLocaleEnum)[keyof typeof UpdateDraftProposalPayloadDataLocaleEnum];

/**
 *
 * @export
 * @interface UpdateOrganizationPayload
 */
export interface UpdateOrganizationPayload {
  /**
   *
   * @type {OrganizationAttributes}
   * @memberof UpdateOrganizationPayload
   */
  data: OrganizationAttributes;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  type: UserTypeEnum;
  /**
   *
   * @type {UserMetadata}
   * @memberof User
   */
  meta?: UserMetadata;
  /**
   *
   * @type {UserRelationships}
   * @memberof User
   */
  relationships?: UserRelationships;
  /**
   *
   * @type {UserAttributes}
   * @memberof User
   */
  attributes: UserAttributes;
}

export const UserTypeEnum = {
  User: "user",
} as const;

export type UserTypeEnum = (typeof UserTypeEnum)[keyof typeof UserTypeEnum];

/**
 *
 * @export
 * @interface UserAttributes
 */
export interface UserAttributes {
  /**
   * User name, use to display the Profile identity. Public
   * @type {string}
   * @memberof UserAttributes
   */
  name: string;
  /**
   * User nickname, unique identifier for the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  nickname: string;
  /**
   * Personal website URL or social link. Public
   * @type {string}
   * @memberof UserAttributes
   */
  personal_url?: string;
  /**
   * Short bio of the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  about?: string;
  /**
   *
   * @type {Locale}
   * @memberof UserAttributes
   */
  locale: Locale;
  /**
   * Email of the user. Private
   * @type {string}
   * @memberof UserAttributes
   */
  email?: string;
  /**
   * Additional data. Private
   * @type {{ [key: string]: any; }}
   * @memberof UserAttributes
   */
  extended_data: { [key: string]: any };
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  updated_at: string;
}

/**
 *
 * @export
 * @interface UserExtendedDataPayload
 */
export interface UserExtendedDataPayload {
  /**
   * New value for the extended data at the given path
   * @type {object}
   * @memberof UserExtendedDataPayload
   */
  data: object;
  /**
   * object path, in dot style, like foo.bar. use \'.\' to update the whole user data
   * @type {string}
   * @memberof UserExtendedDataPayload
   */
  object_path?: string;
}
/**
 * Impersonation Settings
 * @export
 * @interface UserImpersonationSettings
 */
export interface UserImpersonationSettings {
  /**
   * Register the user if it does not exists. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  register_on_missing?: boolean;
  /**
   * Accept the TOS on registration, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  accept_tos_on_register?: boolean;
  /**
   * Skip email confirmation on creation, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  skip_confirmation_on_register?: boolean;
  /**
   * User email to use on registration. used only if register_on_missing=true. Default to <username>@example.org
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  email?: string;
  /**
   * User name. Used only if register_on_missing=true. Default to username
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  name?: string;
}
/**
 *
 * @export
 * @interface UserIndexResponse
 */
export interface UserIndexResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof UserIndexResponse
   */
  data: Array<User>;
}
/**
 *
 * @export
 * @interface UserItemResponse
 */
export interface UserItemResponse {
  /**
   *
   * @type {User}
   * @memberof UserItemResponse
   */
  data: User;
}
/**
 *
 * @export
 * @interface UserMetadata
 */
export interface UserMetadata {
  /**
   * If the user is blocked, and need to be unblocked to signin
   * @type {boolean}
   * @memberof UserMetadata
   */
  blocked: boolean;
  /**
   * If the user is locked, and need to click on the mail link to unlock
   * @type {boolean}
   * @memberof UserMetadata
   */
  locked: boolean;
}
/**
 *
 * @export
 * @interface UserRelationships
 */
export interface UserRelationships {
  /**
   *
   * @type {UserRoles}
   * @memberof UserRelationships
   */
  roles?: UserRoles;
}
/**
 *
 * @export
 * @interface UserRole
 */
export interface UserRole {
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  type: UserRoleTypeEnum;
}

export const UserRoleTypeEnum = {
  UserRole: "user_role",
} as const;

export type UserRoleTypeEnum =
  (typeof UserRoleTypeEnum)[keyof typeof UserRoleTypeEnum];

/**
 *
 * @export
 * @interface UserRoles
 */
export interface UserRoles {
  /**
   *
   * @type {Array<UserRole>}
   * @memberof UserRoles
   */
  data: Array<UserRole>;
}
/**
 * Payload to send your vote
 * @export
 * @interface VoteAProposalData
 */
export interface VoteAProposalData {
  /**
   * Weight for your vote
   * @type {number}
   * @memberof VoteAProposalData
   */
  weight: number;
}
/**
 *
 * @export
 * @interface VoteAProposalPayload
 */
export interface VoteAProposalPayload {
  /**
   * Proposal Id
   * @type {number}
   * @memberof VoteAProposalPayload
   */
  proposal_id: number;
  /**
   *
   * @type {VoteAProposalData}
   * @memberof VoteAProposalPayload
   */
  data: VoteAProposalData;
}

/**
 * BlogsApi - axios parameter creator
 * @export
 */
export const BlogsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {number} [componentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog: async (
      id: number,
      locales?: Array<Locale>,
      componentId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("blog", "id", id);
      const localVarPath = `/blogs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get blog post list
     * @summary Blog Post Lists
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {BlogsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {string} [order] Order by
     * @param {BlogsOrderDirectionEnum} [orderDirection] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs: async (
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      spaceManifest?: BlogsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      order?: string,
      orderDirection?: BlogsOrderDirectionEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/blogs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      if (order !== undefined) {
        localVarQueryParameter["order"] = order;
      }

      if (orderDirection !== undefined) {
        localVarQueryParameter["order_direction"] = orderDirection;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BlogsApi - functional programming interface
 * @export
 */
export const BlogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BlogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {number} [componentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blog(
      id: number,
      locales?: Array<Locale>,
      componentId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blog(
        id,
        locales,
        componentId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blog"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get blog post list
     * @summary Blog Post Lists
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {BlogsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {string} [order] Order by
     * @param {BlogsOrderDirectionEnum} [orderDirection] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogs(
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      spaceManifest?: BlogsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      order?: string,
      orderDirection?: BlogsOrderDirectionEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogs(
        locales,
        page,
        perPage,
        spaceManifest,
        spaceId,
        componentId,
        order,
        orderDirection,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blogs"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BlogsApi - factory interface
 * @export
 */
export const BlogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BlogsApiFp(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogsApiBlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog(
      requestParameters: BlogsApiBlogRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogItemResponse> {
      return localVarFp
        .blog(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get blog post list
     * @summary Blog Post Lists
     * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs(
      requestParameters: BlogsApiBlogsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogIndexResponse> {
      return localVarFp
        .blogs(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.order,
          requestParameters.orderDirection,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for blog operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogRequest
 */
export interface BlogsApiBlogRequest {
  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly id: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof BlogsApiBlog
   */
  readonly locales?: Array<Locale>;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly componentId?: number;
}

/**
 * Request parameters for blogs operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogsRequest
 */
export interface BlogsApiBlogsRequest {
  /**
   *
   * @type {Array<Locale>}
   * @memberof BlogsApiBlogs
   */
  readonly locales?: Array<Locale>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly perPage?: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof BlogsApiBlogs
   */
  readonly spaceManifest?: BlogsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly spaceId?: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly componentId?: number;

  /**
   * Order by
   * @type {string}
   * @memberof BlogsApiBlogs
   */
  readonly order?: string;

  /**
   * Order direction
   * @type {'asc' | 'desc'}
   * @memberof BlogsApiBlogs
   */
  readonly orderDirection?: BlogsOrderDirectionEnum;
}

/**
 * BlogsApi - object-oriented interface
 * @export
 * @class BlogsApi
 * @extends {BaseAPI}
 */
export class BlogsApi extends BaseAPI {
  /**
   * Get blog post details
   * @summary Show a blog detail
   * @param {BlogsApiBlogRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blog(
    requestParameters: BlogsApiBlogRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blog(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get blog post list
   * @summary Blog Post Lists
   * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blogs(
    requestParameters: BlogsApiBlogsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blogs(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.order,
        requestParameters.orderDirection,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const BlogsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogsSpaceManifestEnum =
  (typeof BlogsSpaceManifestEnum)[keyof typeof BlogsSpaceManifestEnum];
/**
 * @export
 */
export const BlogsOrderDirectionEnum = {
  Asc: "asc",
  Desc: "desc",
} as const;
export type BlogsOrderDirectionEnum =
  (typeof BlogsOrderDirectionEnum)[keyof typeof BlogsOrderDirectionEnum];

/**
 * ComponentsApi - axios parameter creator
 * @export
 */
export const ComponentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Blog component details
     * @summary Blog Component Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {number} [componentId]
     * @param {BlogComponentSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponent: async (
      id: number,
      locales?: Array<Locale>,
      componentId?: number,
      spaceManifest?: BlogComponentSpaceManifestEnum,
      spaceId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("blogComponent", "id", id);
      const localVarPath = `/components/blog_components/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search blog components of the organization
     * @summary Blog Components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<Locale>} [locales]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {string} [filterParticipatorySpaceIdLt]
     * @param {string} [filterParticipatorySpaceIdGt]
     * @param {boolean} [filterParticipatorySpaceIdPresent]
     * @param {boolean} [filterParticipatorySpaceIdBlank]
     * @param {Array<string>} [filterParticipatorySpaceTypeNotIn]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeStart]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterParticipatorySpaceTypeNotEq]
     * @param {string} [filterParticipatorySpaceTypeMatches]
     * @param {boolean} [filterParticipatorySpaceTypeBlank]
     * @param {Array<string>} [filterNameNotIn]
     * @param {Array<string>} [filterNameIn]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {boolean} [filterNameBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponents: async (
      page?: number,
      perPage?: number,
      locales?: Array<Locale>,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceIdLt?: string,
      filterParticipatorySpaceIdGt?: string,
      filterParticipatorySpaceIdPresent?: boolean,
      filterParticipatorySpaceIdBlank?: boolean,
      filterParticipatorySpaceTypeNotIn?: Array<string>,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeStart?: string,
      filterParticipatorySpaceTypeEq?: string,
      filterParticipatorySpaceTypeNotEq?: string,
      filterParticipatorySpaceTypeMatches?: string,
      filterParticipatorySpaceTypeBlank?: boolean,
      filterNameNotIn?: Array<string>,
      filterNameIn?: Array<string>,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterNameBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/components/blog_components`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceIdLt !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_lt]"] =
          filterParticipatorySpaceIdLt;
      }

      if (filterParticipatorySpaceIdGt !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_gt]"] =
          filterParticipatorySpaceIdGt;
      }

      if (filterParticipatorySpaceIdPresent !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_present]"] =
          filterParticipatorySpaceIdPresent;
      }

      if (filterParticipatorySpaceIdBlank !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_blank]"] =
          filterParticipatorySpaceIdBlank;
      }

      if (filterParticipatorySpaceTypeNotIn) {
        localVarQueryParameter["filter[participatory_space_type_not_in][]"] =
          filterParticipatorySpaceTypeNotIn;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeStart !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_start]"] =
          filterParticipatorySpaceTypeStart;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterParticipatorySpaceTypeNotEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_not_eq]"] =
          filterParticipatorySpaceTypeNotEq;
      }

      if (filterParticipatorySpaceTypeMatches !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_matches]"] =
          filterParticipatorySpaceTypeMatches;
      }

      if (filterParticipatorySpaceTypeBlank !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_blank]"] =
          filterParticipatorySpaceTypeBlank;
      }

      if (filterNameNotIn) {
        localVarQueryParameter["filter[name_not_in][]"] = filterNameNotIn;
      }

      if (filterNameIn) {
        localVarQueryParameter["filter[name_in][]"] = filterNameIn;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      if (filterNameBlank !== undefined) {
        localVarQueryParameter["filter[name_blank]"] = filterNameBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find on proposal
     * @summary Proposal Component Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponent: async (
      id: number,
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("proposalComponent", "id", id);
      const localVarPath = `/components/proposal_components/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      if (filterIdLt !== undefined) {
        localVarQueryParameter["filter[id_lt]"] = filterIdLt;
      }

      if (filterIdGt !== undefined) {
        localVarQueryParameter["filter[id_gt]"] = filterIdGt;
      }

      if (filterIdPresent !== undefined) {
        localVarQueryParameter["filter[id_present]"] = filterIdPresent;
      }

      if (filterIdBlank !== undefined) {
        localVarQueryParameter["filter[id_blank]"] = filterIdBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search proposal components of the organization
     * @summary Proposal Components
     * @param {Array<string>} [filterNameNotIn]
     * @param {Array<string>} [filterNameIn]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {boolean} [filterNameBlank]
     * @param {Array<string>} [filterParticipatorySpaceTypeNotIn]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeStart]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterParticipatorySpaceTypeNotEq]
     * @param {string} [filterParticipatorySpaceTypeMatches]
     * @param {boolean} [filterParticipatorySpaceTypeBlank]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {string} [filterParticipatorySpaceIdLt]
     * @param {string} [filterParticipatorySpaceIdGt]
     * @param {boolean} [filterParticipatorySpaceIdPresent]
     * @param {boolean} [filterParticipatorySpaceIdBlank]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponents: async (
      filterNameNotIn?: Array<string>,
      filterNameIn?: Array<string>,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterNameBlank?: boolean,
      filterParticipatorySpaceTypeNotIn?: Array<string>,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeStart?: string,
      filterParticipatorySpaceTypeEq?: string,
      filterParticipatorySpaceTypeNotEq?: string,
      filterParticipatorySpaceTypeMatches?: string,
      filterParticipatorySpaceTypeBlank?: boolean,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceIdLt?: string,
      filterParticipatorySpaceIdGt?: string,
      filterParticipatorySpaceIdPresent?: boolean,
      filterParticipatorySpaceIdBlank?: boolean,
      page?: number,
      perPage?: number,
      locales?: Array<Locale>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/components/proposal_components`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (filterNameNotIn) {
        localVarQueryParameter["filter[name_not_in][]"] = filterNameNotIn;
      }

      if (filterNameIn) {
        localVarQueryParameter["filter[name_in][]"] = filterNameIn;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      if (filterNameBlank !== undefined) {
        localVarQueryParameter["filter[name_blank]"] = filterNameBlank;
      }

      if (filterParticipatorySpaceTypeNotIn) {
        localVarQueryParameter["filter[participatory_space_type_not_in][]"] =
          filterParticipatorySpaceTypeNotIn;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeStart !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_start]"] =
          filterParticipatorySpaceTypeStart;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterParticipatorySpaceTypeNotEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_not_eq]"] =
          filterParticipatorySpaceTypeNotEq;
      }

      if (filterParticipatorySpaceTypeMatches !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_matches]"] =
          filterParticipatorySpaceTypeMatches;
      }

      if (filterParticipatorySpaceTypeBlank !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_blank]"] =
          filterParticipatorySpaceTypeBlank;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceIdLt !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_lt]"] =
          filterParticipatorySpaceIdLt;
      }

      if (filterParticipatorySpaceIdGt !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_gt]"] =
          filterParticipatorySpaceIdGt;
      }

      if (filterParticipatorySpaceIdPresent !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_present]"] =
          filterParticipatorySpaceIdPresent;
      }

      if (filterParticipatorySpaceIdBlank !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_blank]"] =
          filterParticipatorySpaceIdBlank;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search components of the organization
     * @summary Search components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<Locale>} [locales]
     * @param {Array<ComponentManifest>} [filterManifestNameNotIn]
     * @param {Array<ComponentManifest>} [filterManifestNameIn]
     * @param {string} [filterManifestNameStart]
     * @param {ComponentManifest} [filterManifestNameEq]
     * @param {ComponentManifest} [filterManifestNameNotEq]
     * @param {string} [filterManifestNameMatches]
     * @param {boolean} [filterManifestNameBlank]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {string} [filterParticipatorySpaceIdLt]
     * @param {string} [filterParticipatorySpaceIdGt]
     * @param {boolean} [filterParticipatorySpaceIdPresent]
     * @param {boolean} [filterParticipatorySpaceIdBlank]
     * @param {Array<SpaceType>} [filterParticipatorySpaceTypeNotIn]
     * @param {Array<SpaceType>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeStart]
     * @param {SpaceType} [filterParticipatorySpaceTypeEq]
     * @param {SpaceType} [filterParticipatorySpaceTypeNotEq]
     * @param {string} [filterParticipatorySpaceTypeMatches]
     * @param {boolean} [filterParticipatorySpaceTypeBlank]
     * @param {Array<string>} [filterNameNotIn]
     * @param {Array<string>} [filterNameIn]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {boolean} [filterNameBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchComponents: async (
      page?: number,
      perPage?: number,
      locales?: Array<Locale>,
      filterManifestNameNotIn?: Array<ComponentManifest>,
      filterManifestNameIn?: Array<ComponentManifest>,
      filterManifestNameStart?: string,
      filterManifestNameEq?: ComponentManifest,
      filterManifestNameNotEq?: ComponentManifest,
      filterManifestNameMatches?: string,
      filterManifestNameBlank?: boolean,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceIdLt?: string,
      filterParticipatorySpaceIdGt?: string,
      filterParticipatorySpaceIdPresent?: boolean,
      filterParticipatorySpaceIdBlank?: boolean,
      filterParticipatorySpaceTypeNotIn?: Array<SpaceType>,
      filterParticipatorySpaceTypeIn?: Array<SpaceType>,
      filterParticipatorySpaceTypeStart?: string,
      filterParticipatorySpaceTypeEq?: SpaceType,
      filterParticipatorySpaceTypeNotEq?: SpaceType,
      filterParticipatorySpaceTypeMatches?: string,
      filterParticipatorySpaceTypeBlank?: boolean,
      filterNameNotIn?: Array<string>,
      filterNameIn?: Array<string>,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterNameBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/components/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameStart !== undefined) {
        localVarQueryParameter["filter[manifest_name_start]"] =
          filterManifestNameStart;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterManifestNameMatches !== undefined) {
        localVarQueryParameter["filter[manifest_name_matches]"] =
          filterManifestNameMatches;
      }

      if (filterManifestNameBlank !== undefined) {
        localVarQueryParameter["filter[manifest_name_blank]"] =
          filterManifestNameBlank;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      if (filterIdLt !== undefined) {
        localVarQueryParameter["filter[id_lt]"] = filterIdLt;
      }

      if (filterIdGt !== undefined) {
        localVarQueryParameter["filter[id_gt]"] = filterIdGt;
      }

      if (filterIdPresent !== undefined) {
        localVarQueryParameter["filter[id_present]"] = filterIdPresent;
      }

      if (filterIdBlank !== undefined) {
        localVarQueryParameter["filter[id_blank]"] = filterIdBlank;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceIdLt !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_lt]"] =
          filterParticipatorySpaceIdLt;
      }

      if (filterParticipatorySpaceIdGt !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_gt]"] =
          filterParticipatorySpaceIdGt;
      }

      if (filterParticipatorySpaceIdPresent !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_present]"] =
          filterParticipatorySpaceIdPresent;
      }

      if (filterParticipatorySpaceIdBlank !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_blank]"] =
          filterParticipatorySpaceIdBlank;
      }

      if (filterParticipatorySpaceTypeNotIn) {
        localVarQueryParameter["filter[participatory_space_type_not_in][]"] =
          filterParticipatorySpaceTypeNotIn;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeStart !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_start]"] =
          filterParticipatorySpaceTypeStart;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterParticipatorySpaceTypeNotEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_not_eq]"] =
          filterParticipatorySpaceTypeNotEq;
      }

      if (filterParticipatorySpaceTypeMatches !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_matches]"] =
          filterParticipatorySpaceTypeMatches;
      }

      if (filterParticipatorySpaceTypeBlank !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_blank]"] =
          filterParticipatorySpaceTypeBlank;
      }

      if (filterNameNotIn) {
        localVarQueryParameter["filter[name_not_in][]"] = filterNameNotIn;
      }

      if (filterNameIn) {
        localVarQueryParameter["filter[name_in][]"] = filterNameIn;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      if (filterNameBlank !== undefined) {
        localVarQueryParameter["filter[name_blank]"] = filterNameBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ComponentsApi - functional programming interface
 * @export
 */
export const ComponentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ComponentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Blog component details
     * @summary Blog Component Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {number} [componentId]
     * @param {BlogComponentSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogComponent(
      id: number,
      locales?: Array<Locale>,
      componentId?: number,
      spaceManifest?: BlogComponentSpaceManifestEnum,
      spaceId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogComponentItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogComponent(
        id,
        locales,
        componentId,
        spaceManifest,
        spaceId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.blogComponent"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search blog components of the organization
     * @summary Blog Components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<Locale>} [locales]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {string} [filterParticipatorySpaceIdLt]
     * @param {string} [filterParticipatorySpaceIdGt]
     * @param {boolean} [filterParticipatorySpaceIdPresent]
     * @param {boolean} [filterParticipatorySpaceIdBlank]
     * @param {Array<string>} [filterParticipatorySpaceTypeNotIn]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeStart]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterParticipatorySpaceTypeNotEq]
     * @param {string} [filterParticipatorySpaceTypeMatches]
     * @param {boolean} [filterParticipatorySpaceTypeBlank]
     * @param {Array<string>} [filterNameNotIn]
     * @param {Array<string>} [filterNameIn]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {boolean} [filterNameBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogComponents(
      page?: number,
      perPage?: number,
      locales?: Array<Locale>,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceIdLt?: string,
      filterParticipatorySpaceIdGt?: string,
      filterParticipatorySpaceIdPresent?: boolean,
      filterParticipatorySpaceIdBlank?: boolean,
      filterParticipatorySpaceTypeNotIn?: Array<string>,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeStart?: string,
      filterParticipatorySpaceTypeEq?: string,
      filterParticipatorySpaceTypeNotEq?: string,
      filterParticipatorySpaceTypeMatches?: string,
      filterParticipatorySpaceTypeBlank?: boolean,
      filterNameNotIn?: Array<string>,
      filterNameIn?: Array<string>,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterNameBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogComponentIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogComponents(
        page,
        perPage,
        locales,
        filterParticipatorySpaceIdIn,
        filterParticipatorySpaceIdEq,
        filterParticipatorySpaceIdLt,
        filterParticipatorySpaceIdGt,
        filterParticipatorySpaceIdPresent,
        filterParticipatorySpaceIdBlank,
        filterParticipatorySpaceTypeNotIn,
        filterParticipatorySpaceTypeIn,
        filterParticipatorySpaceTypeStart,
        filterParticipatorySpaceTypeEq,
        filterParticipatorySpaceTypeNotEq,
        filterParticipatorySpaceTypeMatches,
        filterParticipatorySpaceTypeBlank,
        filterNameNotIn,
        filterNameIn,
        filterNameStart,
        filterNameEq,
        filterNameNotEq,
        filterNameMatches,
        filterNameBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.blogComponents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find on proposal
     * @summary Proposal Component Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposalComponent(
      id: number,
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalComponentItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.proposalComponent(
          id,
          locales,
          page,
          perPage,
          filterIdIn,
          filterIdEq,
          filterIdLt,
          filterIdGt,
          filterIdPresent,
          filterIdBlank,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.proposalComponent"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search proposal components of the organization
     * @summary Proposal Components
     * @param {Array<string>} [filterNameNotIn]
     * @param {Array<string>} [filterNameIn]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {boolean} [filterNameBlank]
     * @param {Array<string>} [filterParticipatorySpaceTypeNotIn]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeStart]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterParticipatorySpaceTypeNotEq]
     * @param {string} [filterParticipatorySpaceTypeMatches]
     * @param {boolean} [filterParticipatorySpaceTypeBlank]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {string} [filterParticipatorySpaceIdLt]
     * @param {string} [filterParticipatorySpaceIdGt]
     * @param {boolean} [filterParticipatorySpaceIdPresent]
     * @param {boolean} [filterParticipatorySpaceIdBlank]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposalComponents(
      filterNameNotIn?: Array<string>,
      filterNameIn?: Array<string>,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterNameBlank?: boolean,
      filterParticipatorySpaceTypeNotIn?: Array<string>,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeStart?: string,
      filterParticipatorySpaceTypeEq?: string,
      filterParticipatorySpaceTypeNotEq?: string,
      filterParticipatorySpaceTypeMatches?: string,
      filterParticipatorySpaceTypeBlank?: boolean,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceIdLt?: string,
      filterParticipatorySpaceIdGt?: string,
      filterParticipatorySpaceIdPresent?: boolean,
      filterParticipatorySpaceIdBlank?: boolean,
      page?: number,
      perPage?: number,
      locales?: Array<Locale>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalComponentIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.proposalComponents(
          filterNameNotIn,
          filterNameIn,
          filterNameStart,
          filterNameEq,
          filterNameNotEq,
          filterNameMatches,
          filterNameBlank,
          filterParticipatorySpaceTypeNotIn,
          filterParticipatorySpaceTypeIn,
          filterParticipatorySpaceTypeStart,
          filterParticipatorySpaceTypeEq,
          filterParticipatorySpaceTypeNotEq,
          filterParticipatorySpaceTypeMatches,
          filterParticipatorySpaceTypeBlank,
          filterParticipatorySpaceIdIn,
          filterParticipatorySpaceIdEq,
          filterParticipatorySpaceIdLt,
          filterParticipatorySpaceIdGt,
          filterParticipatorySpaceIdPresent,
          filterParticipatorySpaceIdBlank,
          page,
          perPage,
          locales,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.proposalComponents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search components of the organization
     * @summary Search components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<Locale>} [locales]
     * @param {Array<ComponentManifest>} [filterManifestNameNotIn]
     * @param {Array<ComponentManifest>} [filterManifestNameIn]
     * @param {string} [filterManifestNameStart]
     * @param {ComponentManifest} [filterManifestNameEq]
     * @param {ComponentManifest} [filterManifestNameNotEq]
     * @param {string} [filterManifestNameMatches]
     * @param {boolean} [filterManifestNameBlank]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {string} [filterParticipatorySpaceIdLt]
     * @param {string} [filterParticipatorySpaceIdGt]
     * @param {boolean} [filterParticipatorySpaceIdPresent]
     * @param {boolean} [filterParticipatorySpaceIdBlank]
     * @param {Array<SpaceType>} [filterParticipatorySpaceTypeNotIn]
     * @param {Array<SpaceType>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeStart]
     * @param {SpaceType} [filterParticipatorySpaceTypeEq]
     * @param {SpaceType} [filterParticipatorySpaceTypeNotEq]
     * @param {string} [filterParticipatorySpaceTypeMatches]
     * @param {boolean} [filterParticipatorySpaceTypeBlank]
     * @param {Array<string>} [filterNameNotIn]
     * @param {Array<string>} [filterNameIn]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {boolean} [filterNameBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchComponents(
      page?: number,
      perPage?: number,
      locales?: Array<Locale>,
      filterManifestNameNotIn?: Array<ComponentManifest>,
      filterManifestNameIn?: Array<ComponentManifest>,
      filterManifestNameStart?: string,
      filterManifestNameEq?: ComponentManifest,
      filterManifestNameNotEq?: ComponentManifest,
      filterManifestNameMatches?: string,
      filterManifestNameBlank?: boolean,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceIdLt?: string,
      filterParticipatorySpaceIdGt?: string,
      filterParticipatorySpaceIdPresent?: boolean,
      filterParticipatorySpaceIdBlank?: boolean,
      filterParticipatorySpaceTypeNotIn?: Array<SpaceType>,
      filterParticipatorySpaceTypeIn?: Array<SpaceType>,
      filterParticipatorySpaceTypeStart?: string,
      filterParticipatorySpaceTypeEq?: SpaceType,
      filterParticipatorySpaceTypeNotEq?: SpaceType,
      filterParticipatorySpaceTypeMatches?: string,
      filterParticipatorySpaceTypeBlank?: boolean,
      filterNameNotIn?: Array<string>,
      filterNameIn?: Array<string>,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterNameBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ComponentIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchComponents(
          page,
          perPage,
          locales,
          filterManifestNameNotIn,
          filterManifestNameIn,
          filterManifestNameStart,
          filterManifestNameEq,
          filterManifestNameNotEq,
          filterManifestNameMatches,
          filterManifestNameBlank,
          filterIdIn,
          filterIdEq,
          filterIdLt,
          filterIdGt,
          filterIdPresent,
          filterIdBlank,
          filterParticipatorySpaceIdIn,
          filterParticipatorySpaceIdEq,
          filterParticipatorySpaceIdLt,
          filterParticipatorySpaceIdGt,
          filterParticipatorySpaceIdPresent,
          filterParticipatorySpaceIdBlank,
          filterParticipatorySpaceTypeNotIn,
          filterParticipatorySpaceTypeIn,
          filterParticipatorySpaceTypeStart,
          filterParticipatorySpaceTypeEq,
          filterParticipatorySpaceTypeNotEq,
          filterParticipatorySpaceTypeMatches,
          filterParticipatorySpaceTypeBlank,
          filterNameNotIn,
          filterNameIn,
          filterNameStart,
          filterNameEq,
          filterNameNotEq,
          filterNameMatches,
          filterNameBlank,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.searchComponents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ComponentsApi - factory interface
 * @export
 */
export const ComponentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ComponentsApiFp(configuration);
  return {
    /**
     * Blog component details
     * @summary Blog Component Details
     * @param {ComponentsApiBlogComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponent(
      requestParameters: ComponentsApiBlogComponentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogComponentItemResponse> {
      return localVarFp
        .blogComponent(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.componentId,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search blog components of the organization
     * @summary Blog Components
     * @param {ComponentsApiBlogComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponents(
      requestParameters: ComponentsApiBlogComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogComponentIndexResponse> {
      return localVarFp
        .blogComponents(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.locales,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceIdLt,
          requestParameters.filterParticipatorySpaceIdGt,
          requestParameters.filterParticipatorySpaceIdPresent,
          requestParameters.filterParticipatorySpaceIdBlank,
          requestParameters.filterParticipatorySpaceTypeNotIn,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeStart,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterParticipatorySpaceTypeNotEq,
          requestParameters.filterParticipatorySpaceTypeMatches,
          requestParameters.filterParticipatorySpaceTypeBlank,
          requestParameters.filterNameNotIn,
          requestParameters.filterNameIn,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          requestParameters.filterNameBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Find on proposal
     * @summary Proposal Component Details
     * @param {ComponentsApiProposalComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponent(
      requestParameters: ComponentsApiProposalComponentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalComponentItemResponse> {
      return localVarFp
        .proposalComponent(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          requestParameters.filterIdLt,
          requestParameters.filterIdGt,
          requestParameters.filterIdPresent,
          requestParameters.filterIdBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search proposal components of the organization
     * @summary Proposal Components
     * @param {ComponentsApiProposalComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponents(
      requestParameters: ComponentsApiProposalComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalComponentIndexResponse> {
      return localVarFp
        .proposalComponents(
          requestParameters.filterNameNotIn,
          requestParameters.filterNameIn,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          requestParameters.filterNameBlank,
          requestParameters.filterParticipatorySpaceTypeNotIn,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeStart,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterParticipatorySpaceTypeNotEq,
          requestParameters.filterParticipatorySpaceTypeMatches,
          requestParameters.filterParticipatorySpaceTypeBlank,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceIdLt,
          requestParameters.filterParticipatorySpaceIdGt,
          requestParameters.filterParticipatorySpaceIdPresent,
          requestParameters.filterParticipatorySpaceIdBlank,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search components of the organization
     * @summary Search components
     * @param {ComponentsApiSearchComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchComponents(
      requestParameters: ComponentsApiSearchComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComponentIndexResponse> {
      return localVarFp
        .searchComponents(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.locales,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameStart,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterManifestNameMatches,
          requestParameters.filterManifestNameBlank,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          requestParameters.filterIdLt,
          requestParameters.filterIdGt,
          requestParameters.filterIdPresent,
          requestParameters.filterIdBlank,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceIdLt,
          requestParameters.filterParticipatorySpaceIdGt,
          requestParameters.filterParticipatorySpaceIdPresent,
          requestParameters.filterParticipatorySpaceIdBlank,
          requestParameters.filterParticipatorySpaceTypeNotIn,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeStart,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterParticipatorySpaceTypeNotEq,
          requestParameters.filterParticipatorySpaceTypeMatches,
          requestParameters.filterParticipatorySpaceTypeBlank,
          requestParameters.filterNameNotIn,
          requestParameters.filterNameIn,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          requestParameters.filterNameBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for blogComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiBlogComponentRequest
 */
export interface ComponentsApiBlogComponentRequest {
  /**
   *
   * @type {number}
   * @memberof ComponentsApiBlogComponent
   */
  readonly id: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof ComponentsApiBlogComponent
   */
  readonly locales?: Array<Locale>;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiBlogComponent
   */
  readonly componentId?: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ComponentsApiBlogComponent
   */
  readonly spaceManifest?: BlogComponentSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiBlogComponent
   */
  readonly spaceId?: number;
}

/**
 * Request parameters for blogComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiBlogComponentsRequest
 */
export interface ComponentsApiBlogComponentsRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiBlogComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiBlogComponents
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly locales?: Array<Locale>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdLt?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdGt?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameBlank?: boolean;
}

/**
 * Request parameters for proposalComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiProposalComponentRequest
 */
export interface ComponentsApiProposalComponentRequest {
  /**
   *
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly id: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof ComponentsApiProposalComponent
   */
  readonly locales?: Array<Locale>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<number>}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdEq?: number;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdLt?: number;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdGt?: number;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdBlank?: boolean;
}

/**
 * Request parameters for proposalComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiProposalComponentsRequest
 */
export interface ComponentsApiProposalComponentsRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdLt?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdGt?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdBlank?: boolean;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiProposalComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiProposalComponents
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for searchComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiSearchComponentsRequest
 */
export interface ComponentsApiSearchComponentsRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly locales?: Array<Locale>;

  /**
   *
   * @type {Array<ComponentManifest>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameNotIn?: Array<ComponentManifest>;

  /**
   *
   * @type {Array<ComponentManifest>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameIn?: Array<ComponentManifest>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameStart?: string;

  /**
   *
   * @type {ComponentManifest}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameEq?: ComponentManifest;

  /**
   *
   * @type {ComponentManifest}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameNotEq?: ComponentManifest;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameBlank?: boolean;

  /**
   *
   * @type {Array<number>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdEq?: number;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdLt?: number;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdGt?: number;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdLt?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdGt?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdBlank?: boolean;

  /**
   *
   * @type {Array<SpaceType>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeNotIn?: Array<SpaceType>;

  /**
   *
   * @type {Array<SpaceType>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<SpaceType>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeStart?: string;

  /**
   *
   * @type {SpaceType}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeEq?: SpaceType;

  /**
   *
   * @type {SpaceType}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeNotEq?: SpaceType;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameBlank?: boolean;
}

/**
 * ComponentsApi - object-oriented interface
 * @export
 * @class ComponentsApi
 * @extends {BaseAPI}
 */
export class ComponentsApi extends BaseAPI {
  /**
   * Blog component details
   * @summary Blog Component Details
   * @param {ComponentsApiBlogComponentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public blogComponent(
    requestParameters: ComponentsApiBlogComponentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .blogComponent(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.componentId,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search blog components of the organization
   * @summary Blog Components
   * @param {ComponentsApiBlogComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public blogComponents(
    requestParameters: ComponentsApiBlogComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .blogComponents(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.locales,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceIdLt,
        requestParameters.filterParticipatorySpaceIdGt,
        requestParameters.filterParticipatorySpaceIdPresent,
        requestParameters.filterParticipatorySpaceIdBlank,
        requestParameters.filterParticipatorySpaceTypeNotIn,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeStart,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterParticipatorySpaceTypeNotEq,
        requestParameters.filterParticipatorySpaceTypeMatches,
        requestParameters.filterParticipatorySpaceTypeBlank,
        requestParameters.filterNameNotIn,
        requestParameters.filterNameIn,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        requestParameters.filterNameBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find on proposal
   * @summary Proposal Component Details
   * @param {ComponentsApiProposalComponentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public proposalComponent(
    requestParameters: ComponentsApiProposalComponentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .proposalComponent(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        requestParameters.filterIdLt,
        requestParameters.filterIdGt,
        requestParameters.filterIdPresent,
        requestParameters.filterIdBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search proposal components of the organization
   * @summary Proposal Components
   * @param {ComponentsApiProposalComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public proposalComponents(
    requestParameters: ComponentsApiProposalComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .proposalComponents(
        requestParameters.filterNameNotIn,
        requestParameters.filterNameIn,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        requestParameters.filterNameBlank,
        requestParameters.filterParticipatorySpaceTypeNotIn,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeStart,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterParticipatorySpaceTypeNotEq,
        requestParameters.filterParticipatorySpaceTypeMatches,
        requestParameters.filterParticipatorySpaceTypeBlank,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceIdLt,
        requestParameters.filterParticipatorySpaceIdGt,
        requestParameters.filterParticipatorySpaceIdPresent,
        requestParameters.filterParticipatorySpaceIdBlank,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search components of the organization
   * @summary Search components
   * @param {ComponentsApiSearchComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public searchComponents(
    requestParameters: ComponentsApiSearchComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .searchComponents(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.locales,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameStart,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterManifestNameMatches,
        requestParameters.filterManifestNameBlank,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        requestParameters.filterIdLt,
        requestParameters.filterIdGt,
        requestParameters.filterIdPresent,
        requestParameters.filterIdBlank,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceIdLt,
        requestParameters.filterParticipatorySpaceIdGt,
        requestParameters.filterParticipatorySpaceIdPresent,
        requestParameters.filterParticipatorySpaceIdBlank,
        requestParameters.filterParticipatorySpaceTypeNotIn,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeStart,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterParticipatorySpaceTypeNotEq,
        requestParameters.filterParticipatorySpaceTypeMatches,
        requestParameters.filterParticipatorySpaceTypeBlank,
        requestParameters.filterNameNotIn,
        requestParameters.filterNameIn,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        requestParameters.filterNameBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const BlogComponentSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogComponentSpaceManifestEnum =
  (typeof BlogComponentSpaceManifestEnum)[keyof typeof BlogComponentSpaceManifestEnum];

/**
 * DraftProposalsApi - axios parameter creator
 * @export
 */
export const DraftProposalsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a draft
     * @summary Create draft proposal
     * @param {CreateDraftProposalPayload} createDraftProposalPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDraftProposal: async (
      createDraftProposalPayload: CreateDraftProposalPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDraftProposalPayload' is not null or undefined
      assertParamExists(
        "createDraftProposal",
        "createDraftProposalPayload",
        createDraftProposalPayload,
      );
      const localVarPath = `/draft_proposals`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDraftProposalPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("draftProposal", "id", id);
      const localVarPath = `/draft_proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishDraftProposal: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("publishDraftProposal", "id", id);
      const localVarPath = `/draft_proposals/{id}/publish`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Update draft proposal
     * @param {number} id
     * @param {UpdateDraftProposalPayload} updateDraftProposalPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftProposal: async (
      id: number,
      updateDraftProposalPayload: UpdateDraftProposalPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateDraftProposal", "id", id);
      // verify required parameter 'updateDraftProposalPayload' is not null or undefined
      assertParamExists(
        "updateDraftProposal",
        "updateDraftProposalPayload",
        updateDraftProposalPayload,
      );
      const localVarPath = `/draft_proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDraftProposalPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnDraftProposal: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("withdrawnDraftProposal", "id", id);
      const localVarPath = `/draft_proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DraftProposalsApi - functional programming interface
 * @export
 */
export const DraftProposalsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DraftProposalsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a draft
     * @summary Create draft proposal
     * @param {CreateDraftProposalPayload} createDraftProposalPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDraftProposal(
      createDraftProposalPayload: CreateDraftProposalPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createDraftProposal(
          createDraftProposalPayload,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.createDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async draftProposal(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.draftProposal(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.draftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishDraftProposal(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.publishDraftProposal(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.publishDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Update draft proposal
     * @param {number} id
     * @param {UpdateDraftProposalPayload} updateDraftProposalPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDraftProposal(
      id: number,
      updateDraftProposalPayload: UpdateDraftProposalPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateDraftProposal(
          id,
          updateDraftProposalPayload,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.updateDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async withdrawnDraftProposal(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.withdrawnDraftProposal(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.withdrawnDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DraftProposalsApi - factory interface
 * @export
 */
export const DraftProposalsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DraftProposalsApiFp(configuration);
  return {
    /**
     * Create a draft
     * @summary Create draft proposal
     * @param {DraftProposalsApiCreateDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDraftProposal(
      requestParameters: DraftProposalsApiCreateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .createDraftProposal(
          requestParameters.createDraftProposalPayload,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {DraftProposalsApiDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal(
      requestParameters: DraftProposalsApiDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .draftProposal(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {DraftProposalsApiPublishDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishDraftProposal(
      requestParameters: DraftProposalsApiPublishDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalItemResponse> {
      return localVarFp
        .publishDraftProposal(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Update draft proposal
     * @param {DraftProposalsApiUpdateDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftProposal(
      requestParameters: DraftProposalsApiUpdateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .updateDraftProposal(
          requestParameters.id,
          requestParameters.updateDraftProposalPayload,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {DraftProposalsApiWithdrawnDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnDraftProposal(
      requestParameters: DraftProposalsApiWithdrawnDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .withdrawnDraftProposal(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiCreateDraftProposalRequest
 */
export interface DraftProposalsApiCreateDraftProposalRequest {
  /**
   *
   * @type {CreateDraftProposalPayload}
   * @memberof DraftProposalsApiCreateDraftProposal
   */
  readonly createDraftProposalPayload: CreateDraftProposalPayload;
}

/**
 * Request parameters for draftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiDraftProposalRequest
 */
export interface DraftProposalsApiDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiDraftProposal
   */
  readonly id: number;
}

/**
 * Request parameters for publishDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiPublishDraftProposalRequest
 */
export interface DraftProposalsApiPublishDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiPublishDraftProposal
   */
  readonly id: number;
}

/**
 * Request parameters for updateDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiUpdateDraftProposalRequest
 */
export interface DraftProposalsApiUpdateDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiUpdateDraftProposal
   */
  readonly id: number;

  /**
   *
   * @type {UpdateDraftProposalPayload}
   * @memberof DraftProposalsApiUpdateDraftProposal
   */
  readonly updateDraftProposalPayload: UpdateDraftProposalPayload;
}

/**
 * Request parameters for withdrawnDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiWithdrawnDraftProposalRequest
 */
export interface DraftProposalsApiWithdrawnDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiWithdrawnDraftProposal
   */
  readonly id: number;
}

/**
 * DraftProposalsApi - object-oriented interface
 * @export
 * @class DraftProposalsApi
 * @extends {BaseAPI}
 */
export class DraftProposalsApi extends BaseAPI {
  /**
   * Create a draft
   * @summary Create draft proposal
   * @param {DraftProposalsApiCreateDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public createDraftProposal(
    requestParameters: DraftProposalsApiCreateDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .createDraftProposal(
        requestParameters.createDraftProposalPayload,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
   * @summary Display a draft proposal
   * @param {DraftProposalsApiDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public draftProposal(
    requestParameters: DraftProposalsApiDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .draftProposal(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publish a draft proposal
   * @summary Publish a draft proposal
   * @param {DraftProposalsApiPublishDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public publishDraftProposal(
    requestParameters: DraftProposalsApiPublishDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .publishDraftProposal(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
   * @summary Update draft proposal
   * @param {DraftProposalsApiUpdateDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public updateDraftProposal(
    requestParameters: DraftProposalsApiUpdateDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .updateDraftProposal(
        requestParameters.id,
        requestParameters.updateDraftProposalPayload,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Withdrawn a draft proposal. This action cannot be undone.
   * @summary Withdrawn a draft proposal
   * @param {DraftProposalsApiWithdrawnDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public withdrawnDraftProposal(
    requestParameters: DraftProposalsApiWithdrawnDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .withdrawnDraftProposal(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Health metrics
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthMetrics: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/metrics/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration);
  return {
    /**
     * Health metrics
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthMetrics(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.healthMetrics(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MetricsApi.healthMetrics"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MetricsApiFp(configuration);
  return {
    /**
     * Health metrics
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthMetrics(options?: RawAxiosRequestConfig): AxiosPromise<Health> {
      return localVarFp
        .healthMetrics(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
  /**
   * Health metrics
   * @summary Health
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public healthMetrics(options?: RawAxiosRequestConfig) {
    return MetricsApiFp(this.configuration)
      .healthMetrics(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      oauthGrantParam: OauthGrantParam,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oauthGrantParam' is not null or undefined
      assertParamExists("createToken", "oauthGrantParam", oauthGrantParam);
      const localVarPath = `/oauth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        oauthGrantParam,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken: async (
      introspectTokenRequest: IntrospectTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'introspectTokenRequest' is not null or undefined
      assertParamExists(
        "introspectToken",
        "introspectTokenRequest",
        introspectTokenRequest,
      );
      const localVarPath = `/oauth/introspect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        introspectTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      oauthGrantParam: OauthGrantParam,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(
        oauthGrantParam,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.createToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async introspectToken(
      introspectTokenRequest: IntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntrospectData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.introspectToken(
        introspectTokenRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.introspectToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OAuthApiFp(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      requestParameters: OAuthApiCreateTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createToken(requestParameters.oauthGrantParam, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken(
      requestParameters: OAuthApiIntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntrospectData> {
      return localVarFp
        .introspectToken(requestParameters.introspectTokenRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createToken operation in OAuthApi.
 * @export
 * @interface OAuthApiCreateTokenRequest
 */
export interface OAuthApiCreateTokenRequest {
  /**
   *
   * @type {OauthGrantParam}
   * @memberof OAuthApiCreateToken
   */
  readonly oauthGrantParam: OauthGrantParam;
}

/**
 * Request parameters for introspectToken operation in OAuthApi.
 * @export
 * @interface OAuthApiIntrospectTokenRequest
 */
export interface OAuthApiIntrospectTokenRequest {
  /**
   *
   * @type {IntrospectTokenRequest}
   * @memberof OAuthApiIntrospectToken
   */
  readonly introspectTokenRequest: IntrospectTokenRequest;
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
  /**
   * Create a oauth token for the given scopes
   * @summary Request a OAuth token through Client Credentials
   * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public createToken(
    requestParameters: OAuthApiCreateTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .createToken(requestParameters.oauthGrantParam, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get given oauth token details
   * @summary Introspect a OAuth token
   * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public introspectToken(
    requestParameters: OAuthApiIntrospectTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .introspectToken(requestParameters.introspectTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Show organization
     * @summary Organization
     * @param {string} id The ID of the organization
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organization: async (
      id: string,
      locales?: Array<Locale>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("organization", "id", id);
      const localVarPath = `/organizations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List available organizations
     * @summary Organizations
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations: async (
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/organizations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to update an organization.  ### Update host To update the host, send in your payload the `host` attribute. It will be saved as an `unconfirmed_host` extended data attribute.  Once saved, a job will be enqueued to reverse DNS the unconfirmed host before actually updating the host. The `host` attribute must be unique across all organizations. More information on this update process is documented in the [Safe host update](https://octree-gva.github.io/decidim-rest-full/dev/update-hosts) page.  ### Update name To update the name, send in your payload the `name` attribute. The `name` attribute must be unique across all organizations.
     * @summary Update organization
     * @param {string} id The ID of the organization
     * @param {UpdateOrganizationPayload} updateOrganizationPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization: async (
      id: string,
      updateOrganizationPayload: UpdateOrganizationPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateOrganization", "id", id);
      // verify required parameter 'updateOrganizationPayload' is not null or undefined
      assertParamExists(
        "updateOrganization",
        "updateOrganizationPayload",
        updateOrganizationPayload,
      );
      const localVarPath = `/organizations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateOrganizationPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OrganizationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Show organization
     * @summary Organization
     * @param {string} id The ID of the organization
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organization(
      id: string,
      locales?: Array<Locale>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrganizationItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.organization(
        id,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OrganizationsApi.organization"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List available organizations
     * @summary Organizations
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizations(
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrganizationIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.organizations(
        locales,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OrganizationsApi.organizations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint allows you to update an organization.  ### Update host To update the host, send in your payload the `host` attribute. It will be saved as an `unconfirmed_host` extended data attribute.  Once saved, a job will be enqueued to reverse DNS the unconfirmed host before actually updating the host. The `host` attribute must be unique across all organizations. More information on this update process is documented in the [Safe host update](https://octree-gva.github.io/decidim-rest-full/dev/update-hosts) page.  ### Update name To update the name, send in your payload the `name` attribute. The `name` attribute must be unique across all organizations.
     * @summary Update organization
     * @param {string} id The ID of the organization
     * @param {UpdateOrganizationPayload} updateOrganizationPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOrganization(
      id: string,
      updateOrganizationPayload: UpdateOrganizationPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrganizationItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateOrganization(
          id,
          updateOrganizationPayload,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OrganizationsApi.updateOrganization"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OrganizationsApiFp(configuration);
  return {
    /**
     * Show organization
     * @summary Organization
     * @param {OrganizationsApiOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organization(
      requestParameters: OrganizationsApiOrganizationRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OrganizationItemResponse> {
      return localVarFp
        .organization(requestParameters.id, requestParameters.locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List available organizations
     * @summary Organizations
     * @param {OrganizationsApiOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations(
      requestParameters: OrganizationsApiOrganizationsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OrganizationIndexResponse> {
      return localVarFp
        .organizations(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to update an organization.  ### Update host To update the host, send in your payload the `host` attribute. It will be saved as an `unconfirmed_host` extended data attribute.  Once saved, a job will be enqueued to reverse DNS the unconfirmed host before actually updating the host. The `host` attribute must be unique across all organizations. More information on this update process is documented in the [Safe host update](https://octree-gva.github.io/decidim-rest-full/dev/update-hosts) page.  ### Update name To update the name, send in your payload the `name` attribute. The `name` attribute must be unique across all organizations.
     * @summary Update organization
     * @param {OrganizationsApiUpdateOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization(
      requestParameters: OrganizationsApiUpdateOrganizationRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OrganizationItemResponse> {
      return localVarFp
        .updateOrganization(
          requestParameters.id,
          requestParameters.updateOrganizationPayload,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for organization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiOrganizationRequest
 */
export interface OrganizationsApiOrganizationRequest {
  /**
   * The ID of the organization
   * @type {string}
   * @memberof OrganizationsApiOrganization
   */
  readonly id: string;

  /**
   *
   * @type {Array<Locale>}
   * @memberof OrganizationsApiOrganization
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for organizations operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiOrganizationsRequest
 */
export interface OrganizationsApiOrganizationsRequest {
  /**
   *
   * @type {Array<Locale>}
   * @memberof OrganizationsApiOrganizations
   */
  readonly locales?: Array<Locale>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof OrganizationsApiOrganizations
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof OrganizationsApiOrganizations
   */
  readonly perPage?: number;
}

/**
 * Request parameters for updateOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiUpdateOrganizationRequest
 */
export interface OrganizationsApiUpdateOrganizationRequest {
  /**
   * The ID of the organization
   * @type {string}
   * @memberof OrganizationsApiUpdateOrganization
   */
  readonly id: string;

  /**
   *
   * @type {UpdateOrganizationPayload}
   * @memberof OrganizationsApiUpdateOrganization
   */
  readonly updateOrganizationPayload: UpdateOrganizationPayload;
}

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
  /**
   * Show organization
   * @summary Organization
   * @param {OrganizationsApiOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public organization(
    requestParameters: OrganizationsApiOrganizationRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OrganizationsApiFp(this.configuration)
      .organization(requestParameters.id, requestParameters.locales, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List available organizations
   * @summary Organizations
   * @param {OrganizationsApiOrganizationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public organizations(
    requestParameters: OrganizationsApiOrganizationsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return OrganizationsApiFp(this.configuration)
      .organizations(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to update an organization.  ### Update host To update the host, send in your payload the `host` attribute. It will be saved as an `unconfirmed_host` extended data attribute.  Once saved, a job will be enqueued to reverse DNS the unconfirmed host before actually updating the host. The `host` attribute must be unique across all organizations. More information on this update process is documented in the [Safe host update](https://octree-gva.github.io/decidim-rest-full/dev/update-hosts) page.  ### Update name To update the name, send in your payload the `name` attribute. The `name` attribute must be unique across all organizations.
   * @summary Update organization
   * @param {OrganizationsApiUpdateOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public updateOrganization(
    requestParameters: OrganizationsApiUpdateOrganizationRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OrganizationsApiFp(this.configuration)
      .updateOrganization(
        requestParameters.id,
        requestParameters.updateOrganizationPayload,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OrganizationsExtendedDataApi - axios parameter creator
 * @export
 */
export const OrganizationsExtendedDataApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Fetch organization extended data
     * @summary Organization extended data
     * @param {string} objectPath
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationData: async (
      objectPath: string,
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'objectPath' is not null or undefined
      assertParamExists("organizationData", "objectPath", objectPath);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("organizationData", "id", id);
      const localVarPath = `/organizations/{id}/extended_data`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (objectPath !== undefined) {
        localVarQueryParameter["object_path"] = objectPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update organization extended data
     * @param {number} id
     * @param {UserExtendedDataPayload} userExtendedDataPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setOrganizationExtendedData: async (
      id: number,
      userExtendedDataPayload: UserExtendedDataPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("setOrganizationExtendedData", "id", id);
      // verify required parameter 'userExtendedDataPayload' is not null or undefined
      assertParamExists(
        "setOrganizationExtendedData",
        "userExtendedDataPayload",
        userExtendedDataPayload,
      );
      const localVarPath = `/organizations/{id}/extended_data`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userExtendedDataPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OrganizationsExtendedDataApi - functional programming interface
 * @export
 */
export const OrganizationsExtendedDataApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    OrganizationsExtendedDataApiAxiosParamCreator(configuration);
  return {
    /**
     * Fetch organization extended data
     * @summary Organization extended data
     * @param {string} objectPath
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizationData(
      objectPath: string,
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.organizationData(
          objectPath,
          id,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OrganizationsExtendedDataApi.organizationData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update organization extended data
     * @param {number} id
     * @param {UserExtendedDataPayload} userExtendedDataPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setOrganizationExtendedData(
      id: number,
      userExtendedDataPayload: UserExtendedDataPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setOrganizationExtendedData(
          id,
          userExtendedDataPayload,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "OrganizationsExtendedDataApi.setOrganizationExtendedData"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OrganizationsExtendedDataApi - factory interface
 * @export
 */
export const OrganizationsExtendedDataApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OrganizationsExtendedDataApiFp(configuration);
  return {
    /**
     * Fetch organization extended data
     * @summary Organization extended data
     * @param {OrganizationsExtendedDataApiOrganizationDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizationData(
      requestParameters: OrganizationsExtendedDataApiOrganizationDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .organizationData(
          requestParameters.objectPath,
          requestParameters.id,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update organization extended data
     * @param {OrganizationsExtendedDataApiSetOrganizationExtendedDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setOrganizationExtendedData(
      requestParameters: OrganizationsExtendedDataApiSetOrganizationExtendedDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .setOrganizationExtendedData(
          requestParameters.id,
          requestParameters.userExtendedDataPayload,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for organizationData operation in OrganizationsExtendedDataApi.
 * @export
 * @interface OrganizationsExtendedDataApiOrganizationDataRequest
 */
export interface OrganizationsExtendedDataApiOrganizationDataRequest {
  /**
   *
   * @type {string}
   * @memberof OrganizationsExtendedDataApiOrganizationData
   */
  readonly objectPath: string;

  /**
   *
   * @type {number}
   * @memberof OrganizationsExtendedDataApiOrganizationData
   */
  readonly id: number;
}

/**
 * Request parameters for setOrganizationExtendedData operation in OrganizationsExtendedDataApi.
 * @export
 * @interface OrganizationsExtendedDataApiSetOrganizationExtendedDataRequest
 */
export interface OrganizationsExtendedDataApiSetOrganizationExtendedDataRequest {
  /**
   *
   * @type {number}
   * @memberof OrganizationsExtendedDataApiSetOrganizationExtendedData
   */
  readonly id: number;

  /**
   *
   * @type {UserExtendedDataPayload}
   * @memberof OrganizationsExtendedDataApiSetOrganizationExtendedData
   */
  readonly userExtendedDataPayload: UserExtendedDataPayload;
}

/**
 * OrganizationsExtendedDataApi - object-oriented interface
 * @export
 * @class OrganizationsExtendedDataApi
 * @extends {BaseAPI}
 */
export class OrganizationsExtendedDataApi extends BaseAPI {
  /**
   * Fetch organization extended data
   * @summary Organization extended data
   * @param {OrganizationsExtendedDataApiOrganizationDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsExtendedDataApi
   */
  public organizationData(
    requestParameters: OrganizationsExtendedDataApiOrganizationDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OrganizationsExtendedDataApiFp(this.configuration)
      .organizationData(
        requestParameters.objectPath,
        requestParameters.id,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
   * @summary Update organization extended data
   * @param {OrganizationsExtendedDataApiSetOrganizationExtendedDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsExtendedDataApi
   */
  public setOrganizationExtendedData(
    requestParameters: OrganizationsExtendedDataApiSetOrganizationExtendedDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OrganizationsExtendedDataApiFp(this.configuration)
      .setOrganizationExtendedData(
        requestParameters.id,
        requestParameters.userExtendedDataPayload,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProposalsApi - axios parameter creator
 * @export
 */
export const ProposalsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Proposal detail
     * @summary Proposal Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {ProposalSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {Array<string>} [filterVotedWeightNotIn]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightStart]
     * @param {string} [filterVotedWeightEq]
     * @param {string} [filterVotedWeightNotEq]
     * @param {string} [filterVotedWeightMatches]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateNotIn]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateStart]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {string} [filterStateMatches]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal: async (
      id: number,
      locales?: Array<Locale>,
      spaceManifest?: ProposalSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      filterVotedWeightNotIn?: Array<string>,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightStart?: string,
      filterVotedWeightEq?: string,
      filterVotedWeightNotEq?: string,
      filterVotedWeightMatches?: string,
      filterVotedWeightBlank?: boolean,
      filterStateNotIn?: Array<string>,
      filterStateIn?: Array<string>,
      filterStateStart?: string,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateMatches?: string,
      filterStateBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("proposal", "id", id);
      const localVarPath = `/proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      if (filterVotedWeightNotIn) {
        localVarQueryParameter["filter[voted_weight_not_in][]"] =
          filterVotedWeightNotIn;
      }

      if (filterVotedWeightIn) {
        localVarQueryParameter["filter[voted_weight_in][]"] =
          filterVotedWeightIn;
      }

      if (filterVotedWeightStart !== undefined) {
        localVarQueryParameter["filter[voted_weight_start]"] =
          filterVotedWeightStart;
      }

      if (filterVotedWeightEq !== undefined) {
        localVarQueryParameter["filter[voted_weight_eq]"] = filterVotedWeightEq;
      }

      if (filterVotedWeightNotEq !== undefined) {
        localVarQueryParameter["filter[voted_weight_not_eq]"] =
          filterVotedWeightNotEq;
      }

      if (filterVotedWeightMatches !== undefined) {
        localVarQueryParameter["filter[voted_weight_matches]"] =
          filterVotedWeightMatches;
      }

      if (filterVotedWeightBlank !== undefined) {
        localVarQueryParameter["filter[voted_weight_blank]"] =
          filterVotedWeightBlank;
      }

      if (filterStateNotIn) {
        localVarQueryParameter["filter[state_not_in][]"] = filterStateNotIn;
      }

      if (filterStateIn) {
        localVarQueryParameter["filter[state_in][]"] = filterStateIn;
      }

      if (filterStateStart !== undefined) {
        localVarQueryParameter["filter[state_start]"] = filterStateStart;
      }

      if (filterStateEq !== undefined) {
        localVarQueryParameter["filter[state_eq]"] = filterStateEq;
      }

      if (filterStateNotEq !== undefined) {
        localVarQueryParameter["filter[state_not_eq]"] = filterStateNotEq;
      }

      if (filterStateMatches !== undefined) {
        localVarQueryParameter["filter[state_matches]"] = filterStateMatches;
      }

      if (filterStateBlank !== undefined) {
        localVarQueryParameter["filter[state_blank]"] = filterStateBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search proposals
     * @summary Proposals
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {ProposalsOrderEnum} [order] Order by
     * @param {ProposalsOrderDirectionEnum} [orderDirection] Order direction
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {string} [filterVotedWeightLt]
     * @param {string} [filterVotedWeightGt]
     * @param {boolean} [filterVotedWeightPresent]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateNotIn]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateStart]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {string} [filterStateMatches]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals: async (
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      spaceManifest?: ProposalsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightLt?: string,
      filterVotedWeightGt?: string,
      filterVotedWeightPresent?: boolean,
      filterVotedWeightBlank?: boolean,
      filterStateNotIn?: Array<string>,
      filterStateIn?: Array<string>,
      filterStateStart?: string,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateMatches?: string,
      filterStateBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/proposals`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      if (order !== undefined) {
        localVarQueryParameter["order"] = order;
      }

      if (orderDirection !== undefined) {
        localVarQueryParameter["order_direction"] = orderDirection;
      }

      if (filterVotedWeightIn) {
        localVarQueryParameter["filter[voted_weight_in][]"] =
          filterVotedWeightIn;
      }

      if (filterVotedWeightEq !== undefined) {
        localVarQueryParameter["filter[voted_weight_eq]"] = filterVotedWeightEq;
      }

      if (filterVotedWeightLt !== undefined) {
        localVarQueryParameter["filter[voted_weight_lt]"] = filterVotedWeightLt;
      }

      if (filterVotedWeightGt !== undefined) {
        localVarQueryParameter["filter[voted_weight_gt]"] = filterVotedWeightGt;
      }

      if (filterVotedWeightPresent !== undefined) {
        localVarQueryParameter["filter[voted_weight_present]"] =
          filterVotedWeightPresent;
      }

      if (filterVotedWeightBlank !== undefined) {
        localVarQueryParameter["filter[voted_weight_blank]"] =
          filterVotedWeightBlank;
      }

      if (filterStateNotIn) {
        localVarQueryParameter["filter[state_not_in][]"] = filterStateNotIn;
      }

      if (filterStateIn) {
        localVarQueryParameter["filter[state_in][]"] = filterStateIn;
      }

      if (filterStateStart !== undefined) {
        localVarQueryParameter["filter[state_start]"] = filterStateStart;
      }

      if (filterStateEq !== undefined) {
        localVarQueryParameter["filter[state_eq]"] = filterStateEq;
      }

      if (filterStateNotEq !== undefined) {
        localVarQueryParameter["filter[state_not_eq]"] = filterStateNotEq;
      }

      if (filterStateMatches !== undefined) {
        localVarQueryParameter["filter[state_matches]"] = filterStateMatches;
      }

      if (filterStateBlank !== undefined) {
        localVarQueryParameter["filter[state_blank]"] = filterStateBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProposalsApi - functional programming interface
 * @export
 */
export const ProposalsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProposalsApiAxiosParamCreator(configuration);
  return {
    /**
     * Proposal detail
     * @summary Proposal Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {ProposalSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {Array<string>} [filterVotedWeightNotIn]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightStart]
     * @param {string} [filterVotedWeightEq]
     * @param {string} [filterVotedWeightNotEq]
     * @param {string} [filterVotedWeightMatches]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateNotIn]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateStart]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {string} [filterStateMatches]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposal(
      id: number,
      locales?: Array<Locale>,
      spaceManifest?: ProposalSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      filterVotedWeightNotIn?: Array<string>,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightStart?: string,
      filterVotedWeightEq?: string,
      filterVotedWeightNotEq?: string,
      filterVotedWeightMatches?: string,
      filterVotedWeightBlank?: boolean,
      filterStateNotIn?: Array<string>,
      filterStateIn?: Array<string>,
      filterStateStart?: string,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateMatches?: string,
      filterStateBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposal(
        id,
        locales,
        spaceManifest,
        spaceId,
        componentId,
        filterVotedWeightNotIn,
        filterVotedWeightIn,
        filterVotedWeightStart,
        filterVotedWeightEq,
        filterVotedWeightNotEq,
        filterVotedWeightMatches,
        filterVotedWeightBlank,
        filterStateNotIn,
        filterStateIn,
        filterStateStart,
        filterStateEq,
        filterStateNotEq,
        filterStateMatches,
        filterStateBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search proposals
     * @summary Proposals
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {ProposalsOrderEnum} [order] Order by
     * @param {ProposalsOrderDirectionEnum} [orderDirection] Order direction
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {string} [filterVotedWeightLt]
     * @param {string} [filterVotedWeightGt]
     * @param {boolean} [filterVotedWeightPresent]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateNotIn]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateStart]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {string} [filterStateMatches]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposals(
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      spaceManifest?: ProposalsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightLt?: string,
      filterVotedWeightGt?: string,
      filterVotedWeightPresent?: boolean,
      filterVotedWeightBlank?: boolean,
      filterStateNotIn?: Array<string>,
      filterStateIn?: Array<string>,
      filterStateStart?: string,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateMatches?: string,
      filterStateBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposals(
        locales,
        page,
        perPage,
        spaceManifest,
        spaceId,
        componentId,
        order,
        orderDirection,
        filterVotedWeightIn,
        filterVotedWeightEq,
        filterVotedWeightLt,
        filterVotedWeightGt,
        filterVotedWeightPresent,
        filterVotedWeightBlank,
        filterStateNotIn,
        filterStateIn,
        filterStateStart,
        filterStateEq,
        filterStateNotEq,
        filterStateMatches,
        filterStateBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposals"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProposalsApi - factory interface
 * @export
 */
export const ProposalsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProposalsApiFp(configuration);
  return {
    /**
     * Proposal detail
     * @summary Proposal Details
     * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal(
      requestParameters: ProposalsApiProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalItemResponse> {
      return localVarFp
        .proposal(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.filterVotedWeightNotIn,
          requestParameters.filterVotedWeightIn,
          requestParameters.filterVotedWeightStart,
          requestParameters.filterVotedWeightEq,
          requestParameters.filterVotedWeightNotEq,
          requestParameters.filterVotedWeightMatches,
          requestParameters.filterVotedWeightBlank,
          requestParameters.filterStateNotIn,
          requestParameters.filterStateIn,
          requestParameters.filterStateStart,
          requestParameters.filterStateEq,
          requestParameters.filterStateNotEq,
          requestParameters.filterStateMatches,
          requestParameters.filterStateBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Search proposals
     * @summary Proposals
     * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals(
      requestParameters: ProposalsApiProposalsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalIndexResponse> {
      return localVarFp
        .proposals(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.order,
          requestParameters.orderDirection,
          requestParameters.filterVotedWeightIn,
          requestParameters.filterVotedWeightEq,
          requestParameters.filterVotedWeightLt,
          requestParameters.filterVotedWeightGt,
          requestParameters.filterVotedWeightPresent,
          requestParameters.filterVotedWeightBlank,
          requestParameters.filterStateNotIn,
          requestParameters.filterStateIn,
          requestParameters.filterStateStart,
          requestParameters.filterStateEq,
          requestParameters.filterStateNotEq,
          requestParameters.filterStateMatches,
          requestParameters.filterStateBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for proposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalRequest
 */
export interface ProposalsApiProposalRequest {
  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly id: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof ProposalsApiProposal
   */
  readonly locales?: Array<Locale>;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposal
   */
  readonly spaceManifest?: ProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly spaceId?: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly componentId?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightStart?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateStart?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateBlank?: boolean;
}

/**
 * Request parameters for proposals operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalsRequest
 */
export interface ProposalsApiProposalsRequest {
  /**
   *
   * @type {Array<Locale>}
   * @memberof ProposalsApiProposals
   */
  readonly locales?: Array<Locale>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly perPage?: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposals
   */
  readonly spaceManifest?: ProposalsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly spaceId?: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly componentId?: number;

  /**
   * Order by
   * @type {'published_at' | 'rand'}
   * @memberof ProposalsApiProposals
   */
  readonly order?: ProposalsOrderEnum;

  /**
   * Order direction
   * @type {'asc' | 'desc'}
   * @memberof ProposalsApiProposals
   */
  readonly orderDirection?: ProposalsOrderDirectionEnum;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightLt?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightGt?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateStart?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateBlank?: boolean;
}

/**
 * ProposalsApi - object-oriented interface
 * @export
 * @class ProposalsApi
 * @extends {BaseAPI}
 */
export class ProposalsApi extends BaseAPI {
  /**
   * Proposal detail
   * @summary Proposal Details
   * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposal(
    requestParameters: ProposalsApiProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposal(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.filterVotedWeightNotIn,
        requestParameters.filterVotedWeightIn,
        requestParameters.filterVotedWeightStart,
        requestParameters.filterVotedWeightEq,
        requestParameters.filterVotedWeightNotEq,
        requestParameters.filterVotedWeightMatches,
        requestParameters.filterVotedWeightBlank,
        requestParameters.filterStateNotIn,
        requestParameters.filterStateIn,
        requestParameters.filterStateStart,
        requestParameters.filterStateEq,
        requestParameters.filterStateNotEq,
        requestParameters.filterStateMatches,
        requestParameters.filterStateBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search proposals
   * @summary Proposals
   * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposals(
    requestParameters: ProposalsApiProposalsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposals(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.order,
        requestParameters.orderDirection,
        requestParameters.filterVotedWeightIn,
        requestParameters.filterVotedWeightEq,
        requestParameters.filterVotedWeightLt,
        requestParameters.filterVotedWeightGt,
        requestParameters.filterVotedWeightPresent,
        requestParameters.filterVotedWeightBlank,
        requestParameters.filterStateNotIn,
        requestParameters.filterStateIn,
        requestParameters.filterStateStart,
        requestParameters.filterStateEq,
        requestParameters.filterStateNotEq,
        requestParameters.filterStateMatches,
        requestParameters.filterStateBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalSpaceManifestEnum =
  (typeof ProposalSpaceManifestEnum)[keyof typeof ProposalSpaceManifestEnum];
/**
 * @export
 */
export const ProposalsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalsSpaceManifestEnum =
  (typeof ProposalsSpaceManifestEnum)[keyof typeof ProposalsSpaceManifestEnum];
/**
 * @export
 */
export const ProposalsOrderEnum = {
  PublishedAt: "published_at",
  Rand: "rand",
} as const;
export type ProposalsOrderEnum =
  (typeof ProposalsOrderEnum)[keyof typeof ProposalsOrderEnum];
/**
 * @export
 */
export const ProposalsOrderDirectionEnum = {
  Asc: "asc",
  Desc: "desc",
} as const;
export type ProposalsOrderDirectionEnum =
  (typeof ProposalsOrderDirectionEnum)[keyof typeof ProposalsOrderDirectionEnum];

/**
 * ProposalsVoteApi - axios parameter creator
 * @export
 */
export const ProposalsVoteApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {VoteAProposalPayload} voteAProposalPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voteProposal: async (
      voteAProposalPayload: VoteAProposalPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'voteAProposalPayload' is not null or undefined
      assertParamExists(
        "voteProposal",
        "voteAProposalPayload",
        voteAProposalPayload,
      );
      const localVarPath = `/proposal_votes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        voteAProposalPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProposalsVoteApi - functional programming interface
 * @export
 */
export const ProposalsVoteApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProposalsVoteApiAxiosParamCreator(configuration);
  return {
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {VoteAProposalPayload} voteAProposalPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async voteProposal(
      voteAProposalPayload: VoteAProposalPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.voteProposal(
        voteAProposalPayload,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsVoteApi.voteProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProposalsVoteApi - factory interface
 * @export
 */
export const ProposalsVoteApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProposalsVoteApiFp(configuration);
  return {
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {ProposalsVoteApiVoteProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voteProposal(
      requestParameters: ProposalsVoteApiVoteProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalItemResponse> {
      return localVarFp
        .voteProposal(requestParameters.voteAProposalPayload, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for voteProposal operation in ProposalsVoteApi.
 * @export
 * @interface ProposalsVoteApiVoteProposalRequest
 */
export interface ProposalsVoteApiVoteProposalRequest {
  /**
   *
   * @type {VoteAProposalPayload}
   * @memberof ProposalsVoteApiVoteProposal
   */
  readonly voteAProposalPayload: VoteAProposalPayload;
}

/**
 * ProposalsVoteApi - object-oriented interface
 * @export
 * @class ProposalsVoteApi
 * @extends {BaseAPI}
 */
export class ProposalsVoteApi extends BaseAPI {
  /**
   * Vote on a proposal
   * @summary Vote
   * @param {ProposalsVoteApiVoteProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsVoteApi
   */
  public voteProposal(
    requestParameters: ProposalsVoteApiVoteProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsVoteApiFp(this.configuration)
      .voteProposal(requestParameters.voteAProposalPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SpacesApi - axios parameter creator
 * @export
 */
export const SpacesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get detail of a Assemblies given its id
     * @summary Assemblies Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assemblies: async (
      id: number,
      locales?: Array<Locale>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("assemblies", "id", id);
      const localVarPath = `/spaces/assemblies/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get detail of a Participatory Processes given its id
     * @summary Participatory Processes Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    participatoryProcesses: async (
      id: number,
      locales?: Array<Locale>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("participatoryProcesses", "id", id);
      const localVarPath = `/spaces/participatory_processes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary Search Participatory Spaces
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<SearchSpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SearchSpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameStart]
     * @param {SearchSpacesFilterManifestNameEqEnum} [filterManifestNameEq]
     * @param {SearchSpacesFilterManifestNameNotEqEnum} [filterManifestNameNotEq]
     * @param {string} [filterManifestNameMatches]
     * @param {boolean} [filterManifestNameBlank]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {boolean} [filterTitleBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSpaces: async (
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      filterManifestNameNotIn?: Array<SearchSpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SearchSpacesFilterManifestNameInEnum>,
      filterManifestNameStart?: string,
      filterManifestNameEq?: SearchSpacesFilterManifestNameEqEnum,
      filterManifestNameNotEq?: SearchSpacesFilterManifestNameNotEqEnum,
      filterManifestNameMatches?: string,
      filterManifestNameBlank?: boolean,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/spaces/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameStart !== undefined) {
        localVarQueryParameter["filter[manifest_name_start]"] =
          filterManifestNameStart;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterManifestNameMatches !== undefined) {
        localVarQueryParameter["filter[manifest_name_matches]"] =
          filterManifestNameMatches;
      }

      if (filterManifestNameBlank !== undefined) {
        localVarQueryParameter["filter[manifest_name_blank]"] =
          filterManifestNameBlank;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      if (filterIdLt !== undefined) {
        localVarQueryParameter["filter[id_lt]"] = filterIdLt;
      }

      if (filterIdGt !== undefined) {
        localVarQueryParameter["filter[id_gt]"] = filterIdGt;
      }

      if (filterIdPresent !== undefined) {
        localVarQueryParameter["filter[id_present]"] = filterIdPresent;
      }

      if (filterIdBlank !== undefined) {
        localVarQueryParameter["filter[id_blank]"] = filterIdBlank;
      }

      if (filterTitleNotIn) {
        localVarQueryParameter["filter[title_not_in][]"] = filterTitleNotIn;
      }

      if (filterTitleIn) {
        localVarQueryParameter["filter[title_in][]"] = filterTitleIn;
      }

      if (filterTitleStart !== undefined) {
        localVarQueryParameter["filter[title_start]"] = filterTitleStart;
      }

      if (filterTitleEq !== undefined) {
        localVarQueryParameter["filter[title_eq]"] = filterTitleEq;
      }

      if (filterTitleNotEq !== undefined) {
        localVarQueryParameter["filter[title_not_eq]"] = filterTitleNotEq;
      }

      if (filterTitleMatches !== undefined) {
        localVarQueryParameter["filter[title_matches]"] = filterTitleMatches;
      }

      if (filterTitleBlank !== undefined) {
        localVarQueryParameter["filter[title_blank]"] = filterTitleBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SpacesApi - functional programming interface
 * @export
 */
export const SpacesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SpacesApiAxiosParamCreator(configuration);
  return {
    /**
     * Get detail of a Assemblies given its id
     * @summary Assemblies Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assemblies(
      id: number,
      locales?: Array<Locale>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SpaceItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assemblies(
        id,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SpacesApi.assemblies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get detail of a Participatory Processes given its id
     * @summary Participatory Processes Details
     * @param {number} id
     * @param {Array<Locale>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async participatoryProcesses(
      id: number,
      locales?: Array<Locale>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SpaceItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.participatoryProcesses(
          id,
          locales,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SpacesApi.participatoryProcesses"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary Search Participatory Spaces
     * @param {Array<Locale>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<SearchSpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SearchSpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameStart]
     * @param {SearchSpacesFilterManifestNameEqEnum} [filterManifestNameEq]
     * @param {SearchSpacesFilterManifestNameNotEqEnum} [filterManifestNameNotEq]
     * @param {string} [filterManifestNameMatches]
     * @param {boolean} [filterManifestNameBlank]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {boolean} [filterTitleBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchSpaces(
      locales?: Array<Locale>,
      page?: number,
      perPage?: number,
      filterManifestNameNotIn?: Array<SearchSpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SearchSpacesFilterManifestNameInEnum>,
      filterManifestNameStart?: string,
      filterManifestNameEq?: SearchSpacesFilterManifestNameEqEnum,
      filterManifestNameNotEq?: SearchSpacesFilterManifestNameNotEqEnum,
      filterManifestNameMatches?: string,
      filterManifestNameBlank?: boolean,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SpaceIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchSpaces(
        locales,
        page,
        perPage,
        filterManifestNameNotIn,
        filterManifestNameIn,
        filterManifestNameStart,
        filterManifestNameEq,
        filterManifestNameNotEq,
        filterManifestNameMatches,
        filterManifestNameBlank,
        filterIdIn,
        filterIdEq,
        filterIdLt,
        filterIdGt,
        filterIdPresent,
        filterIdBlank,
        filterTitleNotIn,
        filterTitleIn,
        filterTitleStart,
        filterTitleEq,
        filterTitleNotEq,
        filterTitleMatches,
        filterTitleBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SpacesApi.searchSpaces"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SpacesApi - factory interface
 * @export
 */
export const SpacesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SpacesApiFp(configuration);
  return {
    /**
     * Get detail of a Assemblies given its id
     * @summary Assemblies Details
     * @param {SpacesApiAssembliesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assemblies(
      requestParameters: SpacesApiAssembliesRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceItemResponse> {
      return localVarFp
        .assemblies(requestParameters.id, requestParameters.locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get detail of a Participatory Processes given its id
     * @summary Participatory Processes Details
     * @param {SpacesApiParticipatoryProcessesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    participatoryProcesses(
      requestParameters: SpacesApiParticipatoryProcessesRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceItemResponse> {
      return localVarFp
        .participatoryProcesses(
          requestParameters.id,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary Search Participatory Spaces
     * @param {SpacesApiSearchSpacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSpaces(
      requestParameters: SpacesApiSearchSpacesRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceIndexResponse> {
      return localVarFp
        .searchSpaces(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameStart,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterManifestNameMatches,
          requestParameters.filterManifestNameBlank,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          requestParameters.filterIdLt,
          requestParameters.filterIdGt,
          requestParameters.filterIdPresent,
          requestParameters.filterIdBlank,
          requestParameters.filterTitleNotIn,
          requestParameters.filterTitleIn,
          requestParameters.filterTitleStart,
          requestParameters.filterTitleEq,
          requestParameters.filterTitleNotEq,
          requestParameters.filterTitleMatches,
          requestParameters.filterTitleBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for assemblies operation in SpacesApi.
 * @export
 * @interface SpacesApiAssembliesRequest
 */
export interface SpacesApiAssembliesRequest {
  /**
   *
   * @type {number}
   * @memberof SpacesApiAssemblies
   */
  readonly id: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof SpacesApiAssemblies
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for participatoryProcesses operation in SpacesApi.
 * @export
 * @interface SpacesApiParticipatoryProcessesRequest
 */
export interface SpacesApiParticipatoryProcessesRequest {
  /**
   *
   * @type {number}
   * @memberof SpacesApiParticipatoryProcesses
   */
  readonly id: number;

  /**
   *
   * @type {Array<Locale>}
   * @memberof SpacesApiParticipatoryProcesses
   */
  readonly locales?: Array<Locale>;
}

/**
 * Request parameters for searchSpaces operation in SpacesApi.
 * @export
 * @interface SpacesApiSearchSpacesRequest
 */
export interface SpacesApiSearchSpacesRequest {
  /**
   *
   * @type {Array<Locale>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly locales?: Array<Locale>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameNotIn?: Array<SearchSpacesFilterManifestNameNotInEnum>;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameIn?: Array<SearchSpacesFilterManifestNameInEnum>;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameStart?: string;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameEq?: SearchSpacesFilterManifestNameEqEnum;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameNotEq?: SearchSpacesFilterManifestNameNotEqEnum;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameBlank?: boolean;

  /**
   *
   * @type {Array<number>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdEq?: number;

  /**
   *
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdLt?: number;

  /**
   *
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdGt?: number;

  /**
   *
   * @type {boolean}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleStart?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleEq?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleBlank?: boolean;
}

/**
 * SpacesApi - object-oriented interface
 * @export
 * @class SpacesApi
 * @extends {BaseAPI}
 */
export class SpacesApi extends BaseAPI {
  /**
   * Get detail of a Assemblies given its id
   * @summary Assemblies Details
   * @param {SpacesApiAssembliesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public assemblies(
    requestParameters: SpacesApiAssembliesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SpacesApiFp(this.configuration)
      .assemblies(requestParameters.id, requestParameters.locales, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get detail of a Participatory Processes given its id
   * @summary Participatory Processes Details
   * @param {SpacesApiParticipatoryProcessesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public participatoryProcesses(
    requestParameters: SpacesApiParticipatoryProcessesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SpacesApiFp(this.configuration)
      .participatoryProcesses(
        requestParameters.id,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
   * @summary Search Participatory Spaces
   * @param {SpacesApiSearchSpacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public searchSpaces(
    requestParameters: SpacesApiSearchSpacesRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return SpacesApiFp(this.configuration)
      .searchSpaces(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameStart,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterManifestNameMatches,
        requestParameters.filterManifestNameBlank,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        requestParameters.filterIdLt,
        requestParameters.filterIdGt,
        requestParameters.filterIdPresent,
        requestParameters.filterIdBlank,
        requestParameters.filterTitleNotIn,
        requestParameters.filterTitleIn,
        requestParameters.filterTitleStart,
        requestParameters.filterTitleEq,
        requestParameters.filterTitleNotEq,
        requestParameters.filterTitleMatches,
        requestParameters.filterTitleBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const SearchSpacesFilterManifestNameNotInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameNotInEnum =
  (typeof SearchSpacesFilterManifestNameNotInEnum)[keyof typeof SearchSpacesFilterManifestNameNotInEnum];
/**
 * @export
 */
export const SearchSpacesFilterManifestNameInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameInEnum =
  (typeof SearchSpacesFilterManifestNameInEnum)[keyof typeof SearchSpacesFilterManifestNameInEnum];
/**
 * @export
 */
export const SearchSpacesFilterManifestNameEqEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameEqEnum =
  (typeof SearchSpacesFilterManifestNameEqEnum)[keyof typeof SearchSpacesFilterManifestNameEqEnum];
/**
 * @export
 */
export const SearchSpacesFilterManifestNameNotEqEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameNotEqEnum =
  (typeof SearchSpacesFilterManifestNameNotEqEnum)[keyof typeof SearchSpacesFilterManifestNameNotEqEnum];

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {GenerateMagicLinkPayload} [generateMagicLinkPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink: async (
      generateMagicLinkPayload?: GenerateMagicLinkPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/me/magic_links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        generateMagicLinkPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
     * @summary Use a magic-lick
     * @param {string} magicToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    magicLinkSignin: async (
      magicToken: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'magicToken' is not null or undefined
      assertParamExists("magicLinkSignin", "magicToken", magicToken);
      const localVarPath = `/me/magic_links/{magic_token}`.replace(
        `{${"magic_token"}}`,
        encodeURIComponent(String(magicToken)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {UserExtendedDataPayload} userExtendedDataPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData: async (
      userExtendedDataPayload: UserExtendedDataPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userExtendedDataPayload' is not null or undefined
      assertParamExists(
        "setUserData",
        "userExtendedDataPayload",
        userExtendedDataPayload,
      );
      const localVarPath = `/me/extended_data`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userExtendedDataPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData: async (
      objectPath: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'objectPath' is not null or undefined
      assertParamExists("userData", "objectPath", objectPath);
      const localVarPath = `/me/extended_data`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (objectPath !== undefined) {
        localVarQueryParameter["object_path"] = objectPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {boolean} [filterNicknameBlank]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users: async (
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameBlank?: boolean,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      filterExtendedDataCont?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterNicknameNotIn) {
        localVarQueryParameter["filter[nickname_not_in][]"] =
          filterNicknameNotIn;
      }

      if (filterNicknameIn) {
        localVarQueryParameter["filter[nickname_in][]"] = filterNicknameIn;
      }

      if (filterNicknameStart !== undefined) {
        localVarQueryParameter["filter[nickname_start]"] = filterNicknameStart;
      }

      if (filterNicknameEq !== undefined) {
        localVarQueryParameter["filter[nickname_eq]"] = filterNicknameEq;
      }

      if (filterNicknameNotEq !== undefined) {
        localVarQueryParameter["filter[nickname_not_eq]"] = filterNicknameNotEq;
      }

      if (filterNicknameMatches !== undefined) {
        localVarQueryParameter["filter[nickname_matches]"] =
          filterNicknameMatches;
      }

      if (filterNicknameBlank !== undefined) {
        localVarQueryParameter["filter[nickname_blank]"] = filterNicknameBlank;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      if (filterIdLt !== undefined) {
        localVarQueryParameter["filter[id_lt]"] = filterIdLt;
      }

      if (filterIdGt !== undefined) {
        localVarQueryParameter["filter[id_gt]"] = filterIdGt;
      }

      if (filterIdPresent !== undefined) {
        localVarQueryParameter["filter[id_present]"] = filterIdPresent;
      }

      if (filterIdBlank !== undefined) {
        localVarQueryParameter["filter[id_blank]"] = filterIdBlank;
      }

      if (filterExtendedDataCont !== undefined) {
        localVarQueryParameter["filter[extended_data_cont]"] =
          filterExtendedDataCont;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {GenerateMagicLinkPayload} [generateMagicLinkPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateMagicLink(
      generateMagicLinkPayload?: GenerateMagicLinkPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MagicLinkItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateMagicLink(
          generateMagicLinkPayload,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.generateMagicLink"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
     * @summary Use a magic-lick
     * @param {string} magicToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async magicLinkSignin(
      magicToken: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.magicLinkSignin(
        magicToken,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.magicLinkSignin"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {UserExtendedDataPayload} userExtendedDataPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserData(
      userExtendedDataPayload: UserExtendedDataPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserData(
        userExtendedDataPayload,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.setUserData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userData(
      objectPath: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userData(
        objectPath,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.userData"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {boolean} [filterNicknameBlank]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdLt]
     * @param {number} [filterIdGt]
     * @param {boolean} [filterIdPresent]
     * @param {boolean} [filterIdBlank]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async users(
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameBlank?: boolean,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdLt?: number,
      filterIdGt?: number,
      filterIdPresent?: boolean,
      filterIdBlank?: boolean,
      filterExtendedDataCont?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.users(
        page,
        perPage,
        filterNicknameNotIn,
        filterNicknameIn,
        filterNicknameStart,
        filterNicknameEq,
        filterNicknameNotEq,
        filterNicknameMatches,
        filterNicknameBlank,
        filterIdIn,
        filterIdEq,
        filterIdLt,
        filterIdGt,
        filterIdPresent,
        filterIdBlank,
        filterExtendedDataCont,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.users"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {UsersApiGenerateMagicLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink(
      requestParameters: UsersApiGenerateMagicLinkRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MagicLinkItemResponse> {
      return localVarFp
        .generateMagicLink(requestParameters.generateMagicLinkPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
     * @summary Use a magic-lick
     * @param {UsersApiMagicLinkSigninRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    magicLinkSignin(
      requestParameters: UsersApiMagicLinkSigninRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .magicLinkSignin(requestParameters.magicToken, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {UsersApiSetUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData(
      requestParameters: UsersApiSetUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .setUserData(requestParameters.userExtendedDataPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {UsersApiUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData(
      requestParameters: UsersApiUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .userData(requestParameters.objectPath, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {UsersApiUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users(
      requestParameters: UsersApiUsersRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserIndexResponse> {
      return localVarFp
        .users(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterNicknameNotIn,
          requestParameters.filterNicknameIn,
          requestParameters.filterNicknameStart,
          requestParameters.filterNicknameEq,
          requestParameters.filterNicknameNotEq,
          requestParameters.filterNicknameMatches,
          requestParameters.filterNicknameBlank,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          requestParameters.filterIdLt,
          requestParameters.filterIdGt,
          requestParameters.filterIdPresent,
          requestParameters.filterIdBlank,
          requestParameters.filterExtendedDataCont,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for generateMagicLink operation in UsersApi.
 * @export
 * @interface UsersApiGenerateMagicLinkRequest
 */
export interface UsersApiGenerateMagicLinkRequest {
  /**
   *
   * @type {GenerateMagicLinkPayload}
   * @memberof UsersApiGenerateMagicLink
   */
  readonly generateMagicLinkPayload?: GenerateMagicLinkPayload;
}

/**
 * Request parameters for magicLinkSignin operation in UsersApi.
 * @export
 * @interface UsersApiMagicLinkSigninRequest
 */
export interface UsersApiMagicLinkSigninRequest {
  /**
   *
   * @type {string}
   * @memberof UsersApiMagicLinkSignin
   */
  readonly magicToken: string;
}

/**
 * Request parameters for setUserData operation in UsersApi.
 * @export
 * @interface UsersApiSetUserDataRequest
 */
export interface UsersApiSetUserDataRequest {
  /**
   *
   * @type {UserExtendedDataPayload}
   * @memberof UsersApiSetUserData
   */
  readonly userExtendedDataPayload: UserExtendedDataPayload;
}

/**
 * Request parameters for userData operation in UsersApi.
 * @export
 * @interface UsersApiUserDataRequest
 */
export interface UsersApiUserDataRequest {
  /**
   *
   * @type {string}
   * @memberof UsersApiUserData
   */
  readonly objectPath: string;
}

/**
 * Request parameters for users operation in UsersApi.
 * @export
 * @interface UsersApiUsersRequest
 */
export interface UsersApiUsersRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameStart?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameEq?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameMatches?: string;

  /**
   *
   * @type {boolean}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameBlank?: boolean;

  /**
   *
   * @type {Array<number>}
   * @memberof UsersApiUsers
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly filterIdEq?: number;

  /**
   *
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly filterIdLt?: number;

  /**
   *
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly filterIdGt?: number;

  /**
   *
   * @type {boolean}
   * @memberof UsersApiUsers
   */
  readonly filterIdPresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof UsersApiUsers
   */
  readonly filterIdBlank?: boolean;

  /**
   * Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterExtendedDataCont?: string;
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
   * @summary Create a magic-lick
   * @param {UsersApiGenerateMagicLinkRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public generateMagicLink(
    requestParameters: UsersApiGenerateMagicLinkRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .generateMagicLink(requestParameters.generateMagicLinkPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
   * @summary Use a magic-lick
   * @param {UsersApiMagicLinkSigninRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public magicLinkSignin(
    requestParameters: UsersApiMagicLinkSigninRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .magicLinkSignin(requestParameters.magicToken, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
   * @summary Update user extended data
   * @param {UsersApiSetUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public setUserData(
    requestParameters: UsersApiSetUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .setUserData(requestParameters.userExtendedDataPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch user extended data
   * @summary Get user extended data
   * @param {UsersApiUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userData(
    requestParameters: UsersApiUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .userData(requestParameters.objectPath, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search users of the organization
   * @summary List available Users
   * @param {UsersApiUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public users(
    requestParameters: UsersApiUsersRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .users(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterNicknameNotIn,
        requestParameters.filterNicknameIn,
        requestParameters.filterNicknameStart,
        requestParameters.filterNicknameEq,
        requestParameters.filterNicknameNotEq,
        requestParameters.filterNicknameMatches,
        requestParameters.filterNicknameBlank,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        requestParameters.filterIdLt,
        requestParameters.filterIdGt,
        requestParameters.filterIdPresent,
        requestParameters.filterIdBlank,
        requestParameters.filterExtendedDataCont,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
