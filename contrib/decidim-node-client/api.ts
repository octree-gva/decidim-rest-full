/* tslint:disable */
/* eslint-disable */
/**
 * API V1
 * A RestFull API for Decidim, to be able to CRUD resources from Decidim.  ## Authentication [Get a token](https://octree-gva.github.io/decidim-rest-full/category/authentication) from our `/oauth/token` routes, following OAuth specs on Credential Flows or Resource Owner Password Credentials Flow.  ### Permissions A permission system is attached to the created OAuth application, that is designed in two levels:  - **scope**: a broad permission to access a collection of endpoints - **abilities**: a fine grained permission system that allow actions.  The scopes and abilities are manageable in your System Admin Panel.  ### Multi-tenant Decidim is multi-tenant, and this API supports it. - The **`system` scope** endpoints are available in any tenant - The tenant `host` attribute will be used to guess which tenant you are requesting.   For example, given a tenant `example.org` and `foobar.org`, the endpoint   * `example.org/oauth/token` will ask a token for the example.org organization   * `foobar.org/oauth/token` for foobar.org.
 *
 * The version of the OpenAPI document: v0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
  /**
   * Error title, starting with HTTP Code, like 400: bad request
   * @type {string}
   * @memberof ApiError
   */
  error: string;
  /**
   * Error detail, mostly validation error
   * @type {string}
   * @memberof ApiError
   */
  error_description: string;
  /**
   * authentification state
   * @type {string}
   * @memberof ApiError
   */
  state?: string;
}
/**
 *
 * @export
 * @interface AttachedComponents
 */
export interface AttachedComponents {
  /**
   *
   * @type {Array<AttachedComponentsDataInner>}
   * @memberof AttachedComponents
   */
  data: Array<AttachedComponentsDataInner>;
  /**
   *
   * @type {AttachedComponentsMeta}
   * @memberof AttachedComponents
   */
  meta: AttachedComponentsMeta;
  /**
   *
   * @type {AttachedComponentsLinks}
   * @memberof AttachedComponents
   */
  links: AttachedComponentsLinks;
}
/**
 *
 * @export
 * @interface AttachedComponentsDataInner
 */
export interface AttachedComponentsDataInner {
  /**
   *
   * @type {string}
   * @memberof AttachedComponentsDataInner
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof AttachedComponentsDataInner
   */
  type: ComponentType;
}

/**
 *
 * @export
 * @interface AttachedComponentsLinks
 */
export interface AttachedComponentsLinks {
  /**
   * Complete list
   * @type {string}
   * @memberof AttachedComponentsLinks
   */
  related: string;
}
/**
 *
 * @export
 * @interface AttachedComponentsMeta
 */
export interface AttachedComponentsMeta {
  /**
   * Total count for components association
   * @type {number}
   * @memberof AttachedComponentsMeta
   */
  count: number;
}
/**
 *
 * @export
 * @interface Blog
 */
export interface Blog {
  /**
   * Blog Post Id
   * @type {string}
   * @memberof Blog
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Blog
   */
  type: BlogTypeEnum;
  /**
   *
   * @type {BlogAttributes}
   * @memberof Blog
   */
  attributes: BlogAttributes;
  /**
   *
   * @type {BlogPostMetadata}
   * @memberof Blog
   */
  meta: BlogPostMetadata;
  /**
   *
   * @type {BlogPostLinks}
   * @memberof Blog
   */
  links: BlogPostLinks;
  /**
   *
   * @type {BlogPostRelationships}
   * @memberof Blog
   */
  relationships?: BlogPostRelationships;
}

export const BlogTypeEnum = {
  Blog: "blog",
} as const;

export type BlogTypeEnum = (typeof BlogTypeEnum)[keyof typeof BlogTypeEnum];

/**
 *
 * @export
 * @interface BlogAttributes
 */
export interface BlogAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogAttributes
   */
  body: TranslatedProp;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof BlogAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof BlogAttributes
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface BlogPostLinks
 */
export interface BlogPostLinks {
  /**
   * API URL to the blog post
   * @type {string}
   * @memberof BlogPostLinks
   */
  self: string;
}
/**
 *
 * @export
 * @interface BlogPostMetadata
 */
export interface BlogPostMetadata {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof BlogPostMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof BlogPostMetadata
   */
  scope?: number;
}
/**
 *
 * @export
 * @interface BlogPostRelationships
 */
export interface BlogPostRelationships {
  /**
   *
   * @type {BlogPostRelationshipsSpace}
   * @memberof BlogPostRelationships
   */
  space: BlogPostRelationshipsSpace;
  /**
   *
   * @type {BlogPostRelationshipsComponent}
   * @memberof BlogPostRelationships
   */
  component: BlogPostRelationshipsComponent;
}
/**
 *
 * @export
 * @interface BlogPostRelationshipsComponent
 */
export interface BlogPostRelationshipsComponent {
  /**
   *
   * @type {BlogPostRelationshipsComponentData}
   * @memberof BlogPostRelationshipsComponent
   */
  data: BlogPostRelationshipsComponentData;
}
/**
 *
 * @export
 * @interface BlogPostRelationshipsComponentData
 */
export interface BlogPostRelationshipsComponentData {
  /**
   * Component Id
   * @type {string}
   * @memberof BlogPostRelationshipsComponentData
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof BlogPostRelationshipsComponentData
   */
  type: ComponentType;
}

/**
 *
 * @export
 * @interface BlogPostRelationshipsSpace
 */
export interface BlogPostRelationshipsSpace {
  /**
   *
   * @type {BlogPostRelationshipsSpaceData}
   * @memberof BlogPostRelationshipsSpace
   */
  data: BlogPostRelationshipsSpaceData;
}
/**
 *
 * @export
 * @interface BlogPostRelationshipsSpaceData
 */
export interface BlogPostRelationshipsSpaceData {
  /**
   * Space Id
   * @type {string}
   * @memberof BlogPostRelationshipsSpaceData
   */
  id: string;
  /**
   * Space type
   * @type {string}
   * @memberof BlogPostRelationshipsSpaceData
   */
  type: BlogPostRelationshipsSpaceDataTypeEnum;
}

export const BlogPostRelationshipsSpaceDataTypeEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type BlogPostRelationshipsSpaceDataTypeEnum =
  (typeof BlogPostRelationshipsSpaceDataTypeEnum)[keyof typeof BlogPostRelationshipsSpaceDataTypeEnum];

/**
 *
 * @export
 * @interface BlogResponse
 */
export interface BlogResponse {
  /**
   *
   * @type {Blog}
   * @memberof BlogResponse
   */
  data: Blog;
}
/**
 *
 * @export
 * @interface BlogsResponse
 */
export interface BlogsResponse {
  /**
   *
   * @type {Array<Blog>}
   * @memberof BlogsResponse
   */
  data: Array<Blog>;
}
/**
 *
 * @export
 * @interface ClientCredential
 */
export interface ClientCredential {
  /**
   * Client Credential Flow, for **machine-to-machine**
   * @type {string}
   * @memberof ClientCredential
   */
  grant_type: ClientCredentialGrantTypeEnum;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof ClientCredential
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof ClientCredential
   */
  client_secret: string;
  /**
   * Requested scopes
   * @type {string}
   * @memberof ClientCredential
   */
  scope: ClientCredentialScopeEnum;
}

export const ClientCredentialGrantTypeEnum = {
  ClientCredentials: "client_credentials",
} as const;

export type ClientCredentialGrantTypeEnum =
  (typeof ClientCredentialGrantTypeEnum)[keyof typeof ClientCredentialGrantTypeEnum];
export const ClientCredentialScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  System: "system",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
} as const;

export type ClientCredentialScopeEnum =
  (typeof ClientCredentialScopeEnum)[keyof typeof ClientCredentialScopeEnum];

/**
 *
 * @export
 * @interface Component
 */
export interface Component {
  /**
   * Component Id
   * @type {string}
   * @memberof Component
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof Component
   */
  type: ComponentType;
  /**
   *
   * @type {ComponentAttributes}
   * @memberof Component
   */
  attributes: ComponentAttributes;
  /**
   *
   * @type {ComponentMetadata}
   * @memberof Component
   */
  meta: ComponentMetadata;
  /**
   *
   * @type {ComponentLinks}
   * @memberof Component
   */
  links: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof Component
   */
  relationships?: ComponentRelationships;
}

/**
 *
 * @export
 * @interface ComponentAttributes
 */
export interface ComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof ComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof ComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {ComponentManifest}
   * @memberof ComponentAttributes
   */
  manifest_name: ComponentManifest;
  /**
   * Associate space class name. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof ComponentAttributes
   */
  participatory_space_type: string;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof ComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof ComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof ComponentAttributes
   */
  updated_at: string;
}

/**
 *
 * @export
 * @interface ComponentLinks
 */
export interface ComponentLinks {
  /**
   * API URL to the component
   * @type {string}
   * @memberof ComponentLinks
   */
  self: string;
  /**
   * Component details API URL
   * @type {string}
   * @memberof ComponentLinks
   */
  related: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComponentManifest = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
} as const;

export type ComponentManifest =
  (typeof ComponentManifest)[keyof typeof ComponentManifest];

/**
 *
 * @export
 * @interface ComponentMetadata
 */
export interface ComponentMetadata {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  published: boolean;
  /**
   * Component handle scopes?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  scopes_enabled: boolean;
}
/**
 * @type ComponentMetadataValue
 * @export
 */
export type ComponentMetadataValue = TranslatedProp | boolean | number | string;

/**
 *
 * @export
 * @interface ComponentRelationships
 */
export interface ComponentRelationships {
  /**
   *
   * @type {ComponentResourcesDescriptor}
   * @memberof ComponentRelationships
   */
  resources: ComponentResourcesDescriptor;
}
/**
 *
 * @export
 * @interface ComponentResource
 */
export interface ComponentResource {
  /**
   * Resource ID
   * @type {string}
   * @memberof ComponentResource
   */
  id: string;
  /**
   * Resource Type
   * @type {string}
   * @memberof ComponentResource
   */
  type: string;
}
/**
 *
 * @export
 * @interface ComponentResourceDescriptorMeta
 */
export interface ComponentResourceDescriptorMeta {
  /**
   * Total count of resources
   * @type {number}
   * @memberof ComponentResourceDescriptorMeta
   */
  count: number;
}
/**
 *
 * @export
 * @interface ComponentResourcesDescriptor
 */
export interface ComponentResourcesDescriptor {
  /**
   *
   * @type {Array<ComponentResource>}
   * @memberof ComponentResourcesDescriptor
   */
  data: Array<ComponentResource>;
  /**
   *
   * @type {ComponentResourceDescriptorMeta}
   * @memberof ComponentResourcesDescriptor
   */
  meta: ComponentResourceDescriptorMeta;
}
/**
 *
 * @export
 * @interface ComponentResponse
 */
export interface ComponentResponse {
  /**
   *
   * @type {Component}
   * @memberof ComponentResponse
   */
  data: Component;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComponentType = {
  PageComponent: "page_component",
  ProposalComponent: "proposal_component",
  MeetingComponent: "meeting_component",
  BudgetComponent: "budget_component",
  SurveyComponent: "survey_component",
  AccountabilityComponent: "accountability_component",
  DebateComponent: "debate_component",
  SortitionComponent: "sortition_component",
  BlogComponent: "blog_component",
} as const;

export type ComponentType = (typeof ComponentType)[keyof typeof ComponentType];

/**
 *
 * @export
 * @interface ComponentsResponse
 */
export interface ComponentsResponse {
  /**
   *
   * @type {Array<Component>}
   * @memberof ComponentsResponse
   */
  data: Array<Component>;
}
/**
 *
 * @export
 * @interface DraftProposal
 */
export interface DraftProposal {
  /**
   * Draft Proposal Id
   * @type {string}
   * @memberof DraftProposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DraftProposal
   */
  type: DraftProposalTypeEnum;
  /**
   *
   * @type {DraftProposalAttributes}
   * @memberof DraftProposal
   */
  attributes: DraftProposalAttributes;
  /**
   *
   * @type {PropositionMetadata1}
   * @memberof DraftProposal
   */
  meta: PropositionMetadata1;
  /**
   *
   * @type {ProposalLinks}
   * @memberof DraftProposal
   */
  links: ProposalLinks;
  /**
   *
   * @type {ProposalRelationships}
   * @memberof DraftProposal
   */
  relationships?: ProposalRelationships;
}

export const DraftProposalTypeEnum = {
  DraftProposal: "draft_proposal",
} as const;

export type DraftProposalTypeEnum =
  (typeof DraftProposalTypeEnum)[keyof typeof DraftProposalTypeEnum];

/**
 *
 * @export
 * @interface DraftProposalAttributes
 */
export interface DraftProposalAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  body: TranslatedProp;
  /**
   *
   * @type {DraftProposalAttributesErrors}
   * @memberof DraftProposalAttributes
   */
  errors?: DraftProposalAttributesErrors;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  updated_at: string;
}
/**
 * Draft current errors
 * @export
 * @interface DraftProposalAttributesErrors
 */
export interface DraftProposalAttributesErrors {
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalAttributesErrors
   */
  title: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalAttributesErrors
   */
  body: Array<string>;
}
/**
 *
 * @export
 * @interface DraftProposalResponse
 */
export interface DraftProposalResponse {
  /**
   *
   * @type {DraftProposal}
   * @memberof DraftProposalResponse
   */
  data: DraftProposal;
}
/**
 *
 * @export
 * @interface Impersonation
 */
export interface Impersonation {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user impersonation**
   * @type {string}
   * @memberof Impersonation
   */
  grant_type: ImpersonationGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof Impersonation
   */
  auth_type: ImpersonationAuthTypeEnum;
  /**
   * User nickname, unique and at least 6 alphanumeric chars.
   * @type {string}
   * @memberof Impersonation
   */
  username?: string;
  /**
   * User id, will find over id and ignore username. Fails if register_on_missing=true.
   * @type {string}
   * @memberof Impersonation
   */
  id?: string;
  /**
   *
   * @type {UserImpersonationSettings}
   * @memberof Impersonation
   */
  meta?: UserImpersonationSettings;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof Impersonation
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof Impersonation
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof Impersonation
   */
  scope: ImpersonationScopeEnum;
}

export const ImpersonationGrantTypeEnum = {
  Password: "password",
} as const;

export type ImpersonationGrantTypeEnum =
  (typeof ImpersonationGrantTypeEnum)[keyof typeof ImpersonationGrantTypeEnum];
export const ImpersonationAuthTypeEnum = {
  Impersonate: "impersonate",
} as const;

export type ImpersonationAuthTypeEnum =
  (typeof ImpersonationAuthTypeEnum)[keyof typeof ImpersonationAuthTypeEnum];
export const ImpersonationScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
} as const;

export type ImpersonationScopeEnum =
  (typeof ImpersonationScopeEnum)[keyof typeof ImpersonationScopeEnum];

/**
 *
 * @export
 * @interface IntrospectData
 */
export interface IntrospectData {
  /**
   * Access token id
   * @type {number}
   * @memberof IntrospectData
   */
  sub: number;
  /**
   * If the token can be used
   * @type {boolean}
   * @memberof IntrospectData
   */
  active: boolean;
  /**
   * Where this token can be used (organization host)
   * @type {string}
   * @memberof IntrospectData
   */
  aud: string;
  /**
   *
   * @type {ResourceDetails}
   * @memberof IntrospectData
   */
  resource?: ResourceDetails;
}
/**
 *
 * @export
 * @interface IntrospectTokenRequest
 */
export interface IntrospectTokenRequest {
  /**
   *
   * @type {string}
   * @memberof IntrospectTokenRequest
   */
  token: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Locale = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type Locale = (typeof Locale)[keyof typeof Locale];

/**
 *
 * @export
 * @interface Login
 */
export interface Login {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user login**
   * @type {string}
   * @memberof Login
   */
  grant_type: LoginGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof Login
   */
  auth_type: LoginAuthTypeEnum;
  /**
   * User nickname
   * @type {string}
   * @memberof Login
   */
  username: string;
  /**
   * User password
   * @type {string}
   * @memberof Login
   */
  password: string;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof Login
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof Login
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof Login
   */
  scope: LoginScopeEnum;
}

export const LoginGrantTypeEnum = {
  Password: "password",
} as const;

export type LoginGrantTypeEnum =
  (typeof LoginGrantTypeEnum)[keyof typeof LoginGrantTypeEnum];
export const LoginAuthTypeEnum = {
  Login: "login",
} as const;

export type LoginAuthTypeEnum =
  (typeof LoginAuthTypeEnum)[keyof typeof LoginAuthTypeEnum];
export const LoginScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
} as const;

export type LoginScopeEnum =
  (typeof LoginScopeEnum)[keyof typeof LoginScopeEnum];

/**
 * @type OauthGrantParam
 * @export
 */
export type OauthGrantParam = ClientCredential | Impersonation | Login;

/**
 *
 * @export
 * @interface Organization
 */
export interface Organization {
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  type: OrganizationTypeEnum;
  /**
   *
   * @type {OrganizationAttributes}
   * @memberof Organization
   */
  attributes: OrganizationAttributes;
  /**
   *
   * @type {OrganizationMeta}
   * @memberof Organization
   */
  meta: OrganizationMeta;
}

export const OrganizationTypeEnum = {
  Organization: "organization",
} as const;

export type OrganizationTypeEnum =
  (typeof OrganizationTypeEnum)[keyof typeof OrganizationTypeEnum];

/**
 *
 * @export
 * @interface OrganizationAttributes
 */
export interface OrganizationAttributes {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof OrganizationAttributes
   */
  name: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof OrganizationAttributes
   */
  host: string;
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationAttributes
   */
  available_locales: Array<OrganizationAttributesAvailableLocalesEnum>;
  /**
   * defaut locale for the organization
   * @type {string}
   * @memberof OrganizationAttributes
   */
  default_locale: string;
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationAttributes
   */
  secondary_hosts?: Array<string>;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  updated_at: string;
}

export const OrganizationAttributesAvailableLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type OrganizationAttributesAvailableLocalesEnum =
  (typeof OrganizationAttributesAvailableLocalesEnum)[keyof typeof OrganizationAttributesAvailableLocalesEnum];

/**
 *
 * @export
 * @interface OrganizationMeta
 */
export interface OrganizationMeta {
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationMeta
   */
  locales: Array<OrganizationMetaLocalesEnum>;
}

export const OrganizationMetaLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type OrganizationMetaLocalesEnum =
  (typeof OrganizationMetaLocalesEnum)[keyof typeof OrganizationMetaLocalesEnum];

/**
 *
 * @export
 * @interface OrganizationsResponse
 */
export interface OrganizationsResponse {
  /**
   *
   * @type {Array<Organization>}
   * @memberof OrganizationsResponse
   */
  data: Array<Organization>;
}
/**
 * @type PasswordGrantParam
 * @export
 */
export type PasswordGrantParam = Impersonation | Login;

/**
 *
 * @export
 * @interface Proposal
 */
export interface Proposal {
  /**
   * Proposal Id
   * @type {string}
   * @memberof Proposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Proposal
   */
  type: ProposalTypeEnum;
  /**
   *
   * @type {BlogAttributes}
   * @memberof Proposal
   */
  attributes: BlogAttributes;
  /**
   *
   * @type {PropositionMetadata}
   * @memberof Proposal
   */
  meta: PropositionMetadata;
  /**
   *
   * @type {ProposalLinks}
   * @memberof Proposal
   */
  links: ProposalLinks;
  /**
   *
   * @type {ProposalRelationships}
   * @memberof Proposal
   */
  relationships?: ProposalRelationships;
}

export const ProposalTypeEnum = {
  Proposal: "proposal",
} as const;

export type ProposalTypeEnum =
  (typeof ProposalTypeEnum)[keyof typeof ProposalTypeEnum];

/**
 *
 * @export
 * @interface ProposalLinks
 */
export interface ProposalLinks {
  /**
   * API URL to the proposal
   * @type {string}
   * @memberof ProposalLinks
   */
  self: string;
}
/**
 *
 * @export
 * @interface ProposalRelationships
 */
export interface ProposalRelationships {
  /**
   *
   * @type {ProposalRelationshipsSpace}
   * @memberof ProposalRelationships
   */
  space: ProposalRelationshipsSpace;
  /**
   *
   * @type {BlogPostRelationshipsComponent}
   * @memberof ProposalRelationships
   */
  component: BlogPostRelationshipsComponent;
  /**
   *
   * @type {ProposalRelationshipsAuthor}
   * @memberof ProposalRelationships
   */
  author: ProposalRelationshipsAuthor;
  /**
   *
   * @type {ProposalRelationshipsCoauthors}
   * @memberof ProposalRelationships
   */
  coauthors?: ProposalRelationshipsCoauthors;
}
/**
 *
 * @export
 * @interface ProposalRelationshipsAuthor
 */
export interface ProposalRelationshipsAuthor {
  /**
   * User Id
   * @type {string}
   * @memberof ProposalRelationshipsAuthor
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ProposalRelationshipsAuthor
   */
  type?: ProposalRelationshipsAuthorTypeEnum;
}

export const ProposalRelationshipsAuthorTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type ProposalRelationshipsAuthorTypeEnum =
  (typeof ProposalRelationshipsAuthorTypeEnum)[keyof typeof ProposalRelationshipsAuthorTypeEnum];

/**
 *
 * @export
 * @interface ProposalRelationshipsCoauthors
 */
export interface ProposalRelationshipsCoauthors {
  /**
   *
   * @type {Array<ProposalRelationshipsCoauthorsDataInner>}
   * @memberof ProposalRelationshipsCoauthors
   */
  data: Array<ProposalRelationshipsCoauthorsDataInner>;
}
/**
 *
 * @export
 * @interface ProposalRelationshipsCoauthorsDataInner
 */
export interface ProposalRelationshipsCoauthorsDataInner {
  /**
   * User Id
   * @type {string}
   * @memberof ProposalRelationshipsCoauthorsDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ProposalRelationshipsCoauthorsDataInner
   */
  type: ProposalRelationshipsCoauthorsDataInnerTypeEnum;
}

export const ProposalRelationshipsCoauthorsDataInnerTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type ProposalRelationshipsCoauthorsDataInnerTypeEnum =
  (typeof ProposalRelationshipsCoauthorsDataInnerTypeEnum)[keyof typeof ProposalRelationshipsCoauthorsDataInnerTypeEnum];

/**
 *
 * @export
 * @interface ProposalRelationshipsSpace
 */
export interface ProposalRelationshipsSpace {
  /**
   *
   * @type {ProposalRelationshipsSpaceData}
   * @memberof ProposalRelationshipsSpace
   */
  data: ProposalRelationshipsSpaceData;
}
/**
 *
 * @export
 * @interface ProposalRelationshipsSpaceData
 */
export interface ProposalRelationshipsSpaceData {
  /**
   * Space Id
   * @type {string}
   * @memberof ProposalRelationshipsSpaceData
   */
  id: string;
  /**
   *
   * @type {SpaceType}
   * @memberof ProposalRelationshipsSpaceData
   */
  type: SpaceType;
}

/**
 *
 * @export
 * @interface ProposalResponse
 */
export interface ProposalResponse {
  /**
   *
   * @type {Proposal}
   * @memberof ProposalResponse
   */
  data: Proposal;
}
/**
 *
 * @export
 * @interface ProposalsResponse
 */
export interface ProposalsResponse {
  /**
   *
   * @type {Array<Proposal>}
   * @memberof ProposalsResponse
   */
  data: Array<Proposal>;
}
/**
 *
 * @export
 * @interface PropositionMetadata
 */
export interface PropositionMetadata {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof PropositionMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof PropositionMetadata
   */
  scope?: number;
}
/**
 *
 * @export
 * @interface PropositionMetadata1
 */
export interface PropositionMetadata1 {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Draft is published as it is now?
   * @type {boolean}
   * @memberof PropositionMetadata1
   */
  publishable: boolean;
  /**
   * Attached client_id
   * @type {string}
   * @memberof PropositionMetadata1
   */
  client_id: string;
  /**
   * Scope Id
   * @type {number}
   * @memberof PropositionMetadata1
   */
  scope?: number;
}
/**
 *
 * @export
 * @interface ResourceDetails
 */
export interface ResourceDetails {
  /**
   * resource id
   * @type {string}
   * @memberof ResourceDetails
   */
  id: string;
  /**
   * resource type
   * @type {string}
   * @memberof ResourceDetails
   */
  type: ResourceDetailsTypeEnum;
  /**
   *
   * @type {ResourceDetailsAttributes}
   * @memberof ResourceDetails
   */
  attributes?: ResourceDetailsAttributes;
}

export const ResourceDetailsTypeEnum = {
  User: "user",
} as const;

export type ResourceDetailsTypeEnum =
  (typeof ResourceDetailsTypeEnum)[keyof typeof ResourceDetailsTypeEnum];

/**
 *
 * @export
 * @interface ResourceDetailsAttributes
 */
export interface ResourceDetailsAttributes {
  /**
   * Email
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  email: string;
  /**
   * Last update date
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  updated_at: string;
  /**
   * Creation date
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  created_at: string;
  /**
   * Personal url (social link, website, etc.)
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  personal_url?: string;
  /**
   * Current prefered locale
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  locale?: ResourceDetailsAttributesLocaleEnum;
}

export const ResourceDetailsAttributesLocaleEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type ResourceDetailsAttributesLocaleEnum =
  (typeof ResourceDetailsAttributesLocaleEnum)[keyof typeof ResourceDetailsAttributesLocaleEnum];

/**
 *
 * @export
 * @interface SetUserDataRequest
 */
export interface SetUserDataRequest {
  /**
   * New value for the extended data at the given path
   * @type {object}
   * @memberof SetUserDataRequest
   */
  data: object;
  /**
   * object path, in dot style, like foo.bar. use \'.\' to update the whole user data
   * @type {string}
   * @memberof SetUserDataRequest
   */
  object_path?: string;
}
/**
 *
 * @export
 * @interface Space
 */
export interface Space {
  /**
   * Space Id
   * @type {string}
   * @memberof Space
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Space
   */
  type: SpaceTypeEnum;
  /**
   *
   * @type {SpaceAttributes}
   * @memberof Space
   */
  attributes: SpaceAttributes;
  /**
   *
   * @type {SpaceRelationships}
   * @memberof Space
   */
  relationships: SpaceRelationships;
  /**
   *
   * @type {SpaceLinks}
   * @memberof Space
   */
  links: SpaceLinks;
}

export const SpaceTypeEnum = {
  Space: "space",
} as const;

export type SpaceTypeEnum = (typeof SpaceTypeEnum)[keyof typeof SpaceTypeEnum];

/**
 *
 * @export
 * @interface SpaceAttributes
 */
export interface SpaceAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  subtitle?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  short_description?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  description?: TranslatedProp;
  /**
   *
   * @type {SpaceManifest}
   * @memberof SpaceAttributes
   */
  manifest_name: SpaceManifest;
  /**
   *
   * @type {string}
   * @memberof SpaceAttributes
   */
  participatory_space_type?: string;
  /**
   * Space visibility
   * @type {string}
   * @memberof SpaceAttributes
   */
  visibility: SpaceAttributesVisibilityEnum;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  updated_at: string;
}

export const SpaceAttributesVisibilityEnum = {
  Public: "public",
  Transparent: "transparent",
  Private: "private",
} as const;

export type SpaceAttributesVisibilityEnum =
  (typeof SpaceAttributesVisibilityEnum)[keyof typeof SpaceAttributesVisibilityEnum];

/**
 *
 * @export
 * @interface SpaceLinks
 */
export interface SpaceLinks {
  /**
   *
   * @type {string}
   * @memberof SpaceLinks
   */
  self: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SpaceManifest = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceManifest = (typeof SpaceManifest)[keyof typeof SpaceManifest];

/**
 *
 * @export
 * @interface SpaceRelationships
 */
export interface SpaceRelationships {
  /**
   *
   * @type {AttachedComponents}
   * @memberof SpaceRelationships
   */
  components: AttachedComponents;
}
/**
 *
 * @export
 * @interface SpaceResponse
 */
export interface SpaceResponse {
  /**
   *
   * @type {Space}
   * @memberof SpaceResponse
   */
  data: Space;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SpaceType = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceType = (typeof SpaceType)[keyof typeof SpaceType];

/**
 *
 * @export
 * @interface SpacesResponse
 */
export interface SpacesResponse {
  /**
   *
   * @type {Array<Space>}
   * @memberof SpacesResponse
   */
  data: Array<Space>;
}
/**
 * Hash with translated data, key=locale value=translation
 * @export
 * @interface TranslatedProp
 */
export interface TranslatedProp {
  /**
   * Translation in en
   * @type {string}
   * @memberof TranslatedProp
   */
  en?: string;
  /**
   * Translation in bg
   * @type {string}
   * @memberof TranslatedProp
   */
  bg?: string;
  /**
   * Translation in ar
   * @type {string}
   * @memberof TranslatedProp
   */
  ar?: string;
  /**
   * Translation in ca
   * @type {string}
   * @memberof TranslatedProp
   */
  ca?: string;
  /**
   * Translation in cs
   * @type {string}
   * @memberof TranslatedProp
   */
  cs?: string;
  /**
   * Translation in da
   * @type {string}
   * @memberof TranslatedProp
   */
  da?: string;
  /**
   * Translation in de
   * @type {string}
   * @memberof TranslatedProp
   */
  de?: string;
  /**
   * Translation in el
   * @type {string}
   * @memberof TranslatedProp
   */
  el?: string;
  /**
   * Translation in eo
   * @type {string}
   * @memberof TranslatedProp
   */
  eo?: string;
  /**
   * Translation in es
   * @type {string}
   * @memberof TranslatedProp
   */
  es?: string;
  /**
   * Translation in es-MX
   * @type {string}
   * @memberof TranslatedProp
   */
  "es-MX"?: string;
  /**
   * Translation in es-PY
   * @type {string}
   * @memberof TranslatedProp
   */
  "es-PY"?: string;
  /**
   * Translation in et
   * @type {string}
   * @memberof TranslatedProp
   */
  et?: string;
  /**
   * Translation in eu
   * @type {string}
   * @memberof TranslatedProp
   */
  eu?: string;
  /**
   * Translation in fa
   * @type {string}
   * @memberof TranslatedProp
   */
  fa?: string;
  /**
   * Translation in fi-pl
   * @type {string}
   * @memberof TranslatedProp
   */
  "fi-pl"?: string;
  /**
   * Translation in fi
   * @type {string}
   * @memberof TranslatedProp
   */
  fi?: string;
  /**
   * Translation in fr
   * @type {string}
   * @memberof TranslatedProp
   */
  fr?: string;
  /**
   * Translation in fr-CA
   * @type {string}
   * @memberof TranslatedProp
   */
  "fr-CA"?: string;
  /**
   * Translation in ga
   * @type {string}
   * @memberof TranslatedProp
   */
  ga?: string;
  /**
   * Translation in gl
   * @type {string}
   * @memberof TranslatedProp
   */
  gl?: string;
  /**
   * Translation in hr
   * @type {string}
   * @memberof TranslatedProp
   */
  hr?: string;
  /**
   * Translation in hu
   * @type {string}
   * @memberof TranslatedProp
   */
  hu?: string;
  /**
   * Translation in id
   * @type {string}
   * @memberof TranslatedProp
   */
  id?: string;
  /**
   * Translation in is
   * @type {string}
   * @memberof TranslatedProp
   */
  is?: string;
  /**
   * Translation in it
   * @type {string}
   * @memberof TranslatedProp
   */
  it?: string;
  /**
   * Translation in ja
   * @type {string}
   * @memberof TranslatedProp
   */
  ja?: string;
  /**
   * Translation in ko
   * @type {string}
   * @memberof TranslatedProp
   */
  ko?: string;
  /**
   * Translation in lb
   * @type {string}
   * @memberof TranslatedProp
   */
  lb?: string;
  /**
   * Translation in lt
   * @type {string}
   * @memberof TranslatedProp
   */
  lt?: string;
  /**
   * Translation in lv
   * @type {string}
   * @memberof TranslatedProp
   */
  lv?: string;
  /**
   * Translation in mt
   * @type {string}
   * @memberof TranslatedProp
   */
  mt?: string;
  /**
   * Translation in nl
   * @type {string}
   * @memberof TranslatedProp
   */
  nl?: string;
  /**
   * Translation in no
   * @type {string}
   * @memberof TranslatedProp
   */
  no?: string;
  /**
   * Translation in pl
   * @type {string}
   * @memberof TranslatedProp
   */
  pl?: string;
  /**
   * Translation in pt
   * @type {string}
   * @memberof TranslatedProp
   */
  pt?: string;
  /**
   * Translation in pt-BR
   * @type {string}
   * @memberof TranslatedProp
   */
  "pt-BR"?: string;
  /**
   * Translation in ro
   * @type {string}
   * @memberof TranslatedProp
   */
  ro?: string;
  /**
   * Translation in ru
   * @type {string}
   * @memberof TranslatedProp
   */
  ru?: string;
  /**
   * Translation in sk
   * @type {string}
   * @memberof TranslatedProp
   */
  sk?: string;
  /**
   * Translation in sl
   * @type {string}
   * @memberof TranslatedProp
   */
  sl?: string;
  /**
   * Translation in sr
   * @type {string}
   * @memberof TranslatedProp
   */
  sr?: string;
  /**
   * Translation in sv
   * @type {string}
   * @memberof TranslatedProp
   */
  sv?: string;
  /**
   * Translation in tr
   * @type {string}
   * @memberof TranslatedProp
   */
  tr?: string;
  /**
   * Translation in uk
   * @type {string}
   * @memberof TranslatedProp
   */
  uk?: string;
  /**
   * Translation in vi
   * @type {string}
   * @memberof TranslatedProp
   */
  vi?: string;
  /**
   * Translation in zh-CN
   * @type {string}
   * @memberof TranslatedProp
   */
  "zh-CN"?: string;
  /**
   * Translation in zh-TW
   * @type {string}
   * @memberof TranslatedProp
   */
  "zh-TW"?: string;
}
/**
 *
 * @export
 * @interface UpdateProposalDraftRequest
 */
export interface UpdateProposalDraftRequest {
  /**
   *
   * @type {UpdateProposalDraftRequestData}
   * @memberof UpdateProposalDraftRequest
   */
  data: UpdateProposalDraftRequestData;
}
/**
 * Payload to update in the proposal
 * @export
 * @interface UpdateProposalDraftRequestData
 */
export interface UpdateProposalDraftRequestData {
  /**
   * Title of the draft
   * @type {string}
   * @memberof UpdateProposalDraftRequestData
   */
  title?: string;
  /**
   * Content of the draft
   * @type {string}
   * @memberof UpdateProposalDraftRequestData
   */
  body?: string;
  /**
   * Locale of the draft. default to user locale
   * @type {string}
   * @memberof UpdateProposalDraftRequestData
   */
  locale?: UpdateProposalDraftRequestDataLocaleEnum;
}

export const UpdateProposalDraftRequestDataLocaleEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type UpdateProposalDraftRequestDataLocaleEnum =
  (typeof UpdateProposalDraftRequestDataLocaleEnum)[keyof typeof UpdateProposalDraftRequestDataLocaleEnum];

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  type: UserTypeEnum;
  /**
   *
   * @type {UserMeta}
   * @memberof User
   */
  meta?: UserMeta;
  /**
   *
   * @type {UserRelationships}
   * @memberof User
   */
  relationships?: UserRelationships;
  /**
   *
   * @type {UserAttributes}
   * @memberof User
   */
  attributes: UserAttributes;
}

export const UserTypeEnum = {
  User: "user",
} as const;

export type UserTypeEnum = (typeof UserTypeEnum)[keyof typeof UserTypeEnum];

/**
 *
 * @export
 * @interface UserAttributes
 */
export interface UserAttributes {
  /**
   * User name, use to display the Profile identity. Public
   * @type {string}
   * @memberof UserAttributes
   */
  name: string;
  /**
   * User nickname, unique identifier for the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  nickname: string;
  /**
   * Personal website URL or social link. Public
   * @type {string}
   * @memberof UserAttributes
   */
  personal_url?: string;
  /**
   * Short bio of the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  about?: string;
  /**
   *
   * @type {Locale}
   * @memberof UserAttributes
   */
  locale: Locale;
  /**
   * Email of the user. Private
   * @type {string}
   * @memberof UserAttributes
   */
  email?: string;
  /**
   * Additional data. Private
   * @type {{ [key: string]: any; }}
   * @memberof UserAttributes
   */
  extended_data: { [key: string]: any };
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  updated_at: string;
}

/**
 *
 * @export
 * @interface UserExtendedDataResponse
 */
export interface UserExtendedDataResponse {
  /**
   * Hash of values attached to a user. These values won\'t be displayed to admins or users, consider this as an internal data payload.
   * @type {{ [key: string]: any; }}
   * @memberof UserExtendedDataResponse
   */
  data: { [key: string]: any };
}
/**
 * Impersonation Settings
 * @export
 * @interface UserImpersonationSettings
 */
export interface UserImpersonationSettings {
  /**
   * Register the user if it does not exists. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  register_on_missing?: boolean;
  /**
   * Accept the TOS on registration, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  accept_tos_on_register?: boolean;
  /**
   * Skip email confirmation on creation, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  skip_confirmation_on_register?: boolean;
  /**
   * User email to use on registration. used only if register_on_missing=true. Default to <username>@example.org
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  email?: string;
  /**
   * User name. Used only if register_on_missing=true. Default to username
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  name?: string;
}
/**
 *
 * @export
 * @interface UserMeta
 */
export interface UserMeta {
  /**
   * If the user is blocked, and need to be unblocked to signin
   * @type {boolean}
   * @memberof UserMeta
   */
  blocked: boolean;
  /**
   * If the user is locked, and need to click on the mail link to unlock
   * @type {boolean}
   * @memberof UserMeta
   */
  locked: boolean;
}
/**
 *
 * @export
 * @interface UserRelationships
 */
export interface UserRelationships {
  /**
   *
   * @type {UserRelationshipsRoles}
   * @memberof UserRelationships
   */
  roles?: UserRelationshipsRoles;
}
/**
 *
 * @export
 * @interface UserRelationshipsRoles
 */
export interface UserRelationshipsRoles {
  /**
   *
   * @type {Array<UserRelationshipsRolesDataInner>}
   * @memberof UserRelationshipsRoles
   */
  data: Array<UserRelationshipsRolesDataInner>;
}
/**
 *
 * @export
 * @interface UserRelationshipsRolesDataInner
 */
export interface UserRelationshipsRolesDataInner {
  /**
   *
   * @type {string}
   * @memberof UserRelationshipsRolesDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UserRelationshipsRolesDataInner
   */
  type: UserRelationshipsRolesDataInnerTypeEnum;
}

export const UserRelationshipsRolesDataInnerTypeEnum = {
  UserRole: "user_role",
} as const;

export type UserRelationshipsRolesDataInnerTypeEnum =
  (typeof UserRelationshipsRolesDataInnerTypeEnum)[keyof typeof UserRelationshipsRolesDataInnerTypeEnum];

/**
 *
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof UsersResponse
   */
  data: Array<User>;
}

/**
 * BlogsApi - axios parameter creator
 * @export
 */
export const BlogsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} postId
     * @param {Array<BlogLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog: async (
      spaceManifest: BlogSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      postId: number,
      locales?: Array<BlogLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("blog", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("blog", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("blog", "componentId", componentId);
      // verify required parameter 'postId' is not null or undefined
      assertParamExists("blog", "postId", postId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/blogs/{post_id}`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          )
          .replace(`{${"post_id"}}`, encodeURIComponent(String(postId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get blog post list
     * @summary Show a blog detail
     * @param {BlogsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<BlogsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs: async (
      spaceManifest: BlogsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<BlogsLocalesEnum>,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("blogs", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("blogs", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("blogs", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/blogs`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BlogsApi - functional programming interface
 * @export
 */
export const BlogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BlogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} postId
     * @param {Array<BlogLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blog(
      spaceManifest: BlogSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      postId: number,
      locales?: Array<BlogLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blog(
        spaceManifest,
        spaceId,
        componentId,
        postId,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blog"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get blog post list
     * @summary Show a blog detail
     * @param {BlogsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<BlogsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogs(
      spaceManifest: BlogsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<BlogsLocalesEnum>,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogs(
        spaceManifest,
        spaceId,
        componentId,
        locales,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blogs"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BlogsApi - factory interface
 * @export
 */
export const BlogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BlogsApiFp(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogsApiBlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog(
      requestParameters: BlogsApiBlogRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogResponse> {
      return localVarFp
        .blog(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.postId,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get blog post list
     * @summary Show a blog detail
     * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs(
      requestParameters: BlogsApiBlogsRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogsResponse> {
      return localVarFp
        .blogs(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for blog operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogRequest
 */
export interface BlogsApiBlogRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof BlogsApiBlog
   */
  readonly spaceManifest: BlogSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly componentId: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly postId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof BlogsApiBlog
   */
  readonly locales?: Array<BlogLocalesEnum>;
}

/**
 * Request parameters for blogs operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogsRequest
 */
export interface BlogsApiBlogsRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof BlogsApiBlogs
   */
  readonly spaceManifest: BlogsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly componentId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof BlogsApiBlogs
   */
  readonly locales?: Array<BlogsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly perPage?: number;
}

/**
 * BlogsApi - object-oriented interface
 * @export
 * @class BlogsApi
 * @extends {BaseAPI}
 */
export class BlogsApi extends BaseAPI {
  /**
   * Get blog post details
   * @summary Show a blog detail
   * @param {BlogsApiBlogRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blog(
    requestParameters: BlogsApiBlogRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blog(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.postId,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get blog post list
   * @summary Show a blog detail
   * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blogs(
    requestParameters: BlogsApiBlogsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blogs(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const BlogSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogSpaceManifestEnum =
  (typeof BlogSpaceManifestEnum)[keyof typeof BlogSpaceManifestEnum];
/**
 * @export
 */
export const BlogLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogLocalesEnum =
  (typeof BlogLocalesEnum)[keyof typeof BlogLocalesEnum];
/**
 * @export
 */
export const BlogsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogsSpaceManifestEnum =
  (typeof BlogsSpaceManifestEnum)[keyof typeof BlogsSpaceManifestEnum];
/**
 * @export
 */
export const BlogsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogsLocalesEnum =
  (typeof BlogsLocalesEnum)[keyof typeof BlogsLocalesEnum];

/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token throught ROPC
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      oauthGrantParam: OauthGrantParam,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oauthGrantParam' is not null or undefined
      assertParamExists("createToken", "oauthGrantParam", oauthGrantParam);
      const localVarPath = `/oauth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        oauthGrantParam,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken: async (
      introspectTokenRequest: IntrospectTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'introspectTokenRequest' is not null or undefined
      assertParamExists(
        "introspectToken",
        "introspectTokenRequest",
        introspectTokenRequest,
      );
      const localVarPath = `/oauth/introspect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        introspectTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token throught ROPC
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      oauthGrantParam: OauthGrantParam,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(
        oauthGrantParam,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.createToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async introspectToken(
      introspectTokenRequest: IntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntrospectData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.introspectToken(
        introspectTokenRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.introspectToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OAuthApiFp(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token throught ROPC
     * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      requestParameters: OAuthApiCreateTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createToken(requestParameters.oauthGrantParam, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken(
      requestParameters: OAuthApiIntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntrospectData> {
      return localVarFp
        .introspectToken(requestParameters.introspectTokenRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createToken operation in OAuthApi.
 * @export
 * @interface OAuthApiCreateTokenRequest
 */
export interface OAuthApiCreateTokenRequest {
  /**
   *
   * @type {OauthGrantParam}
   * @memberof OAuthApiCreateToken
   */
  readonly oauthGrantParam: OauthGrantParam;
}

/**
 * Request parameters for introspectToken operation in OAuthApi.
 * @export
 * @interface OAuthApiIntrospectTokenRequest
 */
export interface OAuthApiIntrospectTokenRequest {
  /**
   *
   * @type {IntrospectTokenRequest}
   * @memberof OAuthApiIntrospectToken
   */
  readonly introspectTokenRequest: IntrospectTokenRequest;
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
  /**
   * Create a oauth token for the given scopes
   * @summary Request a OAuth token throught ROPC
   * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public createToken(
    requestParameters: OAuthApiCreateTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .createToken(requestParameters.oauthGrantParam, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get given oauth token details
   * @summary Introspect a OAuth token
   * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public introspectToken(
    requestParameters: OAuthApiIntrospectTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .introspectToken(requestParameters.introspectTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProposalsApi - axios parameter creator
 * @export
 */
export const ProposalsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {DraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal: async (
      spaceManifest: DraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("draftProposal", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("draftProposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("draftProposal", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Proposal detail
     * @summary Show a proposal detail
     * @param {ProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} proposalId
     * @param {Array<ProposalLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal: async (
      spaceManifest: ProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      proposalId: number,
      locales?: Array<ProposalLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("proposal", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("proposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("proposal", "componentId", componentId);
      // verify required parameter 'proposalId' is not null or undefined
      assertParamExists("proposal", "proposalId", proposalId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/{proposal_id}`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          )
          .replace(
            `{${"proposal_id"}}`,
            encodeURIComponent(String(proposalId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Proposals list
     * @summary Show proposal list
     * @param {ProposalsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<ProposalsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsOrderEnum} [order]
     * @param {ProposalsOrderDirectionEnum} [orderDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals: async (
      spaceManifest: ProposalsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<ProposalsLocalesEnum>,
      page?: number,
      perPage?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("proposals", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("proposals", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("proposals", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (order !== undefined) {
        localVarQueryParameter["order"] = order;
      }

      if (orderDirection !== undefined) {
        localVarQueryParameter["order_direction"] = orderDirection;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {PublishProposalDraftSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishProposalDraft: async (
      spaceManifest: PublishProposalDraftSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("publishProposalDraft", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("publishProposalDraft", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("publishProposalDraft", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft/publish`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements     * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token). ## Error Handling     * Field Errors: Only errors related to the fields you\'re updating will be returned.     * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response. ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Upsert a draft proposal
     * @param {UpdateProposalDraftSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {UpdateProposalDraftRequest} updateProposalDraftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProposalDraft: async (
      spaceManifest: UpdateProposalDraftSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      updateProposalDraftRequest: UpdateProposalDraftRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("updateProposalDraft", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("updateProposalDraft", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("updateProposalDraft", "componentId", componentId);
      // verify required parameter 'updateProposalDraftRequest' is not null or undefined
      assertParamExists(
        "updateProposalDraft",
        "updateProposalDraftRequest",
        updateProposalDraftRequest,
      );
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProposalDraftRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {WithdrawnProposalDraftSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnProposalDraft: async (
      spaceManifest: WithdrawnProposalDraftSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists(
        "withdrawnProposalDraft",
        "spaceManifest",
        spaceManifest,
      );
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("withdrawnProposalDraft", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("withdrawnProposalDraft", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProposalsApi - functional programming interface
 * @export
 */
export const ProposalsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProposalsApiAxiosParamCreator(configuration);
  return {
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {DraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async draftProposal(
      spaceManifest: DraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.draftProposal(
        spaceManifest,
        spaceId,
        componentId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.draftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Proposal detail
     * @summary Show a proposal detail
     * @param {ProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} proposalId
     * @param {Array<ProposalLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposal(
      spaceManifest: ProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      proposalId: number,
      locales?: Array<ProposalLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposal(
        spaceManifest,
        spaceId,
        componentId,
        proposalId,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Proposals list
     * @summary Show proposal list
     * @param {ProposalsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<ProposalsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsOrderEnum} [order]
     * @param {ProposalsOrderDirectionEnum} [orderDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposals(
      spaceManifest: ProposalsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<ProposalsLocalesEnum>,
      page?: number,
      perPage?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposals(
        spaceManifest,
        spaceId,
        componentId,
        locales,
        page,
        perPage,
        order,
        orderDirection,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposals"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {PublishProposalDraftSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishProposalDraft(
      spaceManifest: PublishProposalDraftSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.publishProposalDraft(
          spaceManifest,
          spaceId,
          componentId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.publishProposalDraft"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements     * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token). ## Error Handling     * Field Errors: Only errors related to the fields you\'re updating will be returned.     * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response. ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Upsert a draft proposal
     * @param {UpdateProposalDraftSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {UpdateProposalDraftRequest} updateProposalDraftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProposalDraft(
      spaceManifest: UpdateProposalDraftSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      updateProposalDraftRequest: UpdateProposalDraftRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateProposalDraft(
          spaceManifest,
          spaceId,
          componentId,
          updateProposalDraftRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.updateProposalDraft"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {WithdrawnProposalDraftSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async withdrawnProposalDraft(
      spaceManifest: WithdrawnProposalDraftSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.withdrawnProposalDraft(
          spaceManifest,
          spaceId,
          componentId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.withdrawnProposalDraft"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProposalsApi - factory interface
 * @export
 */
export const ProposalsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProposalsApiFp(configuration);
  return {
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {ProposalsApiDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal(
      requestParameters: ProposalsApiDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalResponse> {
      return localVarFp
        .draftProposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Proposal detail
     * @summary Show a proposal detail
     * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal(
      requestParameters: ProposalsApiProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalResponse> {
      return localVarFp
        .proposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.proposalId,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Proposals list
     * @summary Show proposal list
     * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals(
      requestParameters: ProposalsApiProposalsRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalsResponse> {
      return localVarFp
        .proposals(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.order,
          requestParameters.orderDirection,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {ProposalsApiPublishProposalDraftRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishProposalDraft(
      requestParameters: ProposalsApiPublishProposalDraftRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalResponse> {
      return localVarFp
        .publishProposalDraft(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements     * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token). ## Error Handling     * Field Errors: Only errors related to the fields you\'re updating will be returned.     * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response. ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Upsert a draft proposal
     * @param {ProposalsApiUpdateProposalDraftRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProposalDraft(
      requestParameters: ProposalsApiUpdateProposalDraftRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalResponse> {
      return localVarFp
        .updateProposalDraft(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.updateProposalDraftRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {ProposalsApiWithdrawnProposalDraftRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnProposalDraft(
      requestParameters: ProposalsApiWithdrawnProposalDraftRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalResponse> {
      return localVarFp
        .withdrawnProposalDraft(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for draftProposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiDraftProposalRequest
 */
export interface ProposalsApiDraftProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiDraftProposal
   */
  readonly spaceManifest: DraftProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiDraftProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiDraftProposal
   */
  readonly componentId: number;
}

/**
 * Request parameters for proposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalRequest
 */
export interface ProposalsApiProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposal
   */
  readonly spaceManifest: ProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly componentId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly proposalId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ProposalsApiProposal
   */
  readonly locales?: Array<ProposalLocalesEnum>;
}

/**
 * Request parameters for proposals operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalsRequest
 */
export interface ProposalsApiProposalsRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposals
   */
  readonly spaceManifest: ProposalsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly componentId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ProposalsApiProposals
   */
  readonly locales?: Array<ProposalsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly perPage?: number;

  /**
   *
   * @type {'published_at' | 'rand'}
   * @memberof ProposalsApiProposals
   */
  readonly order?: ProposalsOrderEnum;

  /**
   *
   * @type {'desc' | 'asc'}
   * @memberof ProposalsApiProposals
   */
  readonly orderDirection?: ProposalsOrderDirectionEnum;
}

/**
 * Request parameters for publishProposalDraft operation in ProposalsApi.
 * @export
 * @interface ProposalsApiPublishProposalDraftRequest
 */
export interface ProposalsApiPublishProposalDraftRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiPublishProposalDraft
   */
  readonly spaceManifest: PublishProposalDraftSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiPublishProposalDraft
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiPublishProposalDraft
   */
  readonly componentId: number;
}

/**
 * Request parameters for updateProposalDraft operation in ProposalsApi.
 * @export
 * @interface ProposalsApiUpdateProposalDraftRequest
 */
export interface ProposalsApiUpdateProposalDraftRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiUpdateProposalDraft
   */
  readonly spaceManifest: UpdateProposalDraftSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiUpdateProposalDraft
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiUpdateProposalDraft
   */
  readonly componentId: number;

  /**
   *
   * @type {UpdateProposalDraftRequest}
   * @memberof ProposalsApiUpdateProposalDraft
   */
  readonly updateProposalDraftRequest: UpdateProposalDraftRequest;
}

/**
 * Request parameters for withdrawnProposalDraft operation in ProposalsApi.
 * @export
 * @interface ProposalsApiWithdrawnProposalDraftRequest
 */
export interface ProposalsApiWithdrawnProposalDraftRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiWithdrawnProposalDraft
   */
  readonly spaceManifest: WithdrawnProposalDraftSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiWithdrawnProposalDraft
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiWithdrawnProposalDraft
   */
  readonly componentId: number;
}

/**
 * ProposalsApi - object-oriented interface
 * @export
 * @class ProposalsApi
 * @extends {BaseAPI}
 */
export class ProposalsApi extends BaseAPI {
  /**
   * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
   * @summary Display a draft proposal
   * @param {ProposalsApiDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public draftProposal(
    requestParameters: ProposalsApiDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .draftProposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Proposal detail
   * @summary Show a proposal detail
   * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposal(
    requestParameters: ProposalsApiProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.proposalId,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Proposals list
   * @summary Show proposal list
   * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposals(
    requestParameters: ProposalsApiProposalsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposals(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.order,
        requestParameters.orderDirection,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publish a draft proposal
   * @summary Publish a draft proposal
   * @param {ProposalsApiPublishProposalDraftRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public publishProposalDraft(
    requestParameters: ProposalsApiPublishProposalDraftRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .publishProposalDraft(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements     * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token). ## Error Handling     * Field Errors: Only errors related to the fields you\'re updating will be returned.     * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response. ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
   * @summary Upsert a draft proposal
   * @param {ProposalsApiUpdateProposalDraftRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public updateProposalDraft(
    requestParameters: ProposalsApiUpdateProposalDraftRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .updateProposalDraft(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.updateProposalDraftRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Withdrawn a draft proposal. This action cannot be undone.
   * @summary Withdrawn a draft proposal
   * @param {ProposalsApiWithdrawnProposalDraftRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public withdrawnProposalDraft(
    requestParameters: ProposalsApiWithdrawnProposalDraftRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .withdrawnProposalDraft(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const DraftProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type DraftProposalSpaceManifestEnum =
  (typeof DraftProposalSpaceManifestEnum)[keyof typeof DraftProposalSpaceManifestEnum];
/**
 * @export
 */
export const ProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalSpaceManifestEnum =
  (typeof ProposalSpaceManifestEnum)[keyof typeof ProposalSpaceManifestEnum];
/**
 * @export
 */
export const ProposalLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalLocalesEnum =
  (typeof ProposalLocalesEnum)[keyof typeof ProposalLocalesEnum];
/**
 * @export
 */
export const ProposalsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalsSpaceManifestEnum =
  (typeof ProposalsSpaceManifestEnum)[keyof typeof ProposalsSpaceManifestEnum];
/**
 * @export
 */
export const ProposalsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalsLocalesEnum =
  (typeof ProposalsLocalesEnum)[keyof typeof ProposalsLocalesEnum];
/**
 * @export
 */
export const ProposalsOrderEnum = {
  PublishedAt: "published_at",
  Rand: "rand",
} as const;
export type ProposalsOrderEnum =
  (typeof ProposalsOrderEnum)[keyof typeof ProposalsOrderEnum];
/**
 * @export
 */
export const ProposalsOrderDirectionEnum = {
  Desc: "desc",
  Asc: "asc",
} as const;
export type ProposalsOrderDirectionEnum =
  (typeof ProposalsOrderDirectionEnum)[keyof typeof ProposalsOrderDirectionEnum];
/**
 * @export
 */
export const PublishProposalDraftSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type PublishProposalDraftSpaceManifestEnum =
  (typeof PublishProposalDraftSpaceManifestEnum)[keyof typeof PublishProposalDraftSpaceManifestEnum];
/**
 * @export
 */
export const UpdateProposalDraftSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type UpdateProposalDraftSpaceManifestEnum =
  (typeof UpdateProposalDraftSpaceManifestEnum)[keyof typeof UpdateProposalDraftSpaceManifestEnum];
/**
 * @export
 */
export const WithdrawnProposalDraftSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type WithdrawnProposalDraftSpaceManifestEnum =
  (typeof WithdrawnProposalDraftSpaceManifestEnum)[keyof typeof WithdrawnProposalDraftSpaceManifestEnum];

/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get details of a component
     * @summary Show a Component
     * @param {number} id
     * @param {Array<ComponentLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    component: async (
      id: number,
      locales?: Array<ComponentLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("component", "id", id);
      const localVarPath = `/public/components/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search components of the organization
     * @summary List Components
     * @param {Array<ComponentsLocalesEnum>} [locales]
     * @param {Array<ComponentsFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<ComponentsFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    components: async (
      locales?: Array<ComponentsLocalesEnum>,
      filterManifestNameNotIn?: Array<ComponentsFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<ComponentsFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/components`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get detail of a space given its manifest and id
     * @summary Show Participatory Space
     * @param {number} id
     * @param {SpaceManifestNameEnum} manifestName
     * @param {Array<SpaceLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    space: async (
      id: number,
      manifestName: SpaceManifestNameEnum,
      locales?: Array<SpaceLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("space", "id", id);
      // verify required parameter 'manifestName' is not null or undefined
      assertParamExists("space", "manifestName", manifestName);
      const localVarPath = `/public/{manifest_name}/{id}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(
          `{${"manifest_name"}}`,
          encodeURIComponent(String(manifestName)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary List Participatory Spaces
     * @param {Array<SpacesLocalesEnum>} [locales]
     * @param {Array<SpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleNotStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {string} [filterTitleDoesNotMatch]
     * @param {SpacesFilterTitlePresentEnum} [filterTitlePresent]
     * @param {SpacesFilterTitleBlankEnum} [filterTitleBlank]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    spaces: async (
      locales?: Array<SpacesLocalesEnum>,
      filterManifestNameNotIn?: Array<SpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SpacesFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleNotStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleDoesNotMatch?: string,
      filterTitlePresent?: SpacesFilterTitlePresentEnum,
      filterTitleBlank?: SpacesFilterTitleBlankEnum,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/spaces`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterTitleNotIn) {
        localVarQueryParameter["filter[title_not_in][]"] = filterTitleNotIn;
      }

      if (filterTitleIn) {
        localVarQueryParameter["filter[title_in][]"] = filterTitleIn;
      }

      if (filterTitleStart !== undefined) {
        localVarQueryParameter["filter[title_start]"] = filterTitleStart;
      }

      if (filterTitleNotStart !== undefined) {
        localVarQueryParameter["filter[title_not_start]"] = filterTitleNotStart;
      }

      if (filterTitleEq !== undefined) {
        localVarQueryParameter["filter[title_eq]"] = filterTitleEq;
      }

      if (filterTitleNotEq !== undefined) {
        localVarQueryParameter["filter[title_not_eq]"] = filterTitleNotEq;
      }

      if (filterTitleMatches !== undefined) {
        localVarQueryParameter["filter[title_matches]"] = filterTitleMatches;
      }

      if (filterTitleDoesNotMatch !== undefined) {
        localVarQueryParameter["filter[title_does_not_match]"] =
          filterTitleDoesNotMatch;
      }

      if (filterTitlePresent !== undefined) {
        localVarQueryParameter["filter[title_present]"] = filterTitlePresent;
      }

      if (filterTitleBlank !== undefined) {
        localVarQueryParameter["filter[title_blank]"] = filterTitleBlank;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration);
  return {
    /**
     * Get details of a component
     * @summary Show a Component
     * @param {number} id
     * @param {Array<ComponentLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async component(
      id: number,
      locales?: Array<ComponentLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ComponentResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.component(
        id,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.component"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search components of the organization
     * @summary List Components
     * @param {Array<ComponentsLocalesEnum>} [locales]
     * @param {Array<ComponentsFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<ComponentsFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async components(
      locales?: Array<ComponentsLocalesEnum>,
      filterManifestNameNotIn?: Array<ComponentsFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<ComponentsFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ComponentsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.components(
        locales,
        filterManifestNameNotIn,
        filterManifestNameIn,
        filterManifestNameEq,
        filterManifestNameNotEq,
        filterParticipatorySpaceIdIn,
        filterParticipatorySpaceIdEq,
        filterParticipatorySpaceTypeIn,
        filterParticipatorySpaceTypeEq,
        filterNameStart,
        filterNameEq,
        filterNameNotEq,
        filterNameMatches,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.components"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get detail of a space given its manifest and id
     * @summary Show Participatory Space
     * @param {number} id
     * @param {SpaceManifestNameEnum} manifestName
     * @param {Array<SpaceLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async space(
      id: number,
      manifestName: SpaceManifestNameEnum,
      locales?: Array<SpaceLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpaceResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.space(
        id,
        manifestName,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.space"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary List Participatory Spaces
     * @param {Array<SpacesLocalesEnum>} [locales]
     * @param {Array<SpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleNotStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {string} [filterTitleDoesNotMatch]
     * @param {SpacesFilterTitlePresentEnum} [filterTitlePresent]
     * @param {SpacesFilterTitleBlankEnum} [filterTitleBlank]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async spaces(
      locales?: Array<SpacesLocalesEnum>,
      filterManifestNameNotIn?: Array<SpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SpacesFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleNotStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleDoesNotMatch?: string,
      filterTitlePresent?: SpacesFilterTitlePresentEnum,
      filterTitleBlank?: SpacesFilterTitleBlankEnum,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpacesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.spaces(
        locales,
        filterManifestNameNotIn,
        filterManifestNameIn,
        filterManifestNameEq,
        filterManifestNameNotEq,
        filterTitleNotIn,
        filterTitleIn,
        filterTitleStart,
        filterTitleNotStart,
        filterTitleEq,
        filterTitleNotEq,
        filterTitleMatches,
        filterTitleDoesNotMatch,
        filterTitlePresent,
        filterTitleBlank,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.spaces"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PublicApiFp(configuration);
  return {
    /**
     * Get details of a component
     * @summary Show a Component
     * @param {PublicApiComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    component(
      requestParameters: PublicApiComponentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComponentResponse> {
      return localVarFp
        .component(requestParameters.id, requestParameters.locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search components of the organization
     * @summary List Components
     * @param {PublicApiComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    components(
      requestParameters: PublicApiComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComponentsResponse> {
      return localVarFp
        .components(
          requestParameters.locales,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get detail of a space given its manifest and id
     * @summary Show Participatory Space
     * @param {PublicApiSpaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    space(
      requestParameters: PublicApiSpaceRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceResponse> {
      return localVarFp
        .space(
          requestParameters.id,
          requestParameters.manifestName,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary List Participatory Spaces
     * @param {PublicApiSpacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    spaces(
      requestParameters: PublicApiSpacesRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpacesResponse> {
      return localVarFp
        .spaces(
          requestParameters.locales,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterTitleNotIn,
          requestParameters.filterTitleIn,
          requestParameters.filterTitleStart,
          requestParameters.filterTitleNotStart,
          requestParameters.filterTitleEq,
          requestParameters.filterTitleNotEq,
          requestParameters.filterTitleMatches,
          requestParameters.filterTitleDoesNotMatch,
          requestParameters.filterTitlePresent,
          requestParameters.filterTitleBlank,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for component operation in PublicApi.
 * @export
 * @interface PublicApiComponentRequest
 */
export interface PublicApiComponentRequest {
  /**
   *
   * @type {number}
   * @memberof PublicApiComponent
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiComponent
   */
  readonly locales?: Array<ComponentLocalesEnum>;
}

/**
 * Request parameters for components operation in PublicApi.
 * @export
 * @interface PublicApiComponentsRequest
 */
export interface PublicApiComponentsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiComponents
   */
  readonly locales?: Array<ComponentsLocalesEnum>;

  /**
   *
   * @type {Array<'pages' | 'proposals' | 'meetings' | 'budgets' | 'surveys' | 'accountability' | 'debates' | 'sortitions' | 'blogs'>}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameNotIn?: Array<ComponentsFilterManifestNameNotInEnum>;

  /**
   *
   * @type {Array<'pages' | 'proposals' | 'meetings' | 'budgets' | 'surveys' | 'accountability' | 'debates' | 'sortitions' | 'blogs'>}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameIn?: Array<ComponentsFilterManifestNameInEnum>;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameNotEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceTypeEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameMatches?: string;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof PublicApiComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof PublicApiComponents
   */
  readonly perPage?: number;
}

/**
 * Request parameters for space operation in PublicApi.
 * @export
 * @interface PublicApiSpaceRequest
 */
export interface PublicApiSpaceRequest {
  /**
   *
   * @type {number}
   * @memberof PublicApiSpace
   */
  readonly id: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof PublicApiSpace
   */
  readonly manifestName: SpaceManifestNameEnum;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiSpace
   */
  readonly locales?: Array<SpaceLocalesEnum>;
}

/**
 * Request parameters for spaces operation in PublicApi.
 * @export
 * @interface PublicApiSpacesRequest
 */
export interface PublicApiSpacesRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiSpaces
   */
  readonly locales?: Array<SpacesLocalesEnum>;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameNotIn?: Array<SpacesFilterManifestNameNotInEnum>;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameIn?: Array<SpacesFilterManifestNameInEnum>;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameNotEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleStart?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleNotStart?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleMatches?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleDoesNotMatch?: string;

  /**
   *
   * @type {'1' | '0'}
   * @memberof PublicApiSpaces
   */
  readonly filterTitlePresent?: SpacesFilterTitlePresentEnum;

  /**
   *
   * @type {'1' | '0'}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleBlank?: SpacesFilterTitleBlankEnum;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof PublicApiSpaces
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof PublicApiSpaces
   */
  readonly perPage?: number;
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
  /**
   * Get details of a component
   * @summary Show a Component
   * @param {PublicApiComponentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public component(
    requestParameters: PublicApiComponentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .component(requestParameters.id, requestParameters.locales, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search components of the organization
   * @summary List Components
   * @param {PublicApiComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public components(
    requestParameters: PublicApiComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .components(
        requestParameters.locales,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get detail of a space given its manifest and id
   * @summary Show Participatory Space
   * @param {PublicApiSpaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public space(
    requestParameters: PublicApiSpaceRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .space(
        requestParameters.id,
        requestParameters.manifestName,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
   * @summary List Participatory Spaces
   * @param {PublicApiSpacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public spaces(
    requestParameters: PublicApiSpacesRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .spaces(
        requestParameters.locales,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterTitleNotIn,
        requestParameters.filterTitleIn,
        requestParameters.filterTitleStart,
        requestParameters.filterTitleNotStart,
        requestParameters.filterTitleEq,
        requestParameters.filterTitleNotEq,
        requestParameters.filterTitleMatches,
        requestParameters.filterTitleDoesNotMatch,
        requestParameters.filterTitlePresent,
        requestParameters.filterTitleBlank,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ComponentLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ComponentLocalesEnum =
  (typeof ComponentLocalesEnum)[keyof typeof ComponentLocalesEnum];
/**
 * @export
 */
export const ComponentsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ComponentsLocalesEnum =
  (typeof ComponentsLocalesEnum)[keyof typeof ComponentsLocalesEnum];
/**
 * @export
 */
export const ComponentsFilterManifestNameNotInEnum = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
} as const;
export type ComponentsFilterManifestNameNotInEnum =
  (typeof ComponentsFilterManifestNameNotInEnum)[keyof typeof ComponentsFilterManifestNameNotInEnum];
/**
 * @export
 */
export const ComponentsFilterManifestNameInEnum = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
} as const;
export type ComponentsFilterManifestNameInEnum =
  (typeof ComponentsFilterManifestNameInEnum)[keyof typeof ComponentsFilterManifestNameInEnum];
/**
 * @export
 */
export const SpaceManifestNameEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SpaceManifestNameEnum =
  (typeof SpaceManifestNameEnum)[keyof typeof SpaceManifestNameEnum];
/**
 * @export
 */
export const SpaceLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type SpaceLocalesEnum =
  (typeof SpaceLocalesEnum)[keyof typeof SpaceLocalesEnum];
/**
 * @export
 */
export const SpacesLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type SpacesLocalesEnum =
  (typeof SpacesLocalesEnum)[keyof typeof SpacesLocalesEnum];
/**
 * @export
 */
export const SpacesFilterManifestNameNotInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SpacesFilterManifestNameNotInEnum =
  (typeof SpacesFilterManifestNameNotInEnum)[keyof typeof SpacesFilterManifestNameNotInEnum];
/**
 * @export
 */
export const SpacesFilterManifestNameInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SpacesFilterManifestNameInEnum =
  (typeof SpacesFilterManifestNameInEnum)[keyof typeof SpacesFilterManifestNameInEnum];
/**
 * @export
 */
export const SpacesFilterTitlePresentEnum = {
  _1: "1",
  _0: "0",
} as const;
export type SpacesFilterTitlePresentEnum =
  (typeof SpacesFilterTitlePresentEnum)[keyof typeof SpacesFilterTitlePresentEnum];
/**
 * @export
 */
export const SpacesFilterTitleBlankEnum = {
  _1: "1",
  _0: "0",
} as const;
export type SpacesFilterTitleBlankEnum =
  (typeof SpacesFilterTitleBlankEnum)[keyof typeof SpacesFilterTitleBlankEnum];

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {Array<OrganizationsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations: async (
      locales?: Array<OrganizationsLocalesEnum>,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/organizations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {number} userId
     * @param {SetUserDataRequest} setUserDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData: async (
      userId: number,
      setUserDataRequest: SetUserDataRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("setUserData", "userId", userId);
      // verify required parameter 'setUserDataRequest' is not null or undefined
      assertParamExists(
        "setUserData",
        "setUserDataRequest",
        setUserDataRequest,
      );
      const localVarPath = `/system/users/{user_id}/extended_data`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUserDataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData: async (
      objectPath: string,
      userId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'objectPath' is not null or undefined
      assertParamExists("userData", "objectPath", objectPath);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("userData", "userId", userId);
      const localVarPath = `/system/users/{user_id}/extended_data`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (objectPath !== undefined) {
        localVarQueryParameter["object_path"] = objectPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameNotStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {string} [filterNicknameDoesNotMatch]
     * @param {UsersFilterNicknamePresentEnum} [filterNicknamePresent]
     * @param {UsersFilterNicknameBlankEnum} [filterNicknameBlank]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users: async (
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameNotStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameDoesNotMatch?: string,
      filterNicknamePresent?: UsersFilterNicknamePresentEnum,
      filterNicknameBlank?: UsersFilterNicknameBlankEnum,
      filterExtendedDataCont?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterNicknameNotIn) {
        localVarQueryParameter["filter[nickname_not_in][]"] =
          filterNicknameNotIn;
      }

      if (filterNicknameIn) {
        localVarQueryParameter["filter[nickname_in][]"] = filterNicknameIn;
      }

      if (filterNicknameStart !== undefined) {
        localVarQueryParameter["filter[nickname_start]"] = filterNicknameStart;
      }

      if (filterNicknameNotStart !== undefined) {
        localVarQueryParameter["filter[nickname_not_start]"] =
          filterNicknameNotStart;
      }

      if (filterNicknameEq !== undefined) {
        localVarQueryParameter["filter[nickname_eq]"] = filterNicknameEq;
      }

      if (filterNicknameNotEq !== undefined) {
        localVarQueryParameter["filter[nickname_not_eq]"] = filterNicknameNotEq;
      }

      if (filterNicknameMatches !== undefined) {
        localVarQueryParameter["filter[nickname_matches]"] =
          filterNicknameMatches;
      }

      if (filterNicknameDoesNotMatch !== undefined) {
        localVarQueryParameter["filter[nickname_does_not_match]"] =
          filterNicknameDoesNotMatch;
      }

      if (filterNicknamePresent !== undefined) {
        localVarQueryParameter["filter[nickname_present]"] =
          filterNicknamePresent;
      }

      if (filterNicknameBlank !== undefined) {
        localVarQueryParameter["filter[nickname_blank]"] = filterNicknameBlank;
      }

      if (filterExtendedDataCont !== undefined) {
        localVarQueryParameter["filter[extended_data_cont]"] =
          filterExtendedDataCont;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration);
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {Array<OrganizationsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizations(
      locales?: Array<OrganizationsLocalesEnum>,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrganizationsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.organizations(
        locales,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.organizations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {number} userId
     * @param {SetUserDataRequest} setUserDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserData(
      userId: number,
      setUserDataRequest: SetUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserData(
        userId,
        setUserDataRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.setUserData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userData(
      objectPath: string,
      userId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userData(
        objectPath,
        userId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.userData"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameNotStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {string} [filterNicknameDoesNotMatch]
     * @param {UsersFilterNicknamePresentEnum} [filterNicknamePresent]
     * @param {UsersFilterNicknameBlankEnum} [filterNicknameBlank]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async users(
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameNotStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameDoesNotMatch?: string,
      filterNicknamePresent?: UsersFilterNicknamePresentEnum,
      filterNicknameBlank?: UsersFilterNicknameBlankEnum,
      filterExtendedDataCont?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.users(
        page,
        perPage,
        filterNicknameNotIn,
        filterNicknameIn,
        filterNicknameStart,
        filterNicknameNotStart,
        filterNicknameEq,
        filterNicknameNotEq,
        filterNicknameMatches,
        filterNicknameDoesNotMatch,
        filterNicknamePresent,
        filterNicknameBlank,
        filterExtendedDataCont,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.users"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration);
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {SystemApiOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations(
      requestParameters: SystemApiOrganizationsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OrganizationsResponse> {
      return localVarFp
        .organizations(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {SystemApiSetUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData(
      requestParameters: SystemApiSetUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .setUserData(
          requestParameters.userId,
          requestParameters.setUserDataRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {SystemApiUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData(
      requestParameters: SystemApiUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .userData(
          requestParameters.objectPath,
          requestParameters.userId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {SystemApiUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users(
      requestParameters: SystemApiUsersRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UsersResponse> {
      return localVarFp
        .users(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterNicknameNotIn,
          requestParameters.filterNicknameIn,
          requestParameters.filterNicknameStart,
          requestParameters.filterNicknameNotStart,
          requestParameters.filterNicknameEq,
          requestParameters.filterNicknameNotEq,
          requestParameters.filterNicknameMatches,
          requestParameters.filterNicknameDoesNotMatch,
          requestParameters.filterNicknamePresent,
          requestParameters.filterNicknameBlank,
          requestParameters.filterExtendedDataCont,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for organizations operation in SystemApi.
 * @export
 * @interface SystemApiOrganizationsRequest
 */
export interface SystemApiOrganizationsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof SystemApiOrganizations
   */
  readonly locales?: Array<OrganizationsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof SystemApiOrganizations
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof SystemApiOrganizations
   */
  readonly perPage?: number;
}

/**
 * Request parameters for setUserData operation in SystemApi.
 * @export
 * @interface SystemApiSetUserDataRequest
 */
export interface SystemApiSetUserDataRequest {
  /**
   *
   * @type {number}
   * @memberof SystemApiSetUserData
   */
  readonly userId: number;

  /**
   *
   * @type {SetUserDataRequest}
   * @memberof SystemApiSetUserData
   */
  readonly setUserDataRequest: SetUserDataRequest;
}

/**
 * Request parameters for userData operation in SystemApi.
 * @export
 * @interface SystemApiUserDataRequest
 */
export interface SystemApiUserDataRequest {
  /**
   *
   * @type {string}
   * @memberof SystemApiUserData
   */
  readonly objectPath: string;

  /**
   *
   * @type {number}
   * @memberof SystemApiUserData
   */
  readonly userId: number;
}

/**
 * Request parameters for users operation in SystemApi.
 * @export
 * @interface SystemApiUsersRequest
 */
export interface SystemApiUsersRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof SystemApiUsers
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof SystemApiUsers
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameStart?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameNotStart?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameEq?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameMatches?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameDoesNotMatch?: string;

  /**
   *
   * @type {'1' | '0'}
   * @memberof SystemApiUsers
   */
  readonly filterNicknamePresent?: UsersFilterNicknamePresentEnum;

  /**
   *
   * @type {'1' | '0'}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameBlank?: UsersFilterNicknameBlankEnum;

  /**
   * Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterExtendedDataCont?: string;
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   * List available organizations
   * @summary List available organizations
   * @param {SystemApiOrganizationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public organizations(
    requestParameters: SystemApiOrganizationsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .organizations(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
   * @summary Update user extended data
   * @param {SystemApiSetUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public setUserData(
    requestParameters: SystemApiSetUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .setUserData(
        requestParameters.userId,
        requestParameters.setUserDataRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch user extended data
   * @summary Get user extended data
   * @param {SystemApiUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public userData(
    requestParameters: SystemApiUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .userData(requestParameters.objectPath, requestParameters.userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search users of the organization
   * @summary List available Users
   * @param {SystemApiUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public users(
    requestParameters: SystemApiUsersRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .users(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterNicknameNotIn,
        requestParameters.filterNicknameIn,
        requestParameters.filterNicknameStart,
        requestParameters.filterNicknameNotStart,
        requestParameters.filterNicknameEq,
        requestParameters.filterNicknameNotEq,
        requestParameters.filterNicknameMatches,
        requestParameters.filterNicknameDoesNotMatch,
        requestParameters.filterNicknamePresent,
        requestParameters.filterNicknameBlank,
        requestParameters.filterExtendedDataCont,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const OrganizationsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type OrganizationsLocalesEnum =
  (typeof OrganizationsLocalesEnum)[keyof typeof OrganizationsLocalesEnum];
/**
 * @export
 */
export const UsersFilterNicknamePresentEnum = {
  _1: "1",
  _0: "0",
} as const;
export type UsersFilterNicknamePresentEnum =
  (typeof UsersFilterNicknamePresentEnum)[keyof typeof UsersFilterNicknamePresentEnum];
/**
 * @export
 */
export const UsersFilterNicknameBlankEnum = {
  _1: "1",
  _0: "0",
} as const;
export type UsersFilterNicknameBlankEnum =
  (typeof UsersFilterNicknameBlankEnum)[keyof typeof UsersFilterNicknameBlankEnum];
