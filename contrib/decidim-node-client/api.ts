/* tslint:disable */
/* eslint-disable */
/**
 * API V1
 * A RestFull API for Decidim, to be able to CRUD resources from Decidim.  ## Authentication [Get a token](https://octree-gva.github.io/decidim-rest-full/category/authentication) from our `/oauth/token` routes, following OAuth specs on Credential Flows or Resource Owner Password Credentials Flow.  ### Permissions A permission system is attached to the created OAuth application, that is designed in two levels:  - **scope**: a broad permission to access a collection of endpoints - **abilities**: a fine grained permission system that allow actions.  The scopes and abilities are manageable in your System Admin Panel.  ### Multi-tenant Decidim is multi-tenant, and this API supports it. - The **`system` scope** endpoints are available in any tenant - The tenant `host` attribute will be used to guess which tenant you are requesting.   For example, given a tenant `example.org` and `foobar.org`, the endpoint   * `example.org/oauth/token` will ask a token for the example.org organization   * `foobar.org/oauth/token` for foobar.org.
 *
 * The version of the OpenAPI document: v0.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface AttachedComponentsMeta
 */
export interface AttachedComponentsMeta {
  /**
   * Total count for components association
   * @type {number}
   * @memberof AttachedComponentsMeta
   */
  count: number;
}
/**
 *
 * @export
 * @interface AvailableVotesInThisProposalComponentInner
 */
export interface AvailableVotesInThisProposalComponentInner {
  /**
   * Label to voting button
   * @type {string}
   * @memberof AvailableVotesInThisProposalComponentInner
   */
  label: string;
  /**
   * Value to add to the vote. 0 for abstention
   * @type {number}
   * @memberof AvailableVotesInThisProposalComponentInner
   */
  weight: number;
}
/**
 *
 * @export
 * @interface Blog
 */
export interface Blog {
  /**
   * Blog Post Id
   * @type {string}
   * @memberof Blog
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Blog
   */
  type: BlogTypeEnum;
  /**
   *
   * @type {BlogAttributes}
   * @memberof Blog
   */
  attributes: BlogAttributes;
  /**
   *
   * @type {BlogPostMetadata}
   * @memberof Blog
   */
  meta: BlogPostMetadata;
  /**
   *
   * @type {BlogPostLinks}
   * @memberof Blog
   */
  links: BlogPostLinks;
  /**
   *
   * @type {BlogPostRelationships}
   * @memberof Blog
   */
  relationships?: BlogPostRelationships;
}

export const BlogTypeEnum = {
  Blog: "blog",
} as const;

export type BlogTypeEnum = (typeof BlogTypeEnum)[keyof typeof BlogTypeEnum];

/**
 *
 * @export
 * @interface BlogAttributes
 */
export interface BlogAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogAttributes
   */
  body: TranslatedProp;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof BlogAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof BlogAttributes
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface BlogComponent
 */
export interface BlogComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof BlogComponent
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof BlogComponent
   */
  type?: BlogComponentTypeEnum;
  /**
   *
   * @type {BlogComponentAttributes}
   * @memberof BlogComponent
   */
  attributes?: BlogComponentAttributes;
  /**
   *
   * @type {ComponentMetadata}
   * @memberof BlogComponent
   */
  meta?: ComponentMetadata;
  /**
   *
   * @type {ComponentLinks}
   * @memberof BlogComponent
   */
  links?: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof BlogComponent
   */
  relationships?: ComponentRelationships;
}

export const BlogComponentTypeEnum = {
  BlogComponent: "blog_component",
} as const;

export type BlogComponentTypeEnum =
  (typeof BlogComponentTypeEnum)[keyof typeof BlogComponentTypeEnum];

/**
 *
 * @export
 * @interface BlogComponentAttributes
 */
export interface BlogComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof BlogComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof BlogComponentAttributes
   */
  manifest_name: BlogComponentAttributesManifestNameEnum;
}

export const BlogComponentAttributesManifestNameEnum = {
  Blogs: "blogs",
} as const;

export type BlogComponentAttributesManifestNameEnum =
  (typeof BlogComponentAttributesManifestNameEnum)[keyof typeof BlogComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface BlogComponentIndexResponse
 */
export interface BlogComponentIndexResponse {
  /**
   *
   * @type {Array<BlogComponent>}
   * @memberof BlogComponentIndexResponse
   */
  data: Array<BlogComponent>;
}
/**
 *
 * @export
 * @interface BlogComponentItemResponse
 */
export interface BlogComponentItemResponse {
  /**
   *
   * @type {BlogComponent}
   * @memberof BlogComponentItemResponse
   */
  data: BlogComponent;
}
/**
 *
 * @export
 * @interface BlogIndexResponse
 */
export interface BlogIndexResponse {
  /**
   *
   * @type {Array<Blog>}
   * @memberof BlogIndexResponse
   */
  data: Array<Blog>;
}
/**
 *
 * @export
 * @interface BlogItemResponse
 */
export interface BlogItemResponse {
  /**
   *
   * @type {Blog}
   * @memberof BlogItemResponse
   */
  data: Blog;
}
/**
 *
 * @export
 * @interface BlogPostLinks
 */
export interface BlogPostLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  collection: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  related: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  prev?: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof BlogPostLinks
   */
  next?: ResourceLink;
}
/**
 *
 * @export
 * @interface BlogPostMetadata
 */
export interface BlogPostMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof BlogPostMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof BlogPostMetadata
   */
  scope?: number;
}
/**
 * @type BlogPostMetadataValue
 * @export
 */
export type BlogPostMetadataValue = TranslatedProp | boolean | number | string;

/**
 *
 * @export
 * @interface BlogPostRelationships
 */
export interface BlogPostRelationships {
  /**
   *
   * @type {LinkedSpace}
   * @memberof BlogPostRelationships
   */
  space: LinkedSpace;
  /**
   *
   * @type {LinkedComponent}
   * @memberof BlogPostRelationships
   */
  component: LinkedComponent;
}
/**
 *
 * @export
 * @interface ClientCredential
 */
export interface ClientCredential {
  /**
   * Client Credential Flow, for **machine-to-machine**
   * @type {string}
   * @memberof ClientCredential
   */
  grant_type: ClientCredentialGrantTypeEnum;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof ClientCredential
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof ClientCredential
   */
  client_secret: string;
  /**
   * Requested scopes
   * @type {string}
   * @memberof ClientCredential
   */
  scope: ClientCredentialScopeEnum;
}

export const ClientCredentialGrantTypeEnum = {
  ClientCredentials: "client_credentials",
} as const;

export type ClientCredentialGrantTypeEnum =
  (typeof ClientCredentialGrantTypeEnum)[keyof typeof ClientCredentialGrantTypeEnum];
export const ClientCredentialScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  System: "system",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type ClientCredentialScopeEnum =
  (typeof ClientCredentialScopeEnum)[keyof typeof ClientCredentialScopeEnum];

/**
 * @type Component
 * @export
 */
export type Component = BlogComponent | OtherComponent | ProposalComponent;

/**
 *
 * @export
 * @interface ComponentIndexResponse
 */
export interface ComponentIndexResponse {
  /**
   *
   * @type {Array<Component>}
   * @memberof ComponentIndexResponse
   */
  data: Array<Component>;
}
/**
 *
 * @export
 * @interface ComponentItemResponse
 */
export interface ComponentItemResponse {
  /**
   *
   * @type {Component}
   * @memberof ComponentItemResponse
   */
  data: Component;
}
/**
 *
 * @export
 * @interface ComponentLinks
 */
export interface ComponentLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof ComponentLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ComponentLinks
   */
  related?: ResourceLink;
}
/**
 *
 * @export
 * @interface ComponentLinks1
 */
export interface ComponentLinks1 {
  /**
   *
   * @type {ResourceLink}
   * @memberof ComponentLinks1
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ComponentLinks1
   */
  related?: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ComponentLinks1
   */
  draft?: ResourceLink;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComponentManifest = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type ComponentManifest =
  (typeof ComponentManifest)[keyof typeof ComponentManifest];

/**
 *
 * @export
 * @interface ComponentMetadata
 */
export interface ComponentMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  published: boolean;
  /**
   * Component handle scopes?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  scopes_enabled: boolean;
}
/**
 *
 * @export
 * @interface ComponentMetadata1
 */
export interface ComponentMetadata1 {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  published: boolean;
  /**
   * Component handle scopes?
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  scopes_enabled: boolean;
  /**
   * If the current user can create proposal (component allows, and user did not reach publication limit)
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  can_create_proposals: boolean;
  /**
   * If the current user can vote on the component
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  can_vote: boolean;
  /**
   * If the current user comment on the component
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  can_comment: boolean;
  /**
   * If the component needs a map to display its resources
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  geocoding_enabled: boolean;
  /**
   * If the component allows to attach files to resources
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  attachments_allowed: boolean;
  /**
   * If you can create collaborative draft for the proposal
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  collaborative_drafts_enabled?: boolean;
  /**
   * If you can comment on proposals
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  comments_enabled?: boolean;
  /**
   * Characters limit for comment
   * @type {number}
   * @memberof ComponentMetadata1
   */
  comments_max_length?: number;
  /**
   * Default order of proposals
   * @type {string}
   * @memberof ComponentMetadata1
   */
  default_sort_order?: ComponentMetadata1DefaultSortOrderEnum;
  /**
   * If proposals can be official
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  official_proposals_enabled?: boolean;
  /**
   * If proposals are based on a text modification
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  participatory_texts_enabled?: boolean;
  /**
   * Time in minute participant can edit the proposal
   * @type {number}
   * @memberof ComponentMetadata1
   */
  proposal_edit_before_minutes?: number;
  /**
   * Type of restriction for proposal edition
   * @type {string}
   * @memberof ComponentMetadata1
   */
  proposal_edit_time?: ComponentMetadata1ProposalEditTimeEnum;
  /**
   * Max proposal per participant. No maximum if value is 0
   * @type {number}
   * @memberof ComponentMetadata1
   */
  proposal_limit?: number;
  /**
   * If authorizations can be defined per proposal
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  resources_permissions_enabled?: boolean;
  /**
   * Threshold to compare similar proposals
   * @type {number}
   * @memberof ComponentMetadata1
   */
  threshold_per_proposal?: number;
  /**
   * Max Number of vote per participant. 0 if no limit
   * @type {number}
   * @memberof ComponentMetadata1
   */
  vote_limit: number;
  /**
   * If endorsements are enabled
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  endorsements_enabled?: boolean;
  /**
   * If votes on proposal are enabled
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  votes_enabled?: boolean;
  /**
   * If participant can create proposal are enabled
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  creation_enabled?: boolean;
  /**
   * If officials can answer proposals
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  proposal_answering_enabled?: boolean;
  /**
   * If participant can propose an amendment to a proposal
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  amendment_creation_enabled?: boolean;
  /**
   * If participant can react to an amendment of a proposal
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  amendment_reaction_enabled?: boolean;
  /**
   * If participant choose an amendment to replace their initial proposal
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  amendment_promotion_enabled?: boolean;
  /**
   * Vote weight, if can_vote is true.
   * @type {Array<AvailableVotesInThisProposalComponentInner>}
   * @memberof ComponentMetadata1
   */
  votes?: Array<AvailableVotesInThisProposalComponentInner>;
}

export const ComponentMetadata1DefaultSortOrderEnum = {
  Random: "random",
  Recent: "recent",
  MostVoted: "most_voted",
  MostEndorsed: "most_endorsed",
  MostCommented: "most_commented",
  MostFollowed: "most_followed",
  WithMoreAuthors: "with_more_authors",
  Automatic: "automatic",
  Default: "default",
} as const;

export type ComponentMetadata1DefaultSortOrderEnum =
  (typeof ComponentMetadata1DefaultSortOrderEnum)[keyof typeof ComponentMetadata1DefaultSortOrderEnum];
export const ComponentMetadata1ProposalEditTimeEnum = {
  Infinite: "infinite",
  Limited: "limited",
} as const;

export type ComponentMetadata1ProposalEditTimeEnum =
  (typeof ComponentMetadata1ProposalEditTimeEnum)[keyof typeof ComponentMetadata1ProposalEditTimeEnum];

/**
 *
 * @export
 * @interface ComponentRelationships
 */
export interface ComponentRelationships {
  /**
   *
   * @type {LinkedResources}
   * @memberof ComponentRelationships
   */
  resources?: LinkedResources;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComponentType = {
  PageComponent: "page_component",
  ProposalComponent: "proposal_component",
  MeetingComponent: "meeting_component",
  BudgetComponent: "budget_component",
  SurveyComponent: "survey_component",
  AccountabilityComponent: "accountability_component",
  DebateComponent: "debate_component",
  SortitionComponent: "sortition_component",
  BlogComponent: "blog_component",
  AwesomeMapComponent: "awesome_map_component",
  AwesomeIframeComponent: "awesome_iframe_component",
} as const;

export type ComponentType = (typeof ComponentType)[keyof typeof ComponentType];

/**
 *
 * @export
 * @interface CreateDraftProposalRequest
 */
export interface CreateDraftProposalRequest {
  /**
   *
   * @type {CreateDraftProposalRequestData}
   * @memberof CreateDraftProposalRequest
   */
  data: CreateDraftProposalRequestData;
}
/**
 * Payload to update in the proposal
 * @export
 * @interface CreateDraftProposalRequestData
 */
export interface CreateDraftProposalRequestData {
  /**
   * Component ID
   * @type {number}
   * @memberof CreateDraftProposalRequestData
   */
  component_id: number;
}
/**
 *
 * @export
 * @interface DraftProposal
 */
export interface DraftProposal {
  /**
   * Draft Proposal Id
   * @type {string}
   * @memberof DraftProposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DraftProposal
   */
  type: DraftProposalTypeEnum;
  /**
   *
   * @type {DraftProposalAttributes}
   * @memberof DraftProposal
   */
  attributes: DraftProposalAttributes;
  /**
   *
   * @type {DraftPropositionMetadata}
   * @memberof DraftProposal
   */
  meta: DraftPropositionMetadata;
  /**
   *
   * @type {ProposalLinks}
   * @memberof DraftProposal
   */
  links: ProposalLinks;
  /**
   *
   * @type {ProposalRelationships}
   * @memberof DraftProposal
   */
  relationships?: ProposalRelationships;
}

export const DraftProposalTypeEnum = {
  DraftProposal: "draft_proposal",
} as const;

export type DraftProposalTypeEnum =
  (typeof DraftProposalTypeEnum)[keyof typeof DraftProposalTypeEnum];

/**
 *
 * @export
 * @interface DraftProposalAttributes
 */
export interface DraftProposalAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  body: TranslatedProp;
  /**
   *
   * @type {DraftProposalAttributesErrors}
   * @memberof DraftProposalAttributes
   */
  errors?: DraftProposalAttributesErrors;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  updated_at: string;
}
/**
 * Draft current errors
 * @export
 * @interface DraftProposalAttributesErrors
 */
export interface DraftProposalAttributesErrors {
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalAttributesErrors
   */
  title: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalAttributesErrors
   */
  body: Array<string>;
}
/**
 *
 * @export
 * @interface DraftProposalIndexResponse
 */
export interface DraftProposalIndexResponse {
  /**
   *
   * @type {Array<DraftProposal>}
   * @memberof DraftProposalIndexResponse
   */
  data: Array<DraftProposal>;
}
/**
 *
 * @export
 * @interface DraftProposalItemResponse
 */
export interface DraftProposalItemResponse {
  /**
   *
   * @type {DraftProposal}
   * @memberof DraftProposalItemResponse
   */
  data: DraftProposal;
}
/**
 *
 * @export
 * @interface DraftPropositionMetadata
 */
export interface DraftPropositionMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Draft is published as it is now?
   * @type {boolean}
   * @memberof DraftPropositionMetadata
   */
  publishable: boolean;
  /**
   * Attached client_id
   * @type {string}
   * @memberof DraftPropositionMetadata
   */
  client_id: string;
  /**
   * Scope Id
   * @type {number}
   * @memberof DraftPropositionMetadata
   */
  scope?: number;
  /**
   * Editable field names
   * @type {Array<string>}
   * @memberof DraftPropositionMetadata
   */
  fields: Array<string>;
}
/**
 *
 * @export
 * @interface GenericComponent
 */
export interface GenericComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof GenericComponent
   */
  id?: string;
  /**
   *
   * @type {ComponentType}
   * @memberof GenericComponent
   */
  type?: ComponentType;
  /**
   *
   * @type {GenericComponentAttributes}
   * @memberof GenericComponent
   */
  attributes?: GenericComponentAttributes;
  /**
   *
   * @type {ComponentMetadata}
   * @memberof GenericComponent
   */
  meta?: ComponentMetadata;
  /**
   *
   * @type {ComponentLinks}
   * @memberof GenericComponent
   */
  links?: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof GenericComponent
   */
  relationships?: ComponentRelationships;
}

/**
 *
 * @export
 * @interface GenericComponentAttributes
 */
export interface GenericComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof GenericComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof GenericComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof GenericComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  updated_at: string;
}

/**
 *
 * @export
 * @interface GetActionLink
 */
export interface GetActionLink {
  /**
   * Action Name
   * @type {string}
   * @memberof GetActionLink
   */
  title: string;
  /**
   * Full URL
   * @type {string}
   * @memberof GetActionLink
   */
  href: string;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof GetActionLink
   */
  describedby?: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof GetActionLink
   */
  hreflang?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetActionLink
   */
  rel: GetActionLinkRelEnum;
  /**
   *
   * @type {MetaForReadRequest}
   * @memberof GetActionLink
   */
  meta: MetaForReadRequest;
}

export const GetActionLinkRelEnum = {
  Action: "action",
} as const;

export type GetActionLinkRelEnum =
  (typeof GetActionLinkRelEnum)[keyof typeof GetActionLinkRelEnum];

/**
 *
 * @export
 * @interface Health
 */
export interface Health {
  /**
   *
   * @type {string}
   * @memberof Health
   */
  message?: HealthMessageEnum;
}

export const HealthMessageEnum = {
  Ok: "OK",
  Error: "ERROR",
} as const;

export type HealthMessageEnum =
  (typeof HealthMessageEnum)[keyof typeof HealthMessageEnum];

/**
 *
 * @export
 * @interface IntrospectData
 */
export interface IntrospectData {
  /**
   * Access token id
   * @type {number}
   * @memberof IntrospectData
   */
  sub: number;
  /**
   * If the token can be used
   * @type {boolean}
   * @memberof IntrospectData
   */
  active: boolean;
  /**
   * Where this token can be used (organization host)
   * @type {string}
   * @memberof IntrospectData
   */
  aud: string;
  /**
   *
   * @type {ResourceDetails}
   * @memberof IntrospectData
   */
  resource?: ResourceDetails;
}
/**
 *
 * @export
 * @interface IntrospectTokenRequest
 */
export interface IntrospectTokenRequest {
  /**
   *
   * @type {string}
   * @memberof IntrospectTokenRequest
   */
  token: string;
}
/**
 *
 * @export
 * @interface LinkedAuthor
 */
export interface LinkedAuthor {
  /**
   *
   * @type {LinkedAuthorData}
   * @memberof LinkedAuthor
   */
  data: LinkedAuthorData;
}
/**
 *
 * @export
 * @interface LinkedAuthorData
 */
export interface LinkedAuthorData {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedAuthorData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedAuthorData
   */
  type: LinkedAuthorDataTypeEnum;
}

export const LinkedAuthorDataTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type LinkedAuthorDataTypeEnum =
  (typeof LinkedAuthorDataTypeEnum)[keyof typeof LinkedAuthorDataTypeEnum];

/**
 *
 * @export
 * @interface LinkedCoauthors
 */
export interface LinkedCoauthors {
  /**
   *
   * @type {Array<LinkedAuthorData>}
   * @memberof LinkedCoauthors
   */
  data: Array<LinkedAuthorData>;
}
/**
 *
 * @export
 * @interface LinkedComponent
 */
export interface LinkedComponent {
  /**
   *
   * @type {LinkedComponentData}
   * @memberof LinkedComponent
   */
  data: LinkedComponentData;
}
/**
 *
 * @export
 * @interface LinkedComponent1
 */
export interface LinkedComponent1 {
  /**
   *
   * @type {LinkedComponentsDataInner}
   * @memberof LinkedComponent1
   */
  data: LinkedComponentsDataInner;
}
/**
 *
 * @export
 * @interface LinkedComponent2
 */
export interface LinkedComponent2 {
  /**
   *
   * @type {LinkedComponent2Data}
   * @memberof LinkedComponent2
   */
  data: LinkedComponent2Data;
}
/**
 *
 * @export
 * @interface LinkedComponent2Data
 */
export interface LinkedComponent2Data {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedComponent2Data
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedComponent2Data
   */
  type: LinkedComponent2DataTypeEnum;
}

export const LinkedComponent2DataTypeEnum = {
  ProposalComponent: "proposal_component",
} as const;

export type LinkedComponent2DataTypeEnum =
  (typeof LinkedComponent2DataTypeEnum)[keyof typeof LinkedComponent2DataTypeEnum];

/**
 *
 * @export
 * @interface LinkedComponentData
 */
export interface LinkedComponentData {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedComponentData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedComponentData
   */
  type: LinkedComponentDataTypeEnum;
}

export const LinkedComponentDataTypeEnum = {
  BlogComponent: "blog_component",
} as const;

export type LinkedComponentDataTypeEnum =
  (typeof LinkedComponentDataTypeEnum)[keyof typeof LinkedComponentDataTypeEnum];

/**
 *
 * @export
 * @interface LinkedComponents
 */
export interface LinkedComponents {
  /**
   *
   * @type {Array<LinkedComponentsDataInner>}
   * @memberof LinkedComponents
   */
  data: Array<LinkedComponentsDataInner>;
  /**
   *
   * @type {AttachedComponentsMeta}
   * @memberof LinkedComponents
   */
  meta: AttachedComponentsMeta;
  /**
   *
   * @type {LinkedComponents}
   * @memberof LinkedComponents
   */
  links: LinkedComponents;
}
/**
 *
 * @export
 * @interface LinkedComponentsDataInner
 */
export interface LinkedComponentsDataInner {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedComponentsDataInner
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof LinkedComponentsDataInner
   */
  type: ComponentType;
}

/**
 *
 * @export
 * @interface LinkedResources
 */
export interface LinkedResources {
  /**
   *
   * @type {Array<LinkedResourcesDataInner>}
   * @memberof LinkedResources
   */
  data: Array<LinkedResourcesDataInner>;
  /**
   *
   * @type {LinkedResources}
   * @memberof LinkedResources
   */
  meta: LinkedResources;
}
/**
 *
 * @export
 * @interface LinkedResourcesDataInner
 */
export interface LinkedResourcesDataInner {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedResourcesDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedResourcesDataInner
   */
  type: string;
}
/**
 *
 * @export
 * @interface LinkedSpace
 */
export interface LinkedSpace {
  /**
   *
   * @type {LinkedSpaceData}
   * @memberof LinkedSpace
   */
  data: LinkedSpaceData;
}
/**
 *
 * @export
 * @interface LinkedSpace1
 */
export interface LinkedSpace1 {
  /**
   *
   * @type {LinkedSpace1Data}
   * @memberof LinkedSpace1
   */
  data: LinkedSpace1Data;
}
/**
 *
 * @export
 * @interface LinkedSpace1Data
 */
export interface LinkedSpace1Data {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedSpace1Data
   */
  id: string;
  /**
   *
   * @type {SpaceType}
   * @memberof LinkedSpace1Data
   */
  type: SpaceType;
}

/**
 *
 * @export
 * @interface LinkedSpaceData
 */
export interface LinkedSpaceData {
  /**
   * Resource Id
   * @type {string}
   * @memberof LinkedSpaceData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof LinkedSpaceData
   */
  type: LinkedSpaceDataTypeEnum;
}

export const LinkedSpaceDataTypeEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type LinkedSpaceDataTypeEnum =
  (typeof LinkedSpaceDataTypeEnum)[keyof typeof LinkedSpaceDataTypeEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const Locale = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type Locale = (typeof Locale)[keyof typeof Locale];

/**
 *
 * @export
 * @interface MagicLink
 */
export interface MagicLink {
  /**
   * Magic Token ID
   * @type {string}
   * @memberof MagicLink
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MagicLink
   */
  type: MagicLinkTypeEnum;
  /**
   *
   * @type {MagicLinkAttributes}
   * @memberof MagicLink
   */
  attributes: MagicLinkAttributes;
  /**
   *
   * @type {MagicLinkLinks}
   * @memberof MagicLink
   */
  links: MagicLinkLinks;
}

export const MagicLinkTypeEnum = {
  MagicLink: "magic_link",
} as const;

export type MagicLinkTypeEnum =
  (typeof MagicLinkTypeEnum)[keyof typeof MagicLinkTypeEnum];

/**
 *
 * @export
 * @interface MagicLinkAttributes
 */
export interface MagicLinkAttributes {
  /**
   * Magic Link Token
   * @type {string}
   * @memberof MagicLinkAttributes
   */
  token: string;
  /**
   * Magic Link description
   * @type {string}
   * @memberof MagicLinkAttributes
   */
  label: string;
}
/**
 *
 * @export
 * @interface MagicLinkAttributes1
 */
export interface MagicLinkAttributes1 {
  /**
   * Redirection destination
   * @type {string}
   * @memberof MagicLinkAttributes1
   */
  redirect_url: string;
  /**
   * Magic Link description
   * @type {string}
   * @memberof MagicLinkAttributes1
   */
  label: string;
}
/**
 *
 * @export
 * @interface MagicLinkIndexResponse
 */
export interface MagicLinkIndexResponse {
  /**
   *
   * @type {Array<MagicLink>}
   * @memberof MagicLinkIndexResponse
   */
  data: Array<MagicLink>;
}
/**
 *
 * @export
 * @interface MagicLinkItemResponse
 */
export interface MagicLinkItemResponse {
  /**
   *
   * @type {MagicLink}
   * @memberof MagicLinkItemResponse
   */
  data: MagicLink;
}
/**
 *
 * @export
 * @interface MagicLinkLinks
 */
export interface MagicLinkLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof MagicLinkLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof MagicLinkLinks
   */
  sign_in: ResourceLink;
}
/**
 *
 * @export
 * @interface MagicLinkLinks1
 */
export interface MagicLinkLinks1 {
  /**
   *
   * @type {GetActionLink}
   * @memberof MagicLinkLinks1
   */
  self: GetActionLink;
  /**
   *
   * @type {GetActionLink}
   * @memberof MagicLinkLinks1
   */
  magic_link: GetActionLink;
}
/**
 *
 * @export
 * @interface MagicLinkRedirect
 */
export interface MagicLinkRedirect {
  /**
   * Magic Token ID
   * @type {string}
   * @memberof MagicLinkRedirect
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MagicLinkRedirect
   */
  type: MagicLinkRedirectTypeEnum;
  /**
   *
   * @type {MagicLinkAttributes1}
   * @memberof MagicLinkRedirect
   */
  attributes: MagicLinkAttributes1;
  /**
   *
   * @type {MagicLinkLinks1}
   * @memberof MagicLinkRedirect
   */
  links: MagicLinkLinks1;
}

export const MagicLinkRedirectTypeEnum = {
  MagicLinkRedirect: "magic_link_redirect",
} as const;

export type MagicLinkRedirectTypeEnum =
  (typeof MagicLinkRedirectTypeEnum)[keyof typeof MagicLinkRedirectTypeEnum];

/**
 *
 * @export
 * @interface MagickLinkConfigurationPayload
 */
export interface MagickLinkConfigurationPayload {
  /**
   *
   * @type {MagickLinkConfigurationPayloadData}
   * @memberof MagickLinkConfigurationPayload
   */
  data?: MagickLinkConfigurationPayloadData;
}
/**
 * Optional payload to configure the magic link
 * @export
 * @interface MagickLinkConfigurationPayloadData
 */
export interface MagickLinkConfigurationPayloadData {
  /**
   * Redirect url after sign-in
   * @type {string}
   * @memberof MagickLinkConfigurationPayloadData
   */
  redirect_url: string;
}
/**
 *
 * @export
 * @interface MetaForReadRequest
 */
export interface MetaForReadRequest {
  /**
   * Component ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof MetaForReadRequest
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof MetaForReadRequest
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  resource_id?: string;
  /**
   * Action HTTP method
   * @type {string}
   * @memberof MetaForReadRequest
   */
  action_method: MetaForReadRequestActionMethodEnum;
}

export const MetaForReadRequestActionMethodEnum = {
  Get: "GET",
} as const;

export type MetaForReadRequestActionMethodEnum =
  (typeof MetaForReadRequestActionMethodEnum)[keyof typeof MetaForReadRequestActionMethodEnum];

/**
 *
 * @export
 * @interface MetaForWriteRequest
 */
export interface MetaForWriteRequest {
  /**
   * Component ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  resource_id?: string;
  /**
   * Action HTTP method
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_method: MetaForWriteRequestActionMethodEnum;
  /**
   * Encoding of the payload
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_enctype: MetaForWriteRequestActionEnctypeEnum;
  /**
   * URL to goes after submitting a valid request
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_target?: string;
}

export const MetaForWriteRequestActionMethodEnum = {
  Post: "POST",
  Delete: "DELETE",
  Put: "PUT",
} as const;

export type MetaForWriteRequestActionMethodEnum =
  (typeof MetaForWriteRequestActionMethodEnum)[keyof typeof MetaForWriteRequestActionMethodEnum];
export const MetaForWriteRequestActionEnctypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  MultipartFormData: "multipart/form-data",
} as const;

export type MetaForWriteRequestActionEnctypeEnum =
  (typeof MetaForWriteRequestActionEnctypeEnum)[keyof typeof MetaForWriteRequestActionEnctypeEnum];

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Error title, starting with HTTP Code, like 400: bad request
   * @type {string}
   * @memberof ModelError
   */
  error: string;
  /**
   * Error detail, mostly validation error
   * @type {string}
   * @memberof ModelError
   */
  error_description: string;
  /**
   * authentification state
   * @type {string}
   * @memberof ModelError
   */
  state?: string;
}
/**
 * @type OauthGrantParam
 * @export
 */
export type OauthGrantParam =
  | ClientCredential
  | PasswordGrantImpersonate
  | PasswordGrantLogin;

/**
 *
 * @export
 * @interface Organization
 */
export interface Organization {
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  type: OrganizationTypeEnum;
  /**
   *
   * @type {OrganizationAttributes}
   * @memberof Organization
   */
  attributes: OrganizationAttributes;
  /**
   *
   * @type {OrganizationMeta}
   * @memberof Organization
   */
  meta: OrganizationMeta;
}

export const OrganizationTypeEnum = {
  Organization: "organization",
} as const;

export type OrganizationTypeEnum =
  (typeof OrganizationTypeEnum)[keyof typeof OrganizationTypeEnum];

/**
 *
 * @export
 * @interface OrganizationAttributes
 */
export interface OrganizationAttributes {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof OrganizationAttributes
   */
  name: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof OrganizationAttributes
   */
  host: string;
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationAttributes
   */
  available_locales: Array<OrganizationAttributesAvailableLocalesEnum>;
  /**
   * defaut locale for the organization
   * @type {string}
   * @memberof OrganizationAttributes
   */
  default_locale: string;
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationAttributes
   */
  secondary_hosts?: Array<string>;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  updated_at: string;
}

export const OrganizationAttributesAvailableLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type OrganizationAttributesAvailableLocalesEnum =
  (typeof OrganizationAttributesAvailableLocalesEnum)[keyof typeof OrganizationAttributesAvailableLocalesEnum];

/**
 *
 * @export
 * @interface OrganizationIndexResponse
 */
export interface OrganizationIndexResponse {
  /**
   *
   * @type {Array<Organization>}
   * @memberof OrganizationIndexResponse
   */
  data: Array<Organization>;
}
/**
 *
 * @export
 * @interface OrganizationItemResponse
 */
export interface OrganizationItemResponse {
  /**
   *
   * @type {Organization}
   * @memberof OrganizationItemResponse
   */
  data: Organization;
}
/**
 *
 * @export
 * @interface OrganizationMeta
 */
export interface OrganizationMeta {
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationMeta
   */
  locales: Array<OrganizationMetaLocalesEnum>;
}

export const OrganizationMetaLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type OrganizationMetaLocalesEnum =
  (typeof OrganizationMetaLocalesEnum)[keyof typeof OrganizationMetaLocalesEnum];

/**
 *
 * @export
 * @interface OtherComponent
 */
export interface OtherComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof OtherComponent
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof OtherComponent
   */
  type?: OtherComponentTypeEnum;
  /**
   *
   * @type {OtherComponentAttributes}
   * @memberof OtherComponent
   */
  attributes?: OtherComponentAttributes;
  /**
   *
   * @type {ComponentMetadata}
   * @memberof OtherComponent
   */
  meta?: ComponentMetadata;
  /**
   *
   * @type {ComponentLinks}
   * @memberof OtherComponent
   */
  links?: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof OtherComponent
   */
  relationships?: ComponentRelationships;
}

export const OtherComponentTypeEnum = {
  PageComponent: "page_component",
  MeetingComponent: "meeting_component",
  BudgetComponent: "budget_component",
  SurveyComponent: "survey_component",
  AccountabilityComponent: "accountability_component",
  DebateComponent: "debate_component",
  SortitionComponent: "sortition_component",
  AwesomeMapComponent: "awesome_map_component",
  AwesomeIframeComponent: "awesome_iframe_component",
} as const;

export type OtherComponentTypeEnum =
  (typeof OtherComponentTypeEnum)[keyof typeof OtherComponentTypeEnum];

/**
 *
 * @export
 * @interface OtherComponentAttributes
 */
export interface OtherComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof OtherComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof OtherComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof OtherComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof OtherComponentAttributes
   */
  manifest_name: OtherComponentAttributesManifestNameEnum;
}

export const OtherComponentAttributesManifestNameEnum = {
  Pages: "pages",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type OtherComponentAttributesManifestNameEnum =
  (typeof OtherComponentAttributesManifestNameEnum)[keyof typeof OtherComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface PasswordGrantImpersonate
 */
export interface PasswordGrantImpersonate {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user impersonation**
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  grant_type: PasswordGrantImpersonateGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  auth_type: PasswordGrantImpersonateAuthTypeEnum;
  /**
   * User nickname, unique and at least 6 alphanumeric chars.
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  username?: string;
  /**
   * User id, will find over id and ignore username. Fails if register_on_missing=true.
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  id?: string;
  /**
   *
   * @type {UserImpersonationSettings}
   * @memberof PasswordGrantImpersonate
   */
  meta?: UserImpersonationSettings;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof PasswordGrantImpersonate
   */
  scope: PasswordGrantImpersonateScopeEnum;
}

export const PasswordGrantImpersonateGrantTypeEnum = {
  Password: "password",
} as const;

export type PasswordGrantImpersonateGrantTypeEnum =
  (typeof PasswordGrantImpersonateGrantTypeEnum)[keyof typeof PasswordGrantImpersonateGrantTypeEnum];
export const PasswordGrantImpersonateAuthTypeEnum = {
  Impersonate: "impersonate",
} as const;

export type PasswordGrantImpersonateAuthTypeEnum =
  (typeof PasswordGrantImpersonateAuthTypeEnum)[keyof typeof PasswordGrantImpersonateAuthTypeEnum];
export const PasswordGrantImpersonateScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type PasswordGrantImpersonateScopeEnum =
  (typeof PasswordGrantImpersonateScopeEnum)[keyof typeof PasswordGrantImpersonateScopeEnum];

/**
 *
 * @export
 * @interface PasswordGrantLogin
 */
export interface PasswordGrantLogin {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user login**
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  grant_type: PasswordGrantLoginGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  auth_type: PasswordGrantLoginAuthTypeEnum;
  /**
   * User nickname
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  username: string;
  /**
   * User password
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  password: string;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof PasswordGrantLogin
   */
  scope: PasswordGrantLoginScopeEnum;
}

export const PasswordGrantLoginGrantTypeEnum = {
  Password: "password",
} as const;

export type PasswordGrantLoginGrantTypeEnum =
  (typeof PasswordGrantLoginGrantTypeEnum)[keyof typeof PasswordGrantLoginGrantTypeEnum];
export const PasswordGrantLoginAuthTypeEnum = {
  Login: "login",
} as const;

export type PasswordGrantLoginAuthTypeEnum =
  (typeof PasswordGrantLoginAuthTypeEnum)[keyof typeof PasswordGrantLoginAuthTypeEnum];
export const PasswordGrantLoginScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type PasswordGrantLoginScopeEnum =
  (typeof PasswordGrantLoginScopeEnum)[keyof typeof PasswordGrantLoginScopeEnum];

/**
 * @type PasswordGrantParam
 * @export
 */
export type PasswordGrantParam = PasswordGrantImpersonate | PasswordGrantLogin;

/**
 *
 * @export
 * @interface PostActionLink
 */
export interface PostActionLink {
  /**
   * Action Name
   * @type {string}
   * @memberof PostActionLink
   */
  title: string;
  /**
   * Full URL
   * @type {string}
   * @memberof PostActionLink
   */
  href: string;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof PostActionLink
   */
  describedby?: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof PostActionLink
   */
  hreflang?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof PostActionLink
   */
  rel: PostActionLinkRelEnum;
  /**
   *
   * @type {MetaForWriteRequest}
   * @memberof PostActionLink
   */
  meta: MetaForWriteRequest;
}

export const PostActionLinkRelEnum = {
  Action: "action",
} as const;

export type PostActionLinkRelEnum =
  (typeof PostActionLinkRelEnum)[keyof typeof PostActionLinkRelEnum];

/**
 *
 * @export
 * @interface Proposal
 */
export interface Proposal {
  /**
   * Proposal Id
   * @type {string}
   * @memberof Proposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Proposal
   */
  type: ProposalTypeEnum;
  /**
   *
   * @type {BlogAttributes}
   * @memberof Proposal
   */
  attributes: BlogAttributes;
  /**
   *
   * @type {PropositionMetadata}
   * @memberof Proposal
   */
  meta: PropositionMetadata;
  /**
   *
   * @type {ProposalLinks1}
   * @memberof Proposal
   */
  links: ProposalLinks1;
  /**
   *
   * @type {ProposalRelationships1}
   * @memberof Proposal
   */
  relationships?: ProposalRelationships1;
}

export const ProposalTypeEnum = {
  Proposal: "proposal",
} as const;

export type ProposalTypeEnum =
  (typeof ProposalTypeEnum)[keyof typeof ProposalTypeEnum];

/**
 *
 * @export
 * @interface ProposalAuthor
 */
export interface ProposalAuthor {
  /**
   *
   * @type {LinkedAuthorData}
   * @memberof ProposalAuthor
   */
  data: LinkedAuthorData;
}
/**
 *
 * @export
 * @interface ProposalCoauthors
 */
export interface ProposalCoauthors {
  /**
   *
   * @type {Array<LinkedAuthorData>}
   * @memberof ProposalCoauthors
   */
  data: Array<LinkedAuthorData>;
}
/**
 * A proposal component can host proposals from participants, and official proposals (proposals from the organization). This component have many metadatas that explain what are the restrictions regarding proposing, voting, commenting, amending or endorsing.   Features toggles:  - `can_create_proposals`: If participants can create proposals - `can_vote`: If participants can vote - `can_comment`: If participants can comments - .... and some more
 * @export
 * @interface ProposalComponent
 */
export interface ProposalComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof ProposalComponent
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ProposalComponent
   */
  type?: ProposalComponentTypeEnum;
  /**
   *
   * @type {ProposalComponentAttributes}
   * @memberof ProposalComponent
   */
  attributes?: ProposalComponentAttributes;
  /**
   *
   * @type {ComponentMetadata1}
   * @memberof ProposalComponent
   */
  meta?: ComponentMetadata1;
  /**
   *
   * @type {ComponentLinks1}
   * @memberof ProposalComponent
   */
  links?: ComponentLinks1;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof ProposalComponent
   */
  relationships?: ComponentRelationships;
}

export const ProposalComponentTypeEnum = {
  ProposalComponent: "proposal_component",
} as const;

export type ProposalComponentTypeEnum =
  (typeof ProposalComponentTypeEnum)[keyof typeof ProposalComponentTypeEnum];

/**
 *
 * @export
 * @interface ProposalComponentAttributes
 */
export interface ProposalComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   *
   * @type {SpaceClasses}
   * @memberof ProposalComponentAttributes
   */
  participatory_space_type: SpaceClasses;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  manifest_name: ProposalComponentAttributesManifestNameEnum;
}

export const ProposalComponentAttributesManifestNameEnum = {
  Proposals: "proposals",
} as const;

export type ProposalComponentAttributesManifestNameEnum =
  (typeof ProposalComponentAttributesManifestNameEnum)[keyof typeof ProposalComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface ProposalComponentIndexResponse
 */
export interface ProposalComponentIndexResponse {
  /**
   *
   * @type {Array<ProposalComponent>}
   * @memberof ProposalComponentIndexResponse
   */
  data: Array<ProposalComponent>;
}
/**
 *
 * @export
 * @interface ProposalComponentItemResponse
 */
export interface ProposalComponentItemResponse {
  /**
   *
   * @type {ProposalComponent}
   * @memberof ProposalComponentItemResponse
   */
  data: ProposalComponent;
}
/**
 *
 * @export
 * @interface ProposalIndexResponse
 */
export interface ProposalIndexResponse {
  /**
   *
   * @type {Array<Proposal>}
   * @memberof ProposalIndexResponse
   */
  data: Array<Proposal>;
}
/**
 *
 * @export
 * @interface ProposalItemResponse
 */
export interface ProposalItemResponse {
  /**
   *
   * @type {Proposal}
   * @memberof ProposalItemResponse
   */
  data: Proposal;
}
/**
 *
 * @export
 * @interface ProposalLinks
 */
export interface ProposalLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks
   */
  collection: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks
   */
  related: ResourceLink;
}
/**
 *
 * @export
 * @interface ProposalLinks1
 */
export interface ProposalLinks1 {
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  collection: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  related: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  prev?: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof ProposalLinks1
   */
  next?: ResourceLink;
}
/**
 *
 * @export
 * @interface ProposalRelationships
 */
export interface ProposalRelationships {
  /**
   *
   * @type {LinkedSpace1}
   * @memberof ProposalRelationships
   */
  space: LinkedSpace1;
  /**
   *
   * @type {LinkedComponent1}
   * @memberof ProposalRelationships
   */
  component: LinkedComponent1;
  /**
   *
   * @type {LinkedAuthor}
   * @memberof ProposalRelationships
   */
  author?: LinkedAuthor;
  /**
   *
   * @type {LinkedCoauthors}
   * @memberof ProposalRelationships
   */
  coauthors?: LinkedCoauthors;
}
/**
 *
 * @export
 * @interface ProposalRelationships1
 */
export interface ProposalRelationships1 {
  /**
   *
   * @type {ProposalState}
   * @memberof ProposalRelationships1
   */
  state?: ProposalState;
  /**
   *
   * @type {LinkedSpace1}
   * @memberof ProposalRelationships1
   */
  space: LinkedSpace1;
  /**
   *
   * @type {LinkedComponent2}
   * @memberof ProposalRelationships1
   */
  component: LinkedComponent2;
  /**
   *
   * @type {ProposalAuthor}
   * @memberof ProposalRelationships1
   */
  author?: ProposalAuthor;
  /**
   *
   * @type {ProposalCoauthors}
   * @memberof ProposalRelationships1
   */
  coauthors?: ProposalCoauthors;
}
/**
 *
 * @export
 * @interface ProposalState
 */
export interface ProposalState {
  /**
   *
   * @type {ProposalStateData}
   * @memberof ProposalState
   */
  data: ProposalStateData;
  /**
   *
   * @type {ProposalStateMeta}
   * @memberof ProposalState
   */
  meta: ProposalStateMeta;
}
/**
 *
 * @export
 * @interface ProposalStateData
 */
export interface ProposalStateData {
  /**
   * Resource Id
   * @type {string}
   * @memberof ProposalStateData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ProposalStateData
   */
  type: ProposalStateDataTypeEnum;
}

export const ProposalStateDataTypeEnum = {
  ProposalState: "proposal_state",
} as const;

export type ProposalStateDataTypeEnum =
  (typeof ProposalStateDataTypeEnum)[keyof typeof ProposalStateDataTypeEnum];

/**
 *
 * @export
 * @interface ProposalStateMeta
 */
export interface ProposalStateMeta {
  /**
   * Proposal State token
   * @type {string}
   * @memberof ProposalStateMeta
   */
  token: string;
}
/**
 *
 * @export
 * @interface PropositionMetadata
 */
export interface PropositionMetadata {
  [key: string]: BlogPostMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof PropositionMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof PropositionMetadata
   */
  scope?: number;
  /**
   *
   * @type {PropositionMetadataVoted}
   * @memberof PropositionMetadata
   */
  voted?: PropositionMetadataVoted | null;
}
/**
 *
 * @export
 * @interface PropositionMetadataVoted
 */
export interface PropositionMetadataVoted {
  /**
   * Vote weight
   * @type {number}
   * @memberof PropositionMetadataVoted
   */
  weight: number;
}
/**
 *
 * @export
 * @interface ResourceDetails
 */
export interface ResourceDetails {
  /**
   * resource id
   * @type {string}
   * @memberof ResourceDetails
   */
  id: string;
  /**
   * resource type
   * @type {string}
   * @memberof ResourceDetails
   */
  type: ResourceDetailsTypeEnum;
  /**
   *
   * @type {ResourceDetailsAttributes}
   * @memberof ResourceDetails
   */
  attributes?: ResourceDetailsAttributes;
}

export const ResourceDetailsTypeEnum = {
  User: "user",
} as const;

export type ResourceDetailsTypeEnum =
  (typeof ResourceDetailsTypeEnum)[keyof typeof ResourceDetailsTypeEnum];

/**
 *
 * @export
 * @interface ResourceDetailsAttributes
 */
export interface ResourceDetailsAttributes {
  /**
   * Email
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  email: string;
  /**
   * Last update date
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  updated_at: string;
  /**
   * Creation date
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  created_at: string;
  /**
   * Personal url (social link, website, etc.)
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  personal_url?: string;
  /**
   * Current prefered locale
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  locale?: ResourceDetailsAttributesLocaleEnum;
}

export const ResourceDetailsAttributesLocaleEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type ResourceDetailsAttributesLocaleEnum =
  (typeof ResourceDetailsAttributesLocaleEnum)[keyof typeof ResourceDetailsAttributesLocaleEnum];

/**
 *
 * @export
 * @interface ResourceLink
 */
export interface ResourceLink {
  /**
   * Full URL
   * @type {string}
   * @memberof ResourceLink
   */
  href: string;
  /**
   * Page Title
   * @type {string}
   * @memberof ResourceLink
   */
  title: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof ResourceLink
   */
  hreflang?: Array<string>;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof ResourceLink
   */
  describedby?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceLink
   */
  rel: ResourceLinkRelEnum;
  /**
   *
   * @type {ResourceLinkMeta}
   * @memberof ResourceLink
   */
  meta: ResourceLinkMeta;
}

export const ResourceLinkRelEnum = {
  PublicPage: "public_page",
  Resource: "resource",
} as const;

export type ResourceLinkRelEnum =
  (typeof ResourceLinkRelEnum)[keyof typeof ResourceLinkRelEnum];

/**
 *
 * @export
 * @interface ResourceLinkMeta
 */
export interface ResourceLinkMeta {
  /**
   * Component ID
   * @type {string}
   * @memberof ResourceLinkMeta
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof ResourceLinkMeta
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof ResourceLinkMeta
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof ResourceLinkMeta
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof ResourceLinkMeta
   */
  resource_id?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ResourceManifest = {
  Page: "page",
  Proposal: "proposal",
  Meeting: "meeting",
  Budget: "budget",
  Survey: "survey",
  Accountability: "accountability",
  Debate: "debate",
  Sortition: "sortition",
  Blog: "blog",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type ResourceManifest =
  (typeof ResourceManifest)[keyof typeof ResourceManifest];

/**
 *
 * @export
 * @interface SetUserDataRequest
 */
export interface SetUserDataRequest {
  /**
   * New value for the extended data at the given path
   * @type {object}
   * @memberof SetUserDataRequest
   */
  data: object;
  /**
   * object path, in dot style, like foo.bar. use \'.\' to update the whole user data
   * @type {string}
   * @memberof SetUserDataRequest
   */
  object_path?: string;
}
/**
 *
 * @export
 * @interface Space
 */
export interface Space {
  /**
   * Space Id
   * @type {string}
   * @memberof Space
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Space
   */
  type: SpaceTypeEnum;
  /**
   *
   * @type {SpaceAttributes}
   * @memberof Space
   */
  attributes: SpaceAttributes;
  /**
   *
   * @type {SpaceRelationships}
   * @memberof Space
   */
  relationships: SpaceRelationships;
  /**
   *
   * @type {SpaceLinks}
   * @memberof Space
   */
  links: SpaceLinks;
}

export const SpaceTypeEnum = {
  Space: "space",
} as const;

export type SpaceTypeEnum = (typeof SpaceTypeEnum)[keyof typeof SpaceTypeEnum];

/**
 *
 * @export
 * @interface SpaceAttributes
 */
export interface SpaceAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  subtitle?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  short_description?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  description?: TranslatedProp;
  /**
   *
   * @type {SpaceManifest}
   * @memberof SpaceAttributes
   */
  manifest_name: SpaceManifest;
  /**
   *
   * @type {string}
   * @memberof SpaceAttributes
   */
  participatory_space_type?: string;
  /**
   * Space visibility
   * @type {string}
   * @memberof SpaceAttributes
   */
  visibility: SpaceAttributesVisibilityEnum;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  updated_at: string;
}

export const SpaceAttributesVisibilityEnum = {
  Public: "public",
  Transparent: "transparent",
  Private: "private",
} as const;

export type SpaceAttributesVisibilityEnum =
  (typeof SpaceAttributesVisibilityEnum)[keyof typeof SpaceAttributesVisibilityEnum];

/**
 * space class name. Part of the polymorphic association (participatory_space_type,participatory_space_id)
 * @export
 * @enum {string}
 */

export const SpaceClasses = {
  ParticipatoryProcess: "Decidim::ParticipatoryProcess",
  Assembly: "Decidim::Assembly",
} as const;

export type SpaceClasses = (typeof SpaceClasses)[keyof typeof SpaceClasses];

/**
 *
 * @export
 * @interface SpaceIndexResponse
 */
export interface SpaceIndexResponse {
  /**
   *
   * @type {Array<Space>}
   * @memberof SpaceIndexResponse
   */
  data: Array<Space>;
}
/**
 *
 * @export
 * @interface SpaceItemResponse
 */
export interface SpaceItemResponse {
  /**
   *
   * @type {Space}
   * @memberof SpaceItemResponse
   */
  data: Space;
}
/**
 *
 * @export
 * @interface SpaceLinks
 */
export interface SpaceLinks {
  /**
   *
   * @type {ResourceLink}
   * @memberof SpaceLinks
   */
  self: ResourceLink;
  /**
   *
   * @type {ResourceLink}
   * @memberof SpaceLinks
   */
  related: ResourceLink;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SpaceManifest = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceManifest = (typeof SpaceManifest)[keyof typeof SpaceManifest];

/**
 *
 * @export
 * @interface SpaceRelationships
 */
export interface SpaceRelationships {
  /**
   *
   * @type {LinkedComponents}
   * @memberof SpaceRelationships
   */
  components?: LinkedComponents;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SpaceType = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceType = (typeof SpaceType)[keyof typeof SpaceType];

/**
 * Hash with translated data, key=locale value=translation
 * @export
 * @interface TranslatedProp
 */
export interface TranslatedProp {
  /**
   * Translation in en
   * @type {string}
   * @memberof TranslatedProp
   */
  en?: string;
  /**
   * Translation in bg
   * @type {string}
   * @memberof TranslatedProp
   */
  bg?: string;
  /**
   * Translation in ar
   * @type {string}
   * @memberof TranslatedProp
   */
  ar?: string;
  /**
   * Translation in ca
   * @type {string}
   * @memberof TranslatedProp
   */
  ca?: string;
  /**
   * Translation in cs
   * @type {string}
   * @memberof TranslatedProp
   */
  cs?: string;
  /**
   * Translation in da
   * @type {string}
   * @memberof TranslatedProp
   */
  da?: string;
  /**
   * Translation in de
   * @type {string}
   * @memberof TranslatedProp
   */
  de?: string;
  /**
   * Translation in el
   * @type {string}
   * @memberof TranslatedProp
   */
  el?: string;
  /**
   * Translation in eo
   * @type {string}
   * @memberof TranslatedProp
   */
  eo?: string;
  /**
   * Translation in es
   * @type {string}
   * @memberof TranslatedProp
   */
  es?: string;
  /**
   * Translation in es-MX
   * @type {string}
   * @memberof TranslatedProp
   */
  "es-MX"?: string;
  /**
   * Translation in es-PY
   * @type {string}
   * @memberof TranslatedProp
   */
  "es-PY"?: string;
  /**
   * Translation in et
   * @type {string}
   * @memberof TranslatedProp
   */
  et?: string;
  /**
   * Translation in eu
   * @type {string}
   * @memberof TranslatedProp
   */
  eu?: string;
  /**
   * Translation in fa
   * @type {string}
   * @memberof TranslatedProp
   */
  fa?: string;
  /**
   * Translation in fi-pl
   * @type {string}
   * @memberof TranslatedProp
   */
  "fi-pl"?: string;
  /**
   * Translation in fi
   * @type {string}
   * @memberof TranslatedProp
   */
  fi?: string;
  /**
   * Translation in fr
   * @type {string}
   * @memberof TranslatedProp
   */
  fr?: string;
  /**
   * Translation in fr-CA
   * @type {string}
   * @memberof TranslatedProp
   */
  "fr-CA"?: string;
  /**
   * Translation in ga
   * @type {string}
   * @memberof TranslatedProp
   */
  ga?: string;
  /**
   * Translation in gl
   * @type {string}
   * @memberof TranslatedProp
   */
  gl?: string;
  /**
   * Translation in hr
   * @type {string}
   * @memberof TranslatedProp
   */
  hr?: string;
  /**
   * Translation in hu
   * @type {string}
   * @memberof TranslatedProp
   */
  hu?: string;
  /**
   * Translation in id
   * @type {string}
   * @memberof TranslatedProp
   */
  id?: string;
  /**
   * Translation in is
   * @type {string}
   * @memberof TranslatedProp
   */
  is?: string;
  /**
   * Translation in it
   * @type {string}
   * @memberof TranslatedProp
   */
  it?: string;
  /**
   * Translation in ja
   * @type {string}
   * @memberof TranslatedProp
   */
  ja?: string;
  /**
   * Translation in ko
   * @type {string}
   * @memberof TranslatedProp
   */
  ko?: string;
  /**
   * Translation in lb
   * @type {string}
   * @memberof TranslatedProp
   */
  lb?: string;
  /**
   * Translation in lt
   * @type {string}
   * @memberof TranslatedProp
   */
  lt?: string;
  /**
   * Translation in lv
   * @type {string}
   * @memberof TranslatedProp
   */
  lv?: string;
  /**
   * Translation in mt
   * @type {string}
   * @memberof TranslatedProp
   */
  mt?: string;
  /**
   * Translation in nl
   * @type {string}
   * @memberof TranslatedProp
   */
  nl?: string;
  /**
   * Translation in no
   * @type {string}
   * @memberof TranslatedProp
   */
  no?: string;
  /**
   * Translation in pl
   * @type {string}
   * @memberof TranslatedProp
   */
  pl?: string;
  /**
   * Translation in pt
   * @type {string}
   * @memberof TranslatedProp
   */
  pt?: string;
  /**
   * Translation in pt-BR
   * @type {string}
   * @memberof TranslatedProp
   */
  "pt-BR"?: string;
  /**
   * Translation in ro
   * @type {string}
   * @memberof TranslatedProp
   */
  ro?: string;
  /**
   * Translation in ru
   * @type {string}
   * @memberof TranslatedProp
   */
  ru?: string;
  /**
   * Translation in sk
   * @type {string}
   * @memberof TranslatedProp
   */
  sk?: string;
  /**
   * Translation in sl
   * @type {string}
   * @memberof TranslatedProp
   */
  sl?: string;
  /**
   * Translation in sr
   * @type {string}
   * @memberof TranslatedProp
   */
  sr?: string;
  /**
   * Translation in sv
   * @type {string}
   * @memberof TranslatedProp
   */
  sv?: string;
  /**
   * Translation in tr
   * @type {string}
   * @memberof TranslatedProp
   */
  tr?: string;
  /**
   * Translation in uk
   * @type {string}
   * @memberof TranslatedProp
   */
  uk?: string;
  /**
   * Translation in vi
   * @type {string}
   * @memberof TranslatedProp
   */
  vi?: string;
  /**
   * Translation in zh-CN
   * @type {string}
   * @memberof TranslatedProp
   */
  "zh-CN"?: string;
  /**
   * Translation in zh-TW
   * @type {string}
   * @memberof TranslatedProp
   */
  "zh-TW"?: string;
}
/**
 *
 * @export
 * @interface UpdateDraftProposalRequest
 */
export interface UpdateDraftProposalRequest {
  /**
   *
   * @type {UpdateDraftProposalRequestData}
   * @memberof UpdateDraftProposalRequest
   */
  data: UpdateDraftProposalRequestData;
}
/**
 * Payload to update in the proposal
 * @export
 * @interface UpdateDraftProposalRequestData
 */
export interface UpdateDraftProposalRequestData {
  /**
   * Title of the draft
   * @type {string}
   * @memberof UpdateDraftProposalRequestData
   */
  title?: string;
  /**
   * Content of the draft
   * @type {string}
   * @memberof UpdateDraftProposalRequestData
   */
  body?: string;
  /**
   * Locale of the draft. default to user locale
   * @type {string}
   * @memberof UpdateDraftProposalRequestData
   */
  locale?: UpdateDraftProposalRequestDataLocaleEnum;
}

export const UpdateDraftProposalRequestDataLocaleEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type UpdateDraftProposalRequestDataLocaleEnum =
  (typeof UpdateDraftProposalRequestDataLocaleEnum)[keyof typeof UpdateDraftProposalRequestDataLocaleEnum];

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  type: UserTypeEnum;
  /**
   *
   * @type {UserMeta}
   * @memberof User
   */
  meta?: UserMeta;
  /**
   *
   * @type {UserRelationships}
   * @memberof User
   */
  relationships?: UserRelationships;
  /**
   *
   * @type {UserAttributes}
   * @memberof User
   */
  attributes: UserAttributes;
}

export const UserTypeEnum = {
  User: "user",
} as const;

export type UserTypeEnum = (typeof UserTypeEnum)[keyof typeof UserTypeEnum];

/**
 *
 * @export
 * @interface UserAttributes
 */
export interface UserAttributes {
  /**
   * User name, use to display the Profile identity. Public
   * @type {string}
   * @memberof UserAttributes
   */
  name: string;
  /**
   * User nickname, unique identifier for the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  nickname: string;
  /**
   * Personal website URL or social link. Public
   * @type {string}
   * @memberof UserAttributes
   */
  personal_url?: string;
  /**
   * Short bio of the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  about?: string;
  /**
   *
   * @type {Locale}
   * @memberof UserAttributes
   */
  locale: Locale;
  /**
   * Email of the user. Private
   * @type {string}
   * @memberof UserAttributes
   */
  email?: string;
  /**
   * Additional data. Private
   * @type {{ [key: string]: any; }}
   * @memberof UserAttributes
   */
  extended_data: { [key: string]: any };
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  updated_at: string;
}

/**
 * Impersonation Settings
 * @export
 * @interface UserImpersonationSettings
 */
export interface UserImpersonationSettings {
  /**
   * Register the user if it does not exists. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  register_on_missing?: boolean;
  /**
   * Accept the TOS on registration, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  accept_tos_on_register?: boolean;
  /**
   * Skip email confirmation on creation, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  skip_confirmation_on_register?: boolean;
  /**
   * User email to use on registration. used only if register_on_missing=true. Default to <username>@example.org
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  email?: string;
  /**
   * User name. Used only if register_on_missing=true. Default to username
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  name?: string;
}
/**
 *
 * @export
 * @interface UserIndexResponse
 */
export interface UserIndexResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof UserIndexResponse
   */
  data: Array<User>;
}
/**
 *
 * @export
 * @interface UserItemResponse
 */
export interface UserItemResponse {
  /**
   *
   * @type {User}
   * @memberof UserItemResponse
   */
  data: User;
}
/**
 *
 * @export
 * @interface UserMeta
 */
export interface UserMeta {
  /**
   * If the user is blocked, and need to be unblocked to signin
   * @type {boolean}
   * @memberof UserMeta
   */
  blocked: boolean;
  /**
   * If the user is locked, and need to click on the mail link to unlock
   * @type {boolean}
   * @memberof UserMeta
   */
  locked: boolean;
}
/**
 *
 * @export
 * @interface UserRelationships
 */
export interface UserRelationships {
  /**
   *
   * @type {UserRelationshipsRoles}
   * @memberof UserRelationships
   */
  roles?: UserRelationshipsRoles;
}
/**
 *
 * @export
 * @interface UserRelationshipsRoles
 */
export interface UserRelationshipsRoles {
  /**
   *
   * @type {Array<UserRelationshipsRolesDataInner>}
   * @memberof UserRelationshipsRoles
   */
  data: Array<UserRelationshipsRolesDataInner>;
}
/**
 *
 * @export
 * @interface UserRelationshipsRolesDataInner
 */
export interface UserRelationshipsRolesDataInner {
  /**
   *
   * @type {string}
   * @memberof UserRelationshipsRolesDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UserRelationshipsRolesDataInner
   */
  type: UserRelationshipsRolesDataInnerTypeEnum;
}

export const UserRelationshipsRolesDataInnerTypeEnum = {
  UserRole: "user_role",
} as const;

export type UserRelationshipsRolesDataInnerTypeEnum =
  (typeof UserRelationshipsRolesDataInnerTypeEnum)[keyof typeof UserRelationshipsRolesDataInnerTypeEnum];

/**
 *
 * @export
 * @interface VoteProposalRequest
 */
export interface VoteProposalRequest {
  /**
   * Proposal Id
   * @type {number}
   * @memberof VoteProposalRequest
   */
  proposal_id: number;
  /**
   *
   * @type {VoteProposalRequestData}
   * @memberof VoteProposalRequest
   */
  data: VoteProposalRequestData;
}
/**
 * Payload to send your vote
 * @export
 * @interface VoteProposalRequestData
 */
export interface VoteProposalRequestData {
  /**
   * Weight for your vote
   * @type {number}
   * @memberof VoteProposalRequestData
   */
  weight: number;
}

/**
 * BlogsApi - axios parameter creator
 * @export
 */
export const BlogsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {number} id
     * @param {Array<BlogLocalesEnum>} [locales]
     * @param {number} [componentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog: async (
      id: number,
      locales?: Array<BlogLocalesEnum>,
      componentId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("blog", "id", id);
      const localVarPath = `/blogs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get blog post list
     * @summary Blog Post Lists
     * @param {Array<BlogsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {BlogsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs: async (
      locales?: Array<BlogsLocalesEnum>,
      page?: number,
      perPage?: number,
      spaceManifest?: BlogsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/blogs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BlogsApi - functional programming interface
 * @export
 */
export const BlogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BlogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {number} id
     * @param {Array<BlogLocalesEnum>} [locales]
     * @param {number} [componentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blog(
      id: number,
      locales?: Array<BlogLocalesEnum>,
      componentId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blog(
        id,
        locales,
        componentId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blog"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get blog post list
     * @summary Blog Post Lists
     * @param {Array<BlogsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {BlogsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogs(
      locales?: Array<BlogsLocalesEnum>,
      page?: number,
      perPage?: number,
      spaceManifest?: BlogsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogs(
        locales,
        page,
        perPage,
        spaceManifest,
        spaceId,
        componentId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blogs"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BlogsApi - factory interface
 * @export
 */
export const BlogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BlogsApiFp(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogsApiBlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog(
      requestParameters: BlogsApiBlogRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogItemResponse> {
      return localVarFp
        .blog(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get blog post list
     * @summary Blog Post Lists
     * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs(
      requestParameters: BlogsApiBlogsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogIndexResponse> {
      return localVarFp
        .blogs(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for blog operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogRequest
 */
export interface BlogsApiBlogRequest {
  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof BlogsApiBlog
   */
  readonly locales?: Array<BlogLocalesEnum>;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly componentId?: number;
}

/**
 * Request parameters for blogs operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogsRequest
 */
export interface BlogsApiBlogsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof BlogsApiBlogs
   */
  readonly locales?: Array<BlogsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly perPage?: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof BlogsApiBlogs
   */
  readonly spaceManifest?: BlogsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly spaceId?: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly componentId?: number;
}

/**
 * BlogsApi - object-oriented interface
 * @export
 * @class BlogsApi
 * @extends {BaseAPI}
 */
export class BlogsApi extends BaseAPI {
  /**
   * Get blog post details
   * @summary Show a blog detail
   * @param {BlogsApiBlogRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blog(
    requestParameters: BlogsApiBlogRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blog(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get blog post list
   * @summary Blog Post Lists
   * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blogs(
    requestParameters: BlogsApiBlogsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blogs(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const BlogLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogLocalesEnum =
  (typeof BlogLocalesEnum)[keyof typeof BlogLocalesEnum];
/**
 * @export
 */
export const BlogsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogsLocalesEnum =
  (typeof BlogsLocalesEnum)[keyof typeof BlogsLocalesEnum];
/**
 * @export
 */
export const BlogsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogsSpaceManifestEnum =
  (typeof BlogsSpaceManifestEnum)[keyof typeof BlogsSpaceManifestEnum];

/**
 * ComponentsApi - axios parameter creator
 * @export
 */
export const ComponentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Blog component details
     * @summary Blog Component Details
     * @param {number} id
     * @param {Array<BlogComponentLocalesEnum>} [locales]
     * @param {number} [componentId]
     * @param {BlogComponentSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponent: async (
      id: number,
      locales?: Array<BlogComponentLocalesEnum>,
      componentId?: number,
      spaceManifest?: BlogComponentSpaceManifestEnum,
      spaceId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("blogComponent", "id", id);
      const localVarPath = `/components/blog_components/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search blog components of the organization
     * @summary Blog Components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<BlogComponentsLocalesEnum>} [locales]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponents: async (
      page?: number,
      perPage?: number,
      locales?: Array<BlogComponentsLocalesEnum>,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/components/blog_components`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find on proposal
     * @summary Proposal Component Details
     * @param {number} id
     * @param {Array<ProposalComponentLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponent: async (
      id: number,
      locales?: Array<ProposalComponentLocalesEnum>,
      page?: number,
      perPage?: number,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("proposalComponent", "id", id);
      const localVarPath = `/components/proposal_components/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search proposal components of the organization
     * @summary Proposal Components
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<ProposalComponentsLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponents: async (
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      page?: number,
      perPage?: number,
      locales?: Array<ProposalComponentsLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/components/proposal_components`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search components of the organization
     * @summary Search components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<SearchComponentsLocalesEnum>} [locales]
     * @param {Array<ComponentManifest>} [filterManifestNameNotIn]
     * @param {Array<ComponentManifest>} [filterManifestNameIn]
     * @param {string} [filterManifestNameStart]
     * @param {ComponentManifest} [filterManifestNameEq]
     * @param {ComponentManifest} [filterManifestNameNotEq]
     * @param {string} [filterManifestNameMatches]
     * @param {Array<number>} [filterIdNotIn]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdNotEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<SpaceType>} [filterParticipatorySpaceTypeIn]
     * @param {SpaceType} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchComponents: async (
      page?: number,
      perPage?: number,
      locales?: Array<SearchComponentsLocalesEnum>,
      filterManifestNameNotIn?: Array<ComponentManifest>,
      filterManifestNameIn?: Array<ComponentManifest>,
      filterManifestNameStart?: string,
      filterManifestNameEq?: ComponentManifest,
      filterManifestNameNotEq?: ComponentManifest,
      filterManifestNameMatches?: string,
      filterIdNotIn?: Array<number>,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdNotEq?: number,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<SpaceType>,
      filterParticipatorySpaceTypeEq?: SpaceType,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/components/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameStart !== undefined) {
        localVarQueryParameter["filter[manifest_name_start]"] =
          filterManifestNameStart;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterManifestNameMatches !== undefined) {
        localVarQueryParameter["filter[manifest_name_matches]"] =
          filterManifestNameMatches;
      }

      if (filterIdNotIn) {
        localVarQueryParameter["filter[id_not_in][]"] = filterIdNotIn;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      if (filterIdNotEq !== undefined) {
        localVarQueryParameter["filter[id_not_eq]"] = filterIdNotEq;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ComponentsApi - functional programming interface
 * @export
 */
export const ComponentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ComponentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Blog component details
     * @summary Blog Component Details
     * @param {number} id
     * @param {Array<BlogComponentLocalesEnum>} [locales]
     * @param {number} [componentId]
     * @param {BlogComponentSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogComponent(
      id: number,
      locales?: Array<BlogComponentLocalesEnum>,
      componentId?: number,
      spaceManifest?: BlogComponentSpaceManifestEnum,
      spaceId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogComponentItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogComponent(
        id,
        locales,
        componentId,
        spaceManifest,
        spaceId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.blogComponent"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search blog components of the organization
     * @summary Blog Components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<BlogComponentsLocalesEnum>} [locales]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogComponents(
      page?: number,
      perPage?: number,
      locales?: Array<BlogComponentsLocalesEnum>,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlogComponentIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogComponents(
        page,
        perPage,
        locales,
        filterParticipatorySpaceIdIn,
        filterParticipatorySpaceIdEq,
        filterParticipatorySpaceTypeIn,
        filterParticipatorySpaceTypeEq,
        filterNameStart,
        filterNameEq,
        filterNameNotEq,
        filterNameMatches,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.blogComponents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find on proposal
     * @summary Proposal Component Details
     * @param {number} id
     * @param {Array<ProposalComponentLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposalComponent(
      id: number,
      locales?: Array<ProposalComponentLocalesEnum>,
      page?: number,
      perPage?: number,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalComponentItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.proposalComponent(
          id,
          locales,
          page,
          perPage,
          filterIdIn,
          filterIdEq,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.proposalComponent"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search proposal components of the organization
     * @summary Proposal Components
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<ProposalComponentsLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposalComponents(
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      page?: number,
      perPage?: number,
      locales?: Array<ProposalComponentsLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalComponentIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.proposalComponents(
          filterNameStart,
          filterNameEq,
          filterNameNotEq,
          filterNameMatches,
          filterParticipatorySpaceTypeIn,
          filterParticipatorySpaceTypeEq,
          filterParticipatorySpaceIdIn,
          filterParticipatorySpaceIdEq,
          page,
          perPage,
          locales,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.proposalComponents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search components of the organization
     * @summary Search components
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<SearchComponentsLocalesEnum>} [locales]
     * @param {Array<ComponentManifest>} [filterManifestNameNotIn]
     * @param {Array<ComponentManifest>} [filterManifestNameIn]
     * @param {string} [filterManifestNameStart]
     * @param {ComponentManifest} [filterManifestNameEq]
     * @param {ComponentManifest} [filterManifestNameNotEq]
     * @param {string} [filterManifestNameMatches]
     * @param {Array<number>} [filterIdNotIn]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdNotEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<SpaceType>} [filterParticipatorySpaceTypeIn]
     * @param {SpaceType} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchComponents(
      page?: number,
      perPage?: number,
      locales?: Array<SearchComponentsLocalesEnum>,
      filterManifestNameNotIn?: Array<ComponentManifest>,
      filterManifestNameIn?: Array<ComponentManifest>,
      filterManifestNameStart?: string,
      filterManifestNameEq?: ComponentManifest,
      filterManifestNameNotEq?: ComponentManifest,
      filterManifestNameMatches?: string,
      filterIdNotIn?: Array<number>,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdNotEq?: number,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<SpaceType>,
      filterParticipatorySpaceTypeEq?: SpaceType,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ComponentIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchComponents(
          page,
          perPage,
          locales,
          filterManifestNameNotIn,
          filterManifestNameIn,
          filterManifestNameStart,
          filterManifestNameEq,
          filterManifestNameNotEq,
          filterManifestNameMatches,
          filterIdNotIn,
          filterIdIn,
          filterIdEq,
          filterIdNotEq,
          filterParticipatorySpaceIdIn,
          filterParticipatorySpaceIdEq,
          filterParticipatorySpaceTypeIn,
          filterParticipatorySpaceTypeEq,
          filterNameStart,
          filterNameEq,
          filterNameNotEq,
          filterNameMatches,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.searchComponents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ComponentsApi - factory interface
 * @export
 */
export const ComponentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ComponentsApiFp(configuration);
  return {
    /**
     * Blog component details
     * @summary Blog Component Details
     * @param {ComponentsApiBlogComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponent(
      requestParameters: ComponentsApiBlogComponentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogComponentItemResponse> {
      return localVarFp
        .blogComponent(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.componentId,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search blog components of the organization
     * @summary Blog Components
     * @param {ComponentsApiBlogComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogComponents(
      requestParameters: ComponentsApiBlogComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogComponentIndexResponse> {
      return localVarFp
        .blogComponents(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.locales,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Find on proposal
     * @summary Proposal Component Details
     * @param {ComponentsApiProposalComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponent(
      requestParameters: ComponentsApiProposalComponentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalComponentItemResponse> {
      return localVarFp
        .proposalComponent(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search proposal components of the organization
     * @summary Proposal Components
     * @param {ComponentsApiProposalComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponents(
      requestParameters: ComponentsApiProposalComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalComponentIndexResponse> {
      return localVarFp
        .proposalComponents(
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search components of the organization
     * @summary Search components
     * @param {ComponentsApiSearchComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchComponents(
      requestParameters: ComponentsApiSearchComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComponentIndexResponse> {
      return localVarFp
        .searchComponents(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.locales,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameStart,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterManifestNameMatches,
          requestParameters.filterIdNotIn,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          requestParameters.filterIdNotEq,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for blogComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiBlogComponentRequest
 */
export interface ComponentsApiBlogComponentRequest {
  /**
   *
   * @type {number}
   * @memberof ComponentsApiBlogComponent
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ComponentsApiBlogComponent
   */
  readonly locales?: Array<BlogComponentLocalesEnum>;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiBlogComponent
   */
  readonly componentId?: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ComponentsApiBlogComponent
   */
  readonly spaceManifest?: BlogComponentSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiBlogComponent
   */
  readonly spaceId?: number;
}

/**
 * Request parameters for blogComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiBlogComponentsRequest
 */
export interface ComponentsApiBlogComponentsRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiBlogComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiBlogComponents
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly locales?: Array<BlogComponentsLocalesEnum>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterParticipatorySpaceTypeEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiBlogComponents
   */
  readonly filterNameMatches?: string;
}

/**
 * Request parameters for proposalComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiProposalComponentRequest
 */
export interface ComponentsApiProposalComponentRequest {
  /**
   *
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ComponentsApiProposalComponent
   */
  readonly locales?: Array<ProposalComponentLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<number>}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiProposalComponent
   */
  readonly filterIdEq?: number;
}

/**
 * Request parameters for proposalComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiProposalComponentsRequest
 */
export interface ComponentsApiProposalComponentsRequest {
  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameMatches?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiProposalComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiProposalComponents
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly locales?: Array<ProposalComponentsLocalesEnum>;
}

/**
 * Request parameters for searchComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiSearchComponentsRequest
 */
export interface ComponentsApiSearchComponentsRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly locales?: Array<SearchComponentsLocalesEnum>;

  /**
   *
   * @type {Array<ComponentManifest>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameNotIn?: Array<ComponentManifest>;

  /**
   *
   * @type {Array<ComponentManifest>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameIn?: Array<ComponentManifest>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameStart?: string;

  /**
   *
   * @type {ComponentManifest}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameEq?: ComponentManifest;

  /**
   *
   * @type {ComponentManifest}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameNotEq?: ComponentManifest;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterManifestNameMatches?: string;

  /**
   *
   * @type {Array<number>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdNotIn?: Array<number>;

  /**
   *
   * @type {Array<number>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdEq?: number;

  /**
   *
   * @type {number}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterIdNotEq?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {Array<SpaceType>}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<SpaceType>;

  /**
   *
   * @type {SpaceType}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterParticipatorySpaceTypeEq?: SpaceType;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiSearchComponents
   */
  readonly filterNameMatches?: string;
}

/**
 * ComponentsApi - object-oriented interface
 * @export
 * @class ComponentsApi
 * @extends {BaseAPI}
 */
export class ComponentsApi extends BaseAPI {
  /**
   * Blog component details
   * @summary Blog Component Details
   * @param {ComponentsApiBlogComponentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public blogComponent(
    requestParameters: ComponentsApiBlogComponentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .blogComponent(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.componentId,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search blog components of the organization
   * @summary Blog Components
   * @param {ComponentsApiBlogComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public blogComponents(
    requestParameters: ComponentsApiBlogComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .blogComponents(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.locales,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find on proposal
   * @summary Proposal Component Details
   * @param {ComponentsApiProposalComponentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public proposalComponent(
    requestParameters: ComponentsApiProposalComponentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .proposalComponent(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search proposal components of the organization
   * @summary Proposal Components
   * @param {ComponentsApiProposalComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public proposalComponents(
    requestParameters: ComponentsApiProposalComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .proposalComponents(
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search components of the organization
   * @summary Search components
   * @param {ComponentsApiSearchComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public searchComponents(
    requestParameters: ComponentsApiSearchComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .searchComponents(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.locales,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameStart,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterManifestNameMatches,
        requestParameters.filterIdNotIn,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        requestParameters.filterIdNotEq,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const BlogComponentLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogComponentLocalesEnum =
  (typeof BlogComponentLocalesEnum)[keyof typeof BlogComponentLocalesEnum];
/**
 * @export
 */
export const BlogComponentSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogComponentSpaceManifestEnum =
  (typeof BlogComponentSpaceManifestEnum)[keyof typeof BlogComponentSpaceManifestEnum];
/**
 * @export
 */
export const BlogComponentsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogComponentsLocalesEnum =
  (typeof BlogComponentsLocalesEnum)[keyof typeof BlogComponentsLocalesEnum];
/**
 * @export
 */
export const ProposalComponentLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalComponentLocalesEnum =
  (typeof ProposalComponentLocalesEnum)[keyof typeof ProposalComponentLocalesEnum];
/**
 * @export
 */
export const ProposalComponentsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalComponentsLocalesEnum =
  (typeof ProposalComponentsLocalesEnum)[keyof typeof ProposalComponentsLocalesEnum];
/**
 * @export
 */
export const SearchComponentsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type SearchComponentsLocalesEnum =
  (typeof SearchComponentsLocalesEnum)[keyof typeof SearchComponentsLocalesEnum];

/**
 * DraftProposalsApi - axios parameter creator
 * @export
 */
export const DraftProposalsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a draft
     * @summary Create draft proposal
     * @param {CreateDraftProposalRequest} createDraftProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDraftProposal: async (
      createDraftProposalRequest: CreateDraftProposalRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDraftProposalRequest' is not null or undefined
      assertParamExists(
        "createDraftProposal",
        "createDraftProposalRequest",
        createDraftProposalRequest,
      );
      const localVarPath = `/draft_proposals`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDraftProposalRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("draftProposal", "id", id);
      const localVarPath = `/draft_proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishDraftProposal: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("publishDraftProposal", "id", id);
      const localVarPath = `/draft_proposals/{id}/publish`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Update draft proposal
     * @param {number} id
     * @param {UpdateDraftProposalRequest} updateDraftProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftProposal: async (
      id: number,
      updateDraftProposalRequest: UpdateDraftProposalRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateDraftProposal", "id", id);
      // verify required parameter 'updateDraftProposalRequest' is not null or undefined
      assertParamExists(
        "updateDraftProposal",
        "updateDraftProposalRequest",
        updateDraftProposalRequest,
      );
      const localVarPath = `/draft_proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDraftProposalRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnDraftProposal: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("withdrawnDraftProposal", "id", id);
      const localVarPath = `/draft_proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DraftProposalsApi - functional programming interface
 * @export
 */
export const DraftProposalsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DraftProposalsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a draft
     * @summary Create draft proposal
     * @param {CreateDraftProposalRequest} createDraftProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDraftProposal(
      createDraftProposalRequest: CreateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createDraftProposal(
          createDraftProposalRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.createDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async draftProposal(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.draftProposal(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.draftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishDraftProposal(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.publishDraftProposal(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.publishDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Update draft proposal
     * @param {number} id
     * @param {UpdateDraftProposalRequest} updateDraftProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDraftProposal(
      id: number,
      updateDraftProposalRequest: UpdateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateDraftProposal(
          id,
          updateDraftProposalRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.updateDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async withdrawnDraftProposal(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.withdrawnDraftProposal(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DraftProposalsApi.withdrawnDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DraftProposalsApi - factory interface
 * @export
 */
export const DraftProposalsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DraftProposalsApiFp(configuration);
  return {
    /**
     * Create a draft
     * @summary Create draft proposal
     * @param {DraftProposalsApiCreateDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDraftProposal(
      requestParameters: DraftProposalsApiCreateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .createDraftProposal(
          requestParameters.createDraftProposalRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {DraftProposalsApiDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal(
      requestParameters: DraftProposalsApiDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .draftProposal(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {DraftProposalsApiPublishDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishDraftProposal(
      requestParameters: DraftProposalsApiPublishDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalItemResponse> {
      return localVarFp
        .publishDraftProposal(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Update draft proposal
     * @param {DraftProposalsApiUpdateDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftProposal(
      requestParameters: DraftProposalsApiUpdateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .updateDraftProposal(
          requestParameters.id,
          requestParameters.updateDraftProposalRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {DraftProposalsApiWithdrawnDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnDraftProposal(
      requestParameters: DraftProposalsApiWithdrawnDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalItemResponse> {
      return localVarFp
        .withdrawnDraftProposal(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiCreateDraftProposalRequest
 */
export interface DraftProposalsApiCreateDraftProposalRequest {
  /**
   *
   * @type {CreateDraftProposalRequest}
   * @memberof DraftProposalsApiCreateDraftProposal
   */
  readonly createDraftProposalRequest: CreateDraftProposalRequest;
}

/**
 * Request parameters for draftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiDraftProposalRequest
 */
export interface DraftProposalsApiDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiDraftProposal
   */
  readonly id: number;
}

/**
 * Request parameters for publishDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiPublishDraftProposalRequest
 */
export interface DraftProposalsApiPublishDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiPublishDraftProposal
   */
  readonly id: number;
}

/**
 * Request parameters for updateDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiUpdateDraftProposalRequest
 */
export interface DraftProposalsApiUpdateDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiUpdateDraftProposal
   */
  readonly id: number;

  /**
   *
   * @type {UpdateDraftProposalRequest}
   * @memberof DraftProposalsApiUpdateDraftProposal
   */
  readonly updateDraftProposalRequest: UpdateDraftProposalRequest;
}

/**
 * Request parameters for withdrawnDraftProposal operation in DraftProposalsApi.
 * @export
 * @interface DraftProposalsApiWithdrawnDraftProposalRequest
 */
export interface DraftProposalsApiWithdrawnDraftProposalRequest {
  /**
   *
   * @type {number}
   * @memberof DraftProposalsApiWithdrawnDraftProposal
   */
  readonly id: number;
}

/**
 * DraftProposalsApi - object-oriented interface
 * @export
 * @class DraftProposalsApi
 * @extends {BaseAPI}
 */
export class DraftProposalsApi extends BaseAPI {
  /**
   * Create a draft
   * @summary Create draft proposal
   * @param {DraftProposalsApiCreateDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public createDraftProposal(
    requestParameters: DraftProposalsApiCreateDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .createDraftProposal(
        requestParameters.createDraftProposalRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
   * @summary Display a draft proposal
   * @param {DraftProposalsApiDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public draftProposal(
    requestParameters: DraftProposalsApiDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .draftProposal(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publish a draft proposal
   * @summary Publish a draft proposal
   * @param {DraftProposalsApiPublishDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public publishDraftProposal(
    requestParameters: DraftProposalsApiPublishDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .publishDraftProposal(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to  update a draft proposal associated with your application ID. Drafts updated via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_bearer_token  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
   * @summary Update draft proposal
   * @param {DraftProposalsApiUpdateDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public updateDraftProposal(
    requestParameters: DraftProposalsApiUpdateDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .updateDraftProposal(
        requestParameters.id,
        requestParameters.updateDraftProposalRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Withdrawn a draft proposal. This action cannot be undone.
   * @summary Withdrawn a draft proposal
   * @param {DraftProposalsApiWithdrawnDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DraftProposalsApi
   */
  public withdrawnDraftProposal(
    requestParameters: DraftProposalsApiWithdrawnDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DraftProposalsApiFp(this.configuration)
      .withdrawnDraftProposal(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Health metrics
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthMetrics: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/metrics/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration);
  return {
    /**
     * Health metrics
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthMetrics(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.healthMetrics(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MetricsApi.healthMetrics"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MetricsApiFp(configuration);
  return {
    /**
     * Health metrics
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthMetrics(options?: RawAxiosRequestConfig): AxiosPromise<Health> {
      return localVarFp
        .healthMetrics(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
  /**
   * Health metrics
   * @summary Health
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public healthMetrics(options?: RawAxiosRequestConfig) {
    return MetricsApiFp(this.configuration)
      .healthMetrics(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      oauthGrantParam: OauthGrantParam,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oauthGrantParam' is not null or undefined
      assertParamExists("createToken", "oauthGrantParam", oauthGrantParam);
      const localVarPath = `/oauth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        oauthGrantParam,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken: async (
      introspectTokenRequest: IntrospectTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'introspectTokenRequest' is not null or undefined
      assertParamExists(
        "introspectToken",
        "introspectTokenRequest",
        introspectTokenRequest,
      );
      const localVarPath = `/oauth/introspect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        introspectTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      oauthGrantParam: OauthGrantParam,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(
        oauthGrantParam,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.createToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async introspectToken(
      introspectTokenRequest: IntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntrospectData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.introspectToken(
        introspectTokenRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.introspectToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OAuthApiFp(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      requestParameters: OAuthApiCreateTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createToken(requestParameters.oauthGrantParam, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken(
      requestParameters: OAuthApiIntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntrospectData> {
      return localVarFp
        .introspectToken(requestParameters.introspectTokenRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createToken operation in OAuthApi.
 * @export
 * @interface OAuthApiCreateTokenRequest
 */
export interface OAuthApiCreateTokenRequest {
  /**
   *
   * @type {OauthGrantParam}
   * @memberof OAuthApiCreateToken
   */
  readonly oauthGrantParam: OauthGrantParam;
}

/**
 * Request parameters for introspectToken operation in OAuthApi.
 * @export
 * @interface OAuthApiIntrospectTokenRequest
 */
export interface OAuthApiIntrospectTokenRequest {
  /**
   *
   * @type {IntrospectTokenRequest}
   * @memberof OAuthApiIntrospectToken
   */
  readonly introspectTokenRequest: IntrospectTokenRequest;
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
  /**
   * Create a oauth token for the given scopes
   * @summary Request a OAuth token through Client Credentials
   * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public createToken(
    requestParameters: OAuthApiCreateTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .createToken(requestParameters.oauthGrantParam, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get given oauth token details
   * @summary Introspect a OAuth token
   * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public introspectToken(
    requestParameters: OAuthApiIntrospectTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .introspectToken(requestParameters.introspectTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProposalsApi - axios parameter creator
 * @export
 */
export const ProposalsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Proposal detail
     * @summary Proposal Details
     * @param {number} id
     * @param {Array<ProposalLocalesEnum>} [locales]
     * @param {ProposalSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal: async (
      id: number,
      locales?: Array<ProposalLocalesEnum>,
      spaceManifest?: ProposalSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightBlank?: boolean,
      filterStateIn?: Array<string>,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("proposal", "id", id);
      const localVarPath = `/proposals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      if (filterVotedWeightIn) {
        localVarQueryParameter["filter[voted_weight_in][]"] =
          filterVotedWeightIn;
      }

      if (filterVotedWeightEq !== undefined) {
        localVarQueryParameter["filter[voted_weight_eq]"] = filterVotedWeightEq;
      }

      if (filterVotedWeightBlank !== undefined) {
        localVarQueryParameter["filter[voted_weight_blank]"] =
          filterVotedWeightBlank;
      }

      if (filterStateIn) {
        localVarQueryParameter["filter[state_in][]"] = filterStateIn;
      }

      if (filterStateEq !== undefined) {
        localVarQueryParameter["filter[state_eq]"] = filterStateEq;
      }

      if (filterStateNotEq !== undefined) {
        localVarQueryParameter["filter[state_not_eq]"] = filterStateNotEq;
      }

      if (filterStateBlank !== undefined) {
        localVarQueryParameter["filter[state_blank]"] = filterStateBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search proposals
     * @summary Proposals
     * @param {Array<ProposalsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {ProposalsOrderEnum} [order]
     * @param {ProposalsOrderDirectionEnum} [orderDirection]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals: async (
      locales?: Array<ProposalsLocalesEnum>,
      page?: number,
      perPage?: number,
      spaceManifest?: ProposalsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightBlank?: boolean,
      filterStateIn?: Array<string>,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/proposals`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (spaceManifest !== undefined) {
        localVarQueryParameter["space_manifest"] = spaceManifest;
      }

      if (spaceId !== undefined) {
        localVarQueryParameter["space_id"] = spaceId;
      }

      if (componentId !== undefined) {
        localVarQueryParameter["component_id"] = componentId;
      }

      if (order !== undefined) {
        localVarQueryParameter["order"] = order;
      }

      if (orderDirection !== undefined) {
        localVarQueryParameter["order_direction"] = orderDirection;
      }

      if (filterVotedWeightIn) {
        localVarQueryParameter["filter[voted_weight_in][]"] =
          filterVotedWeightIn;
      }

      if (filterVotedWeightEq !== undefined) {
        localVarQueryParameter["filter[voted_weight_eq]"] = filterVotedWeightEq;
      }

      if (filterVotedWeightBlank !== undefined) {
        localVarQueryParameter["filter[voted_weight_blank]"] =
          filterVotedWeightBlank;
      }

      if (filterStateIn) {
        localVarQueryParameter["filter[state_in][]"] = filterStateIn;
      }

      if (filterStateEq !== undefined) {
        localVarQueryParameter["filter[state_eq]"] = filterStateEq;
      }

      if (filterStateNotEq !== undefined) {
        localVarQueryParameter["filter[state_not_eq]"] = filterStateNotEq;
      }

      if (filterStateBlank !== undefined) {
        localVarQueryParameter["filter[state_blank]"] = filterStateBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProposalsApi - functional programming interface
 * @export
 */
export const ProposalsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProposalsApiAxiosParamCreator(configuration);
  return {
    /**
     * Proposal detail
     * @summary Proposal Details
     * @param {number} id
     * @param {Array<ProposalLocalesEnum>} [locales]
     * @param {ProposalSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposal(
      id: number,
      locales?: Array<ProposalLocalesEnum>,
      spaceManifest?: ProposalSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightBlank?: boolean,
      filterStateIn?: Array<string>,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposal(
        id,
        locales,
        spaceManifest,
        spaceId,
        componentId,
        filterVotedWeightIn,
        filterVotedWeightEq,
        filterVotedWeightBlank,
        filterStateIn,
        filterStateEq,
        filterStateNotEq,
        filterStateBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search proposals
     * @summary Proposals
     * @param {Array<ProposalsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsSpaceManifestEnum} [spaceManifest]
     * @param {number} [spaceId]
     * @param {number} [componentId]
     * @param {ProposalsOrderEnum} [order]
     * @param {ProposalsOrderDirectionEnum} [orderDirection]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {Array<string>} [filterStateIn]
     * @param {string} [filterStateEq]
     * @param {string} [filterStateNotEq]
     * @param {boolean} [filterStateBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposals(
      locales?: Array<ProposalsLocalesEnum>,
      page?: number,
      perPage?: number,
      spaceManifest?: ProposalsSpaceManifestEnum,
      spaceId?: number,
      componentId?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightBlank?: boolean,
      filterStateIn?: Array<string>,
      filterStateEq?: string,
      filterStateNotEq?: string,
      filterStateBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposals(
        locales,
        page,
        perPage,
        spaceManifest,
        spaceId,
        componentId,
        order,
        orderDirection,
        filterVotedWeightIn,
        filterVotedWeightEq,
        filterVotedWeightBlank,
        filterStateIn,
        filterStateEq,
        filterStateNotEq,
        filterStateBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposals"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProposalsApi - factory interface
 * @export
 */
export const ProposalsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProposalsApiFp(configuration);
  return {
    /**
     * Proposal detail
     * @summary Proposal Details
     * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal(
      requestParameters: ProposalsApiProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalItemResponse> {
      return localVarFp
        .proposal(
          requestParameters.id,
          requestParameters.locales,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.filterVotedWeightIn,
          requestParameters.filterVotedWeightEq,
          requestParameters.filterVotedWeightBlank,
          requestParameters.filterStateIn,
          requestParameters.filterStateEq,
          requestParameters.filterStateNotEq,
          requestParameters.filterStateBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Search proposals
     * @summary Proposals
     * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals(
      requestParameters: ProposalsApiProposalsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalIndexResponse> {
      return localVarFp
        .proposals(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.order,
          requestParameters.orderDirection,
          requestParameters.filterVotedWeightIn,
          requestParameters.filterVotedWeightEq,
          requestParameters.filterVotedWeightBlank,
          requestParameters.filterStateIn,
          requestParameters.filterStateEq,
          requestParameters.filterStateNotEq,
          requestParameters.filterStateBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for proposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalRequest
 */
export interface ProposalsApiProposalRequest {
  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ProposalsApiProposal
   */
  readonly locales?: Array<ProposalLocalesEnum>;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposal
   */
  readonly spaceManifest?: ProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly spaceId?: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly componentId?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightEq?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposal
   */
  readonly filterVotedWeightBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateNotEq?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposal
   */
  readonly filterStateBlank?: boolean;
}

/**
 * Request parameters for proposals operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalsRequest
 */
export interface ProposalsApiProposalsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ProposalsApiProposals
   */
  readonly locales?: Array<ProposalsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly perPage?: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposals
   */
  readonly spaceManifest?: ProposalsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly spaceId?: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly componentId?: number;

  /**
   *
   * @type {'published_at' | 'rand'}
   * @memberof ProposalsApiProposals
   */
  readonly order?: ProposalsOrderEnum;

  /**
   *
   * @type {'desc' | 'asc'}
   * @memberof ProposalsApiProposals
   */
  readonly orderDirection?: ProposalsOrderDirectionEnum;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightEq?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightBlank?: boolean;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateEq?: string;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateNotEq?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposals
   */
  readonly filterStateBlank?: boolean;
}

/**
 * ProposalsApi - object-oriented interface
 * @export
 * @class ProposalsApi
 * @extends {BaseAPI}
 */
export class ProposalsApi extends BaseAPI {
  /**
   * Proposal detail
   * @summary Proposal Details
   * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposal(
    requestParameters: ProposalsApiProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposal(
        requestParameters.id,
        requestParameters.locales,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.filterVotedWeightIn,
        requestParameters.filterVotedWeightEq,
        requestParameters.filterVotedWeightBlank,
        requestParameters.filterStateIn,
        requestParameters.filterStateEq,
        requestParameters.filterStateNotEq,
        requestParameters.filterStateBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search proposals
   * @summary Proposals
   * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposals(
    requestParameters: ProposalsApiProposalsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposals(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.order,
        requestParameters.orderDirection,
        requestParameters.filterVotedWeightIn,
        requestParameters.filterVotedWeightEq,
        requestParameters.filterVotedWeightBlank,
        requestParameters.filterStateIn,
        requestParameters.filterStateEq,
        requestParameters.filterStateNotEq,
        requestParameters.filterStateBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ProposalLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalLocalesEnum =
  (typeof ProposalLocalesEnum)[keyof typeof ProposalLocalesEnum];
/**
 * @export
 */
export const ProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalSpaceManifestEnum =
  (typeof ProposalSpaceManifestEnum)[keyof typeof ProposalSpaceManifestEnum];
/**
 * @export
 */
export const ProposalsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalsLocalesEnum =
  (typeof ProposalsLocalesEnum)[keyof typeof ProposalsLocalesEnum];
/**
 * @export
 */
export const ProposalsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalsSpaceManifestEnum =
  (typeof ProposalsSpaceManifestEnum)[keyof typeof ProposalsSpaceManifestEnum];
/**
 * @export
 */
export const ProposalsOrderEnum = {
  PublishedAt: "published_at",
  Rand: "rand",
} as const;
export type ProposalsOrderEnum =
  (typeof ProposalsOrderEnum)[keyof typeof ProposalsOrderEnum];
/**
 * @export
 */
export const ProposalsOrderDirectionEnum = {
  Desc: "desc",
  Asc: "asc",
} as const;
export type ProposalsOrderDirectionEnum =
  (typeof ProposalsOrderDirectionEnum)[keyof typeof ProposalsOrderDirectionEnum];

/**
 * ProposalsVoteApi - axios parameter creator
 * @export
 */
export const ProposalsVoteApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {VoteProposalRequest} voteProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voteProposal: async (
      voteProposalRequest: VoteProposalRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'voteProposalRequest' is not null or undefined
      assertParamExists(
        "voteProposal",
        "voteProposalRequest",
        voteProposalRequest,
      );
      const localVarPath = `/proposal_votes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        voteProposalRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProposalsVoteApi - functional programming interface
 * @export
 */
export const ProposalsVoteApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProposalsVoteApiAxiosParamCreator(configuration);
  return {
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {VoteProposalRequest} voteProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async voteProposal(
      voteProposalRequest: VoteProposalRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.voteProposal(
        voteProposalRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsVoteApi.voteProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProposalsVoteApi - factory interface
 * @export
 */
export const ProposalsVoteApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProposalsVoteApiFp(configuration);
  return {
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {ProposalsVoteApiVoteProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voteProposal(
      requestParameters: ProposalsVoteApiVoteProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalItemResponse> {
      return localVarFp
        .voteProposal(requestParameters.voteProposalRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for voteProposal operation in ProposalsVoteApi.
 * @export
 * @interface ProposalsVoteApiVoteProposalRequest
 */
export interface ProposalsVoteApiVoteProposalRequest {
  /**
   *
   * @type {VoteProposalRequest}
   * @memberof ProposalsVoteApiVoteProposal
   */
  readonly voteProposalRequest: VoteProposalRequest;
}

/**
 * ProposalsVoteApi - object-oriented interface
 * @export
 * @class ProposalsVoteApi
 * @extends {BaseAPI}
 */
export class ProposalsVoteApi extends BaseAPI {
  /**
   * Vote on a proposal
   * @summary Vote
   * @param {ProposalsVoteApiVoteProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsVoteApi
   */
  public voteProposal(
    requestParameters: ProposalsVoteApiVoteProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsVoteApiFp(this.configuration)
      .voteProposal(requestParameters.voteProposalRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SpacesApi - axios parameter creator
 * @export
 */
export const SpacesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get detail of a Assemblies given its id
     * @summary Assemblies Details
     * @param {number} id
     * @param {Array<AssembliesLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assemblies: async (
      id: number,
      locales?: Array<AssembliesLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("assemblies", "id", id);
      const localVarPath = `/spaces/assemblies/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get detail of a Participatory Processes given its id
     * @summary Participatory Processes Details
     * @param {number} id
     * @param {Array<ParticipatoryProcessesLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    participatoryProcesses: async (
      id: number,
      locales?: Array<ParticipatoryProcessesLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("participatoryProcesses", "id", id);
      const localVarPath = `/spaces/participatory_processes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary Search Participatory Spaces
     * @param {Array<SearchSpacesLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<SearchSpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SearchSpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {SearchSpacesFilterManifestNameEqEnum} [filterManifestNameEq]
     * @param {SearchSpacesFilterManifestNameNotEqEnum} [filterManifestNameNotEq]
     * @param {Array<number>} [filterIdNotIn]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdNotEq]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleNotStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {string} [filterTitleDoesNotMatch]
     * @param {boolean} [filterTitlePresent]
     * @param {boolean} [filterTitleBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSpaces: async (
      locales?: Array<SearchSpacesLocalesEnum>,
      page?: number,
      perPage?: number,
      filterManifestNameNotIn?: Array<SearchSpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SearchSpacesFilterManifestNameInEnum>,
      filterManifestNameEq?: SearchSpacesFilterManifestNameEqEnum,
      filterManifestNameNotEq?: SearchSpacesFilterManifestNameNotEqEnum,
      filterIdNotIn?: Array<number>,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdNotEq?: number,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleNotStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleDoesNotMatch?: string,
      filterTitlePresent?: boolean,
      filterTitleBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/spaces/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterIdNotIn) {
        localVarQueryParameter["filter[id_not_in][]"] = filterIdNotIn;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      if (filterIdNotEq !== undefined) {
        localVarQueryParameter["filter[id_not_eq]"] = filterIdNotEq;
      }

      if (filterTitleNotIn) {
        localVarQueryParameter["filter[title_not_in][]"] = filterTitleNotIn;
      }

      if (filterTitleIn) {
        localVarQueryParameter["filter[title_in][]"] = filterTitleIn;
      }

      if (filterTitleStart !== undefined) {
        localVarQueryParameter["filter[title_start]"] = filterTitleStart;
      }

      if (filterTitleNotStart !== undefined) {
        localVarQueryParameter["filter[title_not_start]"] = filterTitleNotStart;
      }

      if (filterTitleEq !== undefined) {
        localVarQueryParameter["filter[title_eq]"] = filterTitleEq;
      }

      if (filterTitleNotEq !== undefined) {
        localVarQueryParameter["filter[title_not_eq]"] = filterTitleNotEq;
      }

      if (filterTitleMatches !== undefined) {
        localVarQueryParameter["filter[title_matches]"] = filterTitleMatches;
      }

      if (filterTitleDoesNotMatch !== undefined) {
        localVarQueryParameter["filter[title_does_not_match]"] =
          filterTitleDoesNotMatch;
      }

      if (filterTitlePresent !== undefined) {
        localVarQueryParameter["filter[title_present]"] = filterTitlePresent;
      }

      if (filterTitleBlank !== undefined) {
        localVarQueryParameter["filter[title_blank]"] = filterTitleBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SpacesApi - functional programming interface
 * @export
 */
export const SpacesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SpacesApiAxiosParamCreator(configuration);
  return {
    /**
     * Get detail of a Assemblies given its id
     * @summary Assemblies Details
     * @param {number} id
     * @param {Array<AssembliesLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assemblies(
      id: number,
      locales?: Array<AssembliesLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SpaceItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assemblies(
        id,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SpacesApi.assemblies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get detail of a Participatory Processes given its id
     * @summary Participatory Processes Details
     * @param {number} id
     * @param {Array<ParticipatoryProcessesLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async participatoryProcesses(
      id: number,
      locales?: Array<ParticipatoryProcessesLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SpaceItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.participatoryProcesses(
          id,
          locales,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SpacesApi.participatoryProcesses"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary Search Participatory Spaces
     * @param {Array<SearchSpacesLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<SearchSpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SearchSpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {SearchSpacesFilterManifestNameEqEnum} [filterManifestNameEq]
     * @param {SearchSpacesFilterManifestNameNotEqEnum} [filterManifestNameNotEq]
     * @param {Array<number>} [filterIdNotIn]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdNotEq]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleNotStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {string} [filterTitleDoesNotMatch]
     * @param {boolean} [filterTitlePresent]
     * @param {boolean} [filterTitleBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchSpaces(
      locales?: Array<SearchSpacesLocalesEnum>,
      page?: number,
      perPage?: number,
      filterManifestNameNotIn?: Array<SearchSpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SearchSpacesFilterManifestNameInEnum>,
      filterManifestNameEq?: SearchSpacesFilterManifestNameEqEnum,
      filterManifestNameNotEq?: SearchSpacesFilterManifestNameNotEqEnum,
      filterIdNotIn?: Array<number>,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdNotEq?: number,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleNotStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleDoesNotMatch?: string,
      filterTitlePresent?: boolean,
      filterTitleBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SpaceIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchSpaces(
        locales,
        page,
        perPage,
        filterManifestNameNotIn,
        filterManifestNameIn,
        filterManifestNameEq,
        filterManifestNameNotEq,
        filterIdNotIn,
        filterIdIn,
        filterIdEq,
        filterIdNotEq,
        filterTitleNotIn,
        filterTitleIn,
        filterTitleStart,
        filterTitleNotStart,
        filterTitleEq,
        filterTitleNotEq,
        filterTitleMatches,
        filterTitleDoesNotMatch,
        filterTitlePresent,
        filterTitleBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SpacesApi.searchSpaces"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SpacesApi - factory interface
 * @export
 */
export const SpacesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SpacesApiFp(configuration);
  return {
    /**
     * Get detail of a Assemblies given its id
     * @summary Assemblies Details
     * @param {SpacesApiAssembliesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assemblies(
      requestParameters: SpacesApiAssembliesRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceItemResponse> {
      return localVarFp
        .assemblies(requestParameters.id, requestParameters.locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get detail of a Participatory Processes given its id
     * @summary Participatory Processes Details
     * @param {SpacesApiParticipatoryProcessesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    participatoryProcesses(
      requestParameters: SpacesApiParticipatoryProcessesRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceItemResponse> {
      return localVarFp
        .participatoryProcesses(
          requestParameters.id,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary Search Participatory Spaces
     * @param {SpacesApiSearchSpacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSpaces(
      requestParameters: SpacesApiSearchSpacesRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceIndexResponse> {
      return localVarFp
        .searchSpaces(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterIdNotIn,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          requestParameters.filterIdNotEq,
          requestParameters.filterTitleNotIn,
          requestParameters.filterTitleIn,
          requestParameters.filterTitleStart,
          requestParameters.filterTitleNotStart,
          requestParameters.filterTitleEq,
          requestParameters.filterTitleNotEq,
          requestParameters.filterTitleMatches,
          requestParameters.filterTitleDoesNotMatch,
          requestParameters.filterTitlePresent,
          requestParameters.filterTitleBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for assemblies operation in SpacesApi.
 * @export
 * @interface SpacesApiAssembliesRequest
 */
export interface SpacesApiAssembliesRequest {
  /**
   *
   * @type {number}
   * @memberof SpacesApiAssemblies
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof SpacesApiAssemblies
   */
  readonly locales?: Array<AssembliesLocalesEnum>;
}

/**
 * Request parameters for participatoryProcesses operation in SpacesApi.
 * @export
 * @interface SpacesApiParticipatoryProcessesRequest
 */
export interface SpacesApiParticipatoryProcessesRequest {
  /**
   *
   * @type {number}
   * @memberof SpacesApiParticipatoryProcesses
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof SpacesApiParticipatoryProcesses
   */
  readonly locales?: Array<ParticipatoryProcessesLocalesEnum>;
}

/**
 * Request parameters for searchSpaces operation in SpacesApi.
 * @export
 * @interface SpacesApiSearchSpacesRequest
 */
export interface SpacesApiSearchSpacesRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly locales?: Array<SearchSpacesLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameNotIn?: Array<SearchSpacesFilterManifestNameNotInEnum>;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameIn?: Array<SearchSpacesFilterManifestNameInEnum>;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameEq?: SearchSpacesFilterManifestNameEqEnum;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterManifestNameNotEq?: SearchSpacesFilterManifestNameNotEqEnum;

  /**
   *
   * @type {Array<number>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdNotIn?: Array<number>;

  /**
   *
   * @type {Array<number>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdEq?: number;

  /**
   *
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterIdNotEq?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleStart?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleNotStart?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleEq?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleMatches?: string;

  /**
   *
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleDoesNotMatch?: string;

  /**
   *
   * @type {boolean}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitlePresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof SpacesApiSearchSpaces
   */
  readonly filterTitleBlank?: boolean;
}

/**
 * SpacesApi - object-oriented interface
 * @export
 * @class SpacesApi
 * @extends {BaseAPI}
 */
export class SpacesApi extends BaseAPI {
  /**
   * Get detail of a Assemblies given its id
   * @summary Assemblies Details
   * @param {SpacesApiAssembliesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public assemblies(
    requestParameters: SpacesApiAssembliesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SpacesApiFp(this.configuration)
      .assemblies(requestParameters.id, requestParameters.locales, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get detail of a Participatory Processes given its id
   * @summary Participatory Processes Details
   * @param {SpacesApiParticipatoryProcessesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public participatoryProcesses(
    requestParameters: SpacesApiParticipatoryProcessesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SpacesApiFp(this.configuration)
      .participatoryProcesses(
        requestParameters.id,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
   * @summary Search Participatory Spaces
   * @param {SpacesApiSearchSpacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public searchSpaces(
    requestParameters: SpacesApiSearchSpacesRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return SpacesApiFp(this.configuration)
      .searchSpaces(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterIdNotIn,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        requestParameters.filterIdNotEq,
        requestParameters.filterTitleNotIn,
        requestParameters.filterTitleIn,
        requestParameters.filterTitleStart,
        requestParameters.filterTitleNotStart,
        requestParameters.filterTitleEq,
        requestParameters.filterTitleNotEq,
        requestParameters.filterTitleMatches,
        requestParameters.filterTitleDoesNotMatch,
        requestParameters.filterTitlePresent,
        requestParameters.filterTitleBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const AssembliesLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type AssembliesLocalesEnum =
  (typeof AssembliesLocalesEnum)[keyof typeof AssembliesLocalesEnum];
/**
 * @export
 */
export const ParticipatoryProcessesLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ParticipatoryProcessesLocalesEnum =
  (typeof ParticipatoryProcessesLocalesEnum)[keyof typeof ParticipatoryProcessesLocalesEnum];
/**
 * @export
 */
export const SearchSpacesLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type SearchSpacesLocalesEnum =
  (typeof SearchSpacesLocalesEnum)[keyof typeof SearchSpacesLocalesEnum];
/**
 * @export
 */
export const SearchSpacesFilterManifestNameNotInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameNotInEnum =
  (typeof SearchSpacesFilterManifestNameNotInEnum)[keyof typeof SearchSpacesFilterManifestNameNotInEnum];
/**
 * @export
 */
export const SearchSpacesFilterManifestNameInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameInEnum =
  (typeof SearchSpacesFilterManifestNameInEnum)[keyof typeof SearchSpacesFilterManifestNameInEnum];
/**
 * @export
 */
export const SearchSpacesFilterManifestNameEqEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameEqEnum =
  (typeof SearchSpacesFilterManifestNameEqEnum)[keyof typeof SearchSpacesFilterManifestNameEqEnum];
/**
 * @export
 */
export const SearchSpacesFilterManifestNameNotEqEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SearchSpacesFilterManifestNameNotEqEnum =
  (typeof SearchSpacesFilterManifestNameNotEqEnum)[keyof typeof SearchSpacesFilterManifestNameNotEqEnum];

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {Array<OrganizationsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations: async (
      locales?: Array<OrganizationsLocalesEnum>,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/organizations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration);
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {Array<OrganizationsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizations(
      locales?: Array<OrganizationsLocalesEnum>,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrganizationIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.organizations(
        locales,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.organizations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration);
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {SystemApiOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations(
      requestParameters: SystemApiOrganizationsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OrganizationIndexResponse> {
      return localVarFp
        .organizations(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for organizations operation in SystemApi.
 * @export
 * @interface SystemApiOrganizationsRequest
 */
export interface SystemApiOrganizationsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof SystemApiOrganizations
   */
  readonly locales?: Array<OrganizationsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof SystemApiOrganizations
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof SystemApiOrganizations
   */
  readonly perPage?: number;
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   * List available organizations
   * @summary List available organizations
   * @param {SystemApiOrganizationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public organizations(
    requestParameters: SystemApiOrganizationsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .organizations(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const OrganizationsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type OrganizationsLocalesEnum =
  (typeof OrganizationsLocalesEnum)[keyof typeof OrganizationsLocalesEnum];

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {MagickLinkConfigurationPayload} [magickLinkConfigurationPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink: async (
      magickLinkConfigurationPayload?: MagickLinkConfigurationPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/me/magic_links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        magickLinkConfigurationPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
     * @summary Use a magic-lick
     * @param {string} magicToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    magicLinkSignin: async (
      magicToken: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'magicToken' is not null or undefined
      assertParamExists("magicLinkSignin", "magicToken", magicToken);
      const localVarPath = `/me/magic_links/{magic_token}`.replace(
        `{${"magic_token"}}`,
        encodeURIComponent(String(magicToken)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {SetUserDataRequest} setUserDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData: async (
      setUserDataRequest: SetUserDataRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setUserDataRequest' is not null or undefined
      assertParamExists(
        "setUserData",
        "setUserDataRequest",
        setUserDataRequest,
      );
      const localVarPath = `/me/extended_data`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUserDataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData: async (
      objectPath: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'objectPath' is not null or undefined
      assertParamExists("userData", "objectPath", objectPath);
      const localVarPath = `/me/extended_data`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (objectPath !== undefined) {
        localVarQueryParameter["object_path"] = objectPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameNotStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {string} [filterNicknameDoesNotMatch]
     * @param {boolean} [filterNicknamePresent]
     * @param {boolean} [filterNicknameBlank]
     * @param {Array<number>} [filterIdNotIn]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdNotEq]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users: async (
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameNotStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameDoesNotMatch?: string,
      filterNicknamePresent?: boolean,
      filterNicknameBlank?: boolean,
      filterIdNotIn?: Array<number>,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdNotEq?: number,
      filterExtendedDataCont?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterNicknameNotIn) {
        localVarQueryParameter["filter[nickname_not_in][]"] =
          filterNicknameNotIn;
      }

      if (filterNicknameIn) {
        localVarQueryParameter["filter[nickname_in][]"] = filterNicknameIn;
      }

      if (filterNicknameStart !== undefined) {
        localVarQueryParameter["filter[nickname_start]"] = filterNicknameStart;
      }

      if (filterNicknameNotStart !== undefined) {
        localVarQueryParameter["filter[nickname_not_start]"] =
          filterNicknameNotStart;
      }

      if (filterNicknameEq !== undefined) {
        localVarQueryParameter["filter[nickname_eq]"] = filterNicknameEq;
      }

      if (filterNicknameNotEq !== undefined) {
        localVarQueryParameter["filter[nickname_not_eq]"] = filterNicknameNotEq;
      }

      if (filterNicknameMatches !== undefined) {
        localVarQueryParameter["filter[nickname_matches]"] =
          filterNicknameMatches;
      }

      if (filterNicknameDoesNotMatch !== undefined) {
        localVarQueryParameter["filter[nickname_does_not_match]"] =
          filterNicknameDoesNotMatch;
      }

      if (filterNicknamePresent !== undefined) {
        localVarQueryParameter["filter[nickname_present]"] =
          filterNicknamePresent;
      }

      if (filterNicknameBlank !== undefined) {
        localVarQueryParameter["filter[nickname_blank]"] = filterNicknameBlank;
      }

      if (filterIdNotIn) {
        localVarQueryParameter["filter[id_not_in][]"] = filterIdNotIn;
      }

      if (filterIdIn) {
        localVarQueryParameter["filter[id_in][]"] = filterIdIn;
      }

      if (filterIdEq !== undefined) {
        localVarQueryParameter["filter[id_eq]"] = filterIdEq;
      }

      if (filterIdNotEq !== undefined) {
        localVarQueryParameter["filter[id_not_eq]"] = filterIdNotEq;
      }

      if (filterExtendedDataCont !== undefined) {
        localVarQueryParameter["filter[extended_data_cont]"] =
          filterExtendedDataCont;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {MagickLinkConfigurationPayload} [magickLinkConfigurationPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateMagicLink(
      magickLinkConfigurationPayload?: MagickLinkConfigurationPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MagicLinkItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateMagicLink(
          magickLinkConfigurationPayload,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.generateMagicLink"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
     * @summary Use a magic-lick
     * @param {string} magicToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async magicLinkSignin(
      magicToken: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.magicLinkSignin(
        magicToken,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.magicLinkSignin"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {SetUserDataRequest} setUserDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserData(
      setUserDataRequest: SetUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserData(
        setUserDataRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.setUserData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userData(
      objectPath: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userData(
        objectPath,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.userData"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameNotStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {string} [filterNicknameDoesNotMatch]
     * @param {boolean} [filterNicknamePresent]
     * @param {boolean} [filterNicknameBlank]
     * @param {Array<number>} [filterIdNotIn]
     * @param {Array<number>} [filterIdIn]
     * @param {number} [filterIdEq]
     * @param {number} [filterIdNotEq]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async users(
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameNotStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameDoesNotMatch?: string,
      filterNicknamePresent?: boolean,
      filterNicknameBlank?: boolean,
      filterIdNotIn?: Array<number>,
      filterIdIn?: Array<number>,
      filterIdEq?: number,
      filterIdNotEq?: number,
      filterExtendedDataCont?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserIndexResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.users(
        page,
        perPage,
        filterNicknameNotIn,
        filterNicknameIn,
        filterNicknameStart,
        filterNicknameNotStart,
        filterNicknameEq,
        filterNicknameNotEq,
        filterNicknameMatches,
        filterNicknameDoesNotMatch,
        filterNicknamePresent,
        filterNicknameBlank,
        filterIdNotIn,
        filterIdIn,
        filterIdEq,
        filterIdNotEq,
        filterExtendedDataCont,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.users"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {UsersApiGenerateMagicLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink(
      requestParameters: UsersApiGenerateMagicLinkRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MagicLinkItemResponse> {
      return localVarFp
        .generateMagicLink(
          requestParameters.magickLinkConfigurationPayload,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
     * @summary Use a magic-lick
     * @param {UsersApiMagicLinkSigninRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    magicLinkSignin(
      requestParameters: UsersApiMagicLinkSigninRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .magicLinkSignin(requestParameters.magicToken, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {UsersApiSetUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData(
      requestParameters: UsersApiSetUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .setUserData(requestParameters.setUserDataRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {UsersApiUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData(
      requestParameters: UsersApiUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .userData(requestParameters.objectPath, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {UsersApiUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users(
      requestParameters: UsersApiUsersRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserIndexResponse> {
      return localVarFp
        .users(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterNicknameNotIn,
          requestParameters.filterNicknameIn,
          requestParameters.filterNicknameStart,
          requestParameters.filterNicknameNotStart,
          requestParameters.filterNicknameEq,
          requestParameters.filterNicknameNotEq,
          requestParameters.filterNicknameMatches,
          requestParameters.filterNicknameDoesNotMatch,
          requestParameters.filterNicknamePresent,
          requestParameters.filterNicknameBlank,
          requestParameters.filterIdNotIn,
          requestParameters.filterIdIn,
          requestParameters.filterIdEq,
          requestParameters.filterIdNotEq,
          requestParameters.filterExtendedDataCont,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for generateMagicLink operation in UsersApi.
 * @export
 * @interface UsersApiGenerateMagicLinkRequest
 */
export interface UsersApiGenerateMagicLinkRequest {
  /**
   *
   * @type {MagickLinkConfigurationPayload}
   * @memberof UsersApiGenerateMagicLink
   */
  readonly magickLinkConfigurationPayload?: MagickLinkConfigurationPayload;
}

/**
 * Request parameters for magicLinkSignin operation in UsersApi.
 * @export
 * @interface UsersApiMagicLinkSigninRequest
 */
export interface UsersApiMagicLinkSigninRequest {
  /**
   *
   * @type {string}
   * @memberof UsersApiMagicLinkSignin
   */
  readonly magicToken: string;
}

/**
 * Request parameters for setUserData operation in UsersApi.
 * @export
 * @interface UsersApiSetUserDataRequest
 */
export interface UsersApiSetUserDataRequest {
  /**
   *
   * @type {SetUserDataRequest}
   * @memberof UsersApiSetUserData
   */
  readonly setUserDataRequest: SetUserDataRequest;
}

/**
 * Request parameters for userData operation in UsersApi.
 * @export
 * @interface UsersApiUserDataRequest
 */
export interface UsersApiUserDataRequest {
  /**
   *
   * @type {string}
   * @memberof UsersApiUserData
   */
  readonly objectPath: string;
}

/**
 * Request parameters for users operation in UsersApi.
 * @export
 * @interface UsersApiUsersRequest
 */
export interface UsersApiUsersRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameStart?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameNotStart?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameEq?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameMatches?: string;

  /**
   *
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameDoesNotMatch?: string;

  /**
   *
   * @type {boolean}
   * @memberof UsersApiUsers
   */
  readonly filterNicknamePresent?: boolean;

  /**
   *
   * @type {boolean}
   * @memberof UsersApiUsers
   */
  readonly filterNicknameBlank?: boolean;

  /**
   *
   * @type {Array<number>}
   * @memberof UsersApiUsers
   */
  readonly filterIdNotIn?: Array<number>;

  /**
   *
   * @type {Array<number>}
   * @memberof UsersApiUsers
   */
  readonly filterIdIn?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly filterIdEq?: number;

  /**
   *
   * @type {number}
   * @memberof UsersApiUsers
   */
  readonly filterIdNotEq?: number;

  /**
   * Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
   * @type {string}
   * @memberof UsersApiUsers
   */
  readonly filterExtendedDataCont?: string;
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
   * @summary Create a magic-lick
   * @param {UsersApiGenerateMagicLinkRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public generateMagicLink(
    requestParameters: UsersApiGenerateMagicLinkRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .generateMagicLink(
        requestParameters.magickLinkConfigurationPayload,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Challenge given token, open and a session and redirect. Publically accessible by HTTP.
   * @summary Use a magic-lick
   * @param {UsersApiMagicLinkSigninRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public magicLinkSignin(
    requestParameters: UsersApiMagicLinkSigninRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .magicLinkSignin(requestParameters.magicToken, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
   * @summary Update user extended data
   * @param {UsersApiSetUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public setUserData(
    requestParameters: UsersApiSetUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .setUserData(requestParameters.setUserDataRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch user extended data
   * @summary Get user extended data
   * @param {UsersApiUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userData(
    requestParameters: UsersApiUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .userData(requestParameters.objectPath, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search users of the organization
   * @summary List available Users
   * @param {UsersApiUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public users(
    requestParameters: UsersApiUsersRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .users(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterNicknameNotIn,
        requestParameters.filterNicknameIn,
        requestParameters.filterNicknameStart,
        requestParameters.filterNicknameNotStart,
        requestParameters.filterNicknameEq,
        requestParameters.filterNicknameNotEq,
        requestParameters.filterNicknameMatches,
        requestParameters.filterNicknameDoesNotMatch,
        requestParameters.filterNicknamePresent,
        requestParameters.filterNicknameBlank,
        requestParameters.filterIdNotIn,
        requestParameters.filterIdIn,
        requestParameters.filterIdEq,
        requestParameters.filterIdNotEq,
        requestParameters.filterExtendedDataCont,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
