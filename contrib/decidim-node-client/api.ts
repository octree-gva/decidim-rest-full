/* tslint:disable */
/* eslint-disable */
/**
 * API V1
 * A RestFull API for Decidim, to be able to CRUD resources from Decidim.  ## Authentication [Get a token](https://octree-gva.github.io/decidim-rest-full/category/authentication) from our `/oauth/token` routes, following OAuth specs on Credential Flows or Resource Owner Password Credentials Flow.  ### Permissions A permission system is attached to the created OAuth application, that is designed in two levels:  - **scope**: a broad permission to access a collection of endpoints - **abilities**: a fine grained permission system that allow actions.  The scopes and abilities are manageable in your System Admin Panel.  ### Multi-tenant Decidim is multi-tenant, and this API supports it. - The **`system` scope** endpoints are available in any tenant - The tenant `host` attribute will be used to guess which tenant you are requesting.   For example, given a tenant `example.org` and `foobar.org`, the endpoint   * `example.org/oauth/token` will ask a token for the example.org organization   * `foobar.org/oauth/token` for foobar.org.
 *
 * The version of the OpenAPI document: v0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface ActionURL
 */
export interface ActionURL {
  /**
   * Action Name
   * @type {string}
   * @memberof ActionURL
   */
  title: string;
  /**
   * Full URL
   * @type {string}
   * @memberof ActionURL
   */
  href: string;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof ActionURL
   */
  describedby?: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof ActionURL
   */
  hreflang?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ActionURL
   */
  rel: ActionURLRelEnum;
  /**
   *
   * @type {ActionURLMeta}
   * @memberof ActionURL
   */
  meta: ActionURLMeta;
}

export const ActionURLRelEnum = {
  Action: "action",
} as const;

export type ActionURLRelEnum =
  (typeof ActionURLRelEnum)[keyof typeof ActionURLRelEnum];

/**
 * @type ActionURLMeta
 * @export
 */
export type ActionURLMeta = MetaForReadRequest | MetaForWriteRequest;

/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
  /**
   * Error title, starting with HTTP Code, like 400: bad request
   * @type {string}
   * @memberof ApiError
   */
  error: string;
  /**
   * Error detail, mostly validation error
   * @type {string}
   * @memberof ApiError
   */
  error_description: string;
  /**
   * authentification state
   * @type {string}
   * @memberof ApiError
   */
  state?: string;
}
/**
 *
 * @export
 * @interface AttachedComponents
 */
export interface AttachedComponents {
  /**
   *
   * @type {Array<AttachedComponentsDataInner>}
   * @memberof AttachedComponents
   */
  data: Array<AttachedComponentsDataInner>;
  /**
   *
   * @type {AttachedComponentsMeta}
   * @memberof AttachedComponents
   */
  meta: AttachedComponentsMeta;
  /**
   *
   * @type {AttachedComponentsLinks}
   * @memberof AttachedComponents
   */
  links: AttachedComponentsLinks;
}
/**
 *
 * @export
 * @interface AttachedComponentsDataInner
 */
export interface AttachedComponentsDataInner {
  /**
   *
   * @type {string}
   * @memberof AttachedComponentsDataInner
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof AttachedComponentsDataInner
   */
  type: ComponentType;
}

/**
 *
 * @export
 * @interface AttachedComponentsLinks
 */
export interface AttachedComponentsLinks {
  /**
   *
   * @type {AttachedComponentsLinksSelf}
   * @memberof AttachedComponentsLinks
   */
  self: AttachedComponentsLinksSelf;
  /**
   *
   * @type {AttachedComponentsLinksRelated}
   * @memberof AttachedComponentsLinks
   */
  related?: AttachedComponentsLinksRelated;
}
/**
 * @type AttachedComponentsLinksRelated
 * Component List
 * @export
 */
export type AttachedComponentsLinksRelated = ActionURL | ResourceURL;

/**
 * @type AttachedComponentsLinksSelf
 * Space Detail
 * @export
 */
export type AttachedComponentsLinksSelf = ActionURL | ResourceURL;

/**
 *
 * @export
 * @interface AttachedComponentsMeta
 */
export interface AttachedComponentsMeta {
  /**
   * Total count for components association
   * @type {number}
   * @memberof AttachedComponentsMeta
   */
  count: number;
}
/**
 *
 * @export
 * @interface AvailableVotesInThisProposalComponentInner
 */
export interface AvailableVotesInThisProposalComponentInner {
  /**
   * Label to voting button
   * @type {string}
   * @memberof AvailableVotesInThisProposalComponentInner
   */
  label: string;
  /**
   * Value to add to the vote. 0 for abstention
   * @type {number}
   * @memberof AvailableVotesInThisProposalComponentInner
   */
  weight: number;
}
/**
 *
 * @export
 * @interface Blog
 */
export interface Blog {
  /**
   * Blog Post Id
   * @type {string}
   * @memberof Blog
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Blog
   */
  type: BlogTypeEnum;
  /**
   *
   * @type {BlogAttributes}
   * @memberof Blog
   */
  attributes: BlogAttributes;
  /**
   *
   * @type {BlogPostMetadata}
   * @memberof Blog
   */
  meta: BlogPostMetadata;
  /**
   *
   * @type {BlogPostLinks}
   * @memberof Blog
   */
  links: BlogPostLinks;
  /**
   *
   * @type {BlogPostRelationships}
   * @memberof Blog
   */
  relationships?: BlogPostRelationships;
}

export const BlogTypeEnum = {
  Blog: "blog",
} as const;

export type BlogTypeEnum = (typeof BlogTypeEnum)[keyof typeof BlogTypeEnum];

/**
 *
 * @export
 * @interface BlogAttributes
 */
export interface BlogAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogAttributes
   */
  body: TranslatedProp;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof BlogAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof BlogAttributes
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface BlogPostComponent
 */
export interface BlogPostComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof BlogPostComponent
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof BlogPostComponent
   */
  type: BlogPostComponentTypeEnum;
  /**
   *
   * @type {BlogPostComponentAttributes}
   * @memberof BlogPostComponent
   */
  attributes: BlogPostComponentAttributes;
  /**
   *
   * @type {ComponentMetadata1}
   * @memberof BlogPostComponent
   */
  meta: ComponentMetadata1;
  /**
   *
   * @type {ComponentLinks}
   * @memberof BlogPostComponent
   */
  links: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof BlogPostComponent
   */
  relationships?: ComponentRelationships;
}

export const BlogPostComponentTypeEnum = {
  BlogComponent: "blog_component",
} as const;

export type BlogPostComponentTypeEnum =
  (typeof BlogPostComponentTypeEnum)[keyof typeof BlogPostComponentTypeEnum];

/**
 *
 * @export
 * @interface BlogPostComponentAttributes
 */
export interface BlogPostComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogPostComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof BlogPostComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   * Associate space class name. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof BlogPostComponentAttributes
   */
  participatory_space_type: string;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof BlogPostComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof BlogPostComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof BlogPostComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof BlogPostComponentAttributes
   */
  manifest_name: BlogPostComponentAttributesManifestNameEnum;
}

export const BlogPostComponentAttributesManifestNameEnum = {
  Blogs: "blogs",
} as const;

export type BlogPostComponentAttributesManifestNameEnum =
  (typeof BlogPostComponentAttributesManifestNameEnum)[keyof typeof BlogPostComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface BlogPostLinks
 */
export interface BlogPostLinks {
  /**
   *
   * @type {BlogPostLinksSelf}
   * @memberof BlogPostLinks
   */
  self: BlogPostLinksSelf;
  /**
   *
   * @type {BlogPostLinksCollection}
   * @memberof BlogPostLinks
   */
  collection: BlogPostLinksCollection;
  /**
   *
   * @type {BlogPostLinksRelated}
   * @memberof BlogPostLinks
   */
  related: BlogPostLinksRelated;
  /**
   *
   * @type {BlogPostLinksPrev}
   * @memberof BlogPostLinks
   */
  prev: BlogPostLinksPrev | null;
  /**
   *
   * @type {BlogPostLinksNext}
   * @memberof BlogPostLinks
   */
  next: BlogPostLinksNext | null;
}
/**
 * @type BlogPostLinksCollection
 * Associate blog post list
 * @export
 */
export type BlogPostLinksCollection = ActionURL | ResourceURL;

/**
 * @type BlogPostLinksNext
 * Next blog post entry
 * @export
 */
export type BlogPostLinksNext = ActionURL | ResourceURL;

/**
 * @type BlogPostLinksPrev
 * Prev blog post entry
 * @export
 */
export type BlogPostLinksPrev = ActionURL | ResourceURL;

/**
 * @type BlogPostLinksRelated
 * Related Component
 * @export
 */
export type BlogPostLinksRelated = ActionURL | ResourceURL;

/**
 * @type BlogPostLinksSelf
 * Blog Post
 * @export
 */
export type BlogPostLinksSelf = ActionURL | ResourceURL;

/**
 *
 * @export
 * @interface BlogPostMetadata
 */
export interface BlogPostMetadata {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof BlogPostMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof BlogPostMetadata
   */
  scope?: number;
}
/**
 *
 * @export
 * @interface BlogPostRelationships
 */
export interface BlogPostRelationships {
  /**
   *
   * @type {BlogPostRelationshipsSpace}
   * @memberof BlogPostRelationships
   */
  space: BlogPostRelationshipsSpace;
  /**
   *
   * @type {BlogPostRelationshipsComponent}
   * @memberof BlogPostRelationships
   */
  component: BlogPostRelationshipsComponent;
}
/**
 *
 * @export
 * @interface BlogPostRelationshipsComponent
 */
export interface BlogPostRelationshipsComponent {
  /**
   *
   * @type {BlogPostRelationshipsComponentData}
   * @memberof BlogPostRelationshipsComponent
   */
  data: BlogPostRelationshipsComponentData;
}
/**
 *
 * @export
 * @interface BlogPostRelationshipsComponentData
 */
export interface BlogPostRelationshipsComponentData {
  /**
   * Component Id
   * @type {string}
   * @memberof BlogPostRelationshipsComponentData
   */
  id: string;
  /**
   *
   * @type {ComponentType}
   * @memberof BlogPostRelationshipsComponentData
   */
  type: ComponentType;
}

/**
 *
 * @export
 * @interface BlogPostRelationshipsSpace
 */
export interface BlogPostRelationshipsSpace {
  /**
   *
   * @type {BlogPostRelationshipsSpaceData}
   * @memberof BlogPostRelationshipsSpace
   */
  data: BlogPostRelationshipsSpaceData;
}
/**
 *
 * @export
 * @interface BlogPostRelationshipsSpaceData
 */
export interface BlogPostRelationshipsSpaceData {
  /**
   * Space Id
   * @type {string}
   * @memberof BlogPostRelationshipsSpaceData
   */
  id: string;
  /**
   * Space type
   * @type {string}
   * @memberof BlogPostRelationshipsSpaceData
   */
  type: BlogPostRelationshipsSpaceDataTypeEnum;
}

export const BlogPostRelationshipsSpaceDataTypeEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type BlogPostRelationshipsSpaceDataTypeEnum =
  (typeof BlogPostRelationshipsSpaceDataTypeEnum)[keyof typeof BlogPostRelationshipsSpaceDataTypeEnum];

/**
 *
 * @export
 * @interface BlogResponse
 */
export interface BlogResponse {
  /**
   *
   * @type {Blog}
   * @memberof BlogResponse
   */
  data: Blog;
}
/**
 *
 * @export
 * @interface BlogsResponse
 */
export interface BlogsResponse {
  /**
   *
   * @type {Array<Blog>}
   * @memberof BlogsResponse
   */
  data: Array<Blog>;
}
/**
 *
 * @export
 * @interface ClientCredential
 */
export interface ClientCredential {
  /**
   * Client Credential Flow, for **machine-to-machine**
   * @type {string}
   * @memberof ClientCredential
   */
  grant_type: ClientCredentialGrantTypeEnum;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof ClientCredential
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof ClientCredential
   */
  client_secret: string;
  /**
   * Requested scopes
   * @type {string}
   * @memberof ClientCredential
   */
  scope: ClientCredentialScopeEnum;
}

export const ClientCredentialGrantTypeEnum = {
  ClientCredentials: "client_credentials",
} as const;

export type ClientCredentialGrantTypeEnum =
  (typeof ClientCredentialGrantTypeEnum)[keyof typeof ClientCredentialGrantTypeEnum];
export const ClientCredentialScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  System: "system",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type ClientCredentialScopeEnum =
  (typeof ClientCredentialScopeEnum)[keyof typeof ClientCredentialScopeEnum];

/**
 * @type Component
 * @export
 */
export type Component =
  | BlogPostComponent
  | GenericComponent
  | ProposalComponent;

/**
 *
 * @export
 * @interface ComponentLinks
 */
export interface ComponentLinks {
  /**
   *
   * @type {ComponentLinksSelf}
   * @memberof ComponentLinks
   */
  self: ComponentLinksSelf;
  /**
   *
   * @type {ComponentLinksRelated}
   * @memberof ComponentLinks
   */
  related?: ComponentLinksRelated;
}
/**
 * @type ComponentLinksRelated
 * Space details API URL
 * @export
 */
export type ComponentLinksRelated = ActionURL | ResourceURL;

/**
 * @type ComponentLinksSelf
 * API URL to the component
 * @export
 */
export type ComponentLinksSelf = ActionURL | ResourceURL;

/**
 *
 * @export
 * @enum {string}
 */

export const ComponentManifest = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type ComponentManifest =
  (typeof ComponentManifest)[keyof typeof ComponentManifest];

/**
 *
 * @export
 * @interface ComponentMetadata
 */
export interface ComponentMetadata {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  published: boolean;
  /**
   * Component handle scopes?
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  scopes_enabled: boolean;
  /**
   * If the current user can create proposal (component allows, and user did not reach publication limit)
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  can_create_proposals: boolean;
  /**
   * If the current user can vote on the component
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  can_vote: boolean;
  /**
   * If the current user comment on the component
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  can_comment: boolean;
  /**
   * If the component needs a map to display its resources
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  geocoding_enabled: boolean;
  /**
   * If the component allows to attach files to resources
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  attachments_allowed: boolean;
  /**
   * If you can create collaborative draft for the proposal
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  collaborative_drafts_enabled?: boolean;
  /**
   * If you can comment on proposals
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  comments_enabled?: boolean;
  /**
   * Characters limit for comment
   * @type {number}
   * @memberof ComponentMetadata
   */
  comments_max_length?: number;
  /**
   * Default order of proposals
   * @type {string}
   * @memberof ComponentMetadata
   */
  default_sort_order?: ComponentMetadataDefaultSortOrderEnum;
  /**
   * If proposals can be official
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  official_proposals_enabled?: boolean;
  /**
   * If proposals are based on a text modification
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  participatory_texts_enabled?: boolean;
  /**
   * Time in minute participant can edit the proposal
   * @type {number}
   * @memberof ComponentMetadata
   */
  proposal_edit_before_minutes?: number;
  /**
   * Type of restriction for proposal edition
   * @type {string}
   * @memberof ComponentMetadata
   */
  proposal_edit_time?: ComponentMetadataProposalEditTimeEnum;
  /**
   * Max proposal per participant. No maximum if value is 0
   * @type {number}
   * @memberof ComponentMetadata
   */
  proposal_limit?: number;
  /**
   * If authorizations can be defined per proposal
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  resources_permissions_enabled?: boolean;
  /**
   * Threshold to compare similar proposals
   * @type {number}
   * @memberof ComponentMetadata
   */
  threshold_per_proposal?: number;
  /**
   * Max Number of vote per participant. 0 if no limit
   * @type {number}
   * @memberof ComponentMetadata
   */
  vote_limit: number;
  /**
   * If endorsements are enabled
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  endorsements_enabled?: boolean;
  /**
   * If votes on proposal are enabled
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  votes_enabled?: boolean;
  /**
   * If participant can create proposal are enabled
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  creation_enabled?: boolean;
  /**
   * If officials can answer proposals
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  proposal_answering_enabled?: boolean;
  /**
   * If participant can propose an amendment to a proposal
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  amendment_creation_enabled?: boolean;
  /**
   * If participant can react to an amendment of a proposal
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  amendment_reaction_enabled?: boolean;
  /**
   * If participant choose an amendment to replace their initial proposal
   * @type {boolean}
   * @memberof ComponentMetadata
   */
  amendment_promotion_enabled?: boolean;
  /**
   * Vote weight, if can_vote is true.
   * @type {Array<AvailableVotesInThisProposalComponentInner>}
   * @memberof ComponentMetadata
   */
  votes?: Array<AvailableVotesInThisProposalComponentInner>;
}

export const ComponentMetadataDefaultSortOrderEnum = {
  Random: "random",
  Recent: "recent",
  MostVoted: "most_voted",
  MostEndorsed: "most_endorsed",
  MostCommented: "most_commented",
  MostFollowed: "most_followed",
  WithMoreAuthors: "with_more_authors",
  Automatic: "automatic",
  Default: "default",
} as const;

export type ComponentMetadataDefaultSortOrderEnum =
  (typeof ComponentMetadataDefaultSortOrderEnum)[keyof typeof ComponentMetadataDefaultSortOrderEnum];
export const ComponentMetadataProposalEditTimeEnum = {
  Infinite: "infinite",
  Limited: "limited",
} as const;

export type ComponentMetadataProposalEditTimeEnum =
  (typeof ComponentMetadataProposalEditTimeEnum)[keyof typeof ComponentMetadataProposalEditTimeEnum];

/**
 *
 * @export
 * @interface ComponentMetadata1
 */
export interface ComponentMetadata1 {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Published component?
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  published: boolean;
  /**
   * Component handle scopes?
   * @type {boolean}
   * @memberof ComponentMetadata1
   */
  scopes_enabled: boolean;
}
/**
 * @type ComponentMetadataValue
 * @export
 */
export type ComponentMetadataValue = TranslatedProp | boolean | number | string;

/**
 *
 * @export
 * @interface ComponentRelationships
 */
export interface ComponentRelationships {
  /**
   *
   * @type {ComponentResourcesDescriptor}
   * @memberof ComponentRelationships
   */
  resources: ComponentResourcesDescriptor;
}
/**
 *
 * @export
 * @interface ComponentResource
 */
export interface ComponentResource {
  /**
   * Resource ID
   * @type {string}
   * @memberof ComponentResource
   */
  id: string;
  /**
   * Resource Type
   * @type {string}
   * @memberof ComponentResource
   */
  type: string;
}
/**
 *
 * @export
 * @interface ComponentResourceDescriptorMeta
 */
export interface ComponentResourceDescriptorMeta {
  /**
   * Total count of resources
   * @type {number}
   * @memberof ComponentResourceDescriptorMeta
   */
  count: number;
}
/**
 *
 * @export
 * @interface ComponentResourcesDescriptor
 */
export interface ComponentResourcesDescriptor {
  /**
   *
   * @type {Array<ComponentResource>}
   * @memberof ComponentResourcesDescriptor
   */
  data: Array<ComponentResource>;
  /**
   *
   * @type {ComponentResourceDescriptorMeta}
   * @memberof ComponentResourcesDescriptor
   */
  meta: ComponentResourceDescriptorMeta;
}
/**
 *
 * @export
 * @interface ComponentResponse
 */
export interface ComponentResponse {
  /**
   *
   * @type {Component}
   * @memberof ComponentResponse
   */
  data: Component;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComponentType = {
  PageComponent: "page_component",
  ProposalComponent: "proposal_component",
  MeetingComponent: "meeting_component",
  BudgetComponent: "budget_component",
  SurveyComponent: "survey_component",
  AccountabilityComponent: "accountability_component",
  DebateComponent: "debate_component",
  SortitionComponent: "sortition_component",
  BlogComponent: "blog_component",
  AwesomeMapComponent: "awesome_map_component",
  AwesomeIframeComponent: "awesome_iframe_component",
} as const;

export type ComponentType = (typeof ComponentType)[keyof typeof ComponentType];

/**
 *
 * @export
 * @interface ComponentsResponse
 */
export interface ComponentsResponse {
  /**
   *
   * @type {Array<Component>}
   * @memberof ComponentsResponse
   */
  data: Array<Component>;
}
/**
 *
 * @export
 * @interface DraftProposal
 */
export interface DraftProposal {
  /**
   * Draft Proposal Id
   * @type {string}
   * @memberof DraftProposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DraftProposal
   */
  type: DraftProposalTypeEnum;
  /**
   *
   * @type {DraftProposalAttributes}
   * @memberof DraftProposal
   */
  attributes: DraftProposalAttributes;
  /**
   *
   * @type {DraftPropositionMetadata}
   * @memberof DraftProposal
   */
  meta: DraftPropositionMetadata;
  /**
   *
   * @type {ProposalLinks1}
   * @memberof DraftProposal
   */
  links: ProposalLinks1;
  /**
   *
   * @type {ProposalRelationships1}
   * @memberof DraftProposal
   */
  relationships?: ProposalRelationships1;
}

export const DraftProposalTypeEnum = {
  DraftProposal: "draft_proposal",
} as const;

export type DraftProposalTypeEnum =
  (typeof DraftProposalTypeEnum)[keyof typeof DraftProposalTypeEnum];

/**
 *
 * @export
 * @interface DraftProposalAttributes
 */
export interface DraftProposalAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof DraftProposalAttributes
   */
  body: TranslatedProp;
  /**
   *
   * @type {DraftProposalAttributesErrors}
   * @memberof DraftProposalAttributes
   */
  errors?: DraftProposalAttributesErrors;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof DraftProposalAttributes
   */
  updated_at: string;
}
/**
 * Draft current errors
 * @export
 * @interface DraftProposalAttributesErrors
 */
export interface DraftProposalAttributesErrors {
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalAttributesErrors
   */
  title: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DraftProposalAttributesErrors
   */
  body: Array<string>;
}
/**
 *
 * @export
 * @interface DraftProposalResponse
 */
export interface DraftProposalResponse {
  /**
   *
   * @type {DraftProposal}
   * @memberof DraftProposalResponse
   */
  data: DraftProposal;
}
/**
 *
 * @export
 * @interface DraftPropositionMetadata
 */
export interface DraftPropositionMetadata {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Draft is published as it is now?
   * @type {boolean}
   * @memberof DraftPropositionMetadata
   */
  publishable: boolean;
  /**
   * Attached client_id
   * @type {string}
   * @memberof DraftPropositionMetadata
   */
  client_id: string;
  /**
   * Scope Id
   * @type {number}
   * @memberof DraftPropositionMetadata
   */
  scope?: number;
  /**
   * Editable field names
   * @type {Array<string>}
   * @memberof DraftPropositionMetadata
   */
  fields: Array<string>;
}
/**
 *
 * @export
 * @interface GenericComponent
 */
export interface GenericComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof GenericComponent
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof GenericComponent
   */
  type: GenericComponentTypeEnum;
  /**
   *
   * @type {GenericComponentAttributes}
   * @memberof GenericComponent
   */
  attributes: GenericComponentAttributes;
  /**
   *
   * @type {ComponentMetadata1}
   * @memberof GenericComponent
   */
  meta: ComponentMetadata1;
  /**
   *
   * @type {ComponentLinks}
   * @memberof GenericComponent
   */
  links: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof GenericComponent
   */
  relationships?: ComponentRelationships;
}

export const GenericComponentTypeEnum = {
  PageComponent: "page_component",
  MeetingComponent: "meeting_component",
  BudgetComponent: "budget_component",
  SurveyComponent: "survey_component",
  AccountabilityComponent: "accountability_component",
  DebateComponent: "debate_component",
  SortitionComponent: "sortition_component",
  AwesomeMapComponent: "awesome_map_component",
  AwesomeIframeComponent: "awesome_iframe_component",
} as const;

export type GenericComponentTypeEnum =
  (typeof GenericComponentTypeEnum)[keyof typeof GenericComponentTypeEnum];

/**
 *
 * @export
 * @interface GenericComponentAttributes
 */
export interface GenericComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof GenericComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof GenericComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   * Associate space class name. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  participatory_space_type: string;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof GenericComponentAttributes
   */
  manifest_name: GenericComponentAttributesManifestNameEnum;
}

export const GenericComponentAttributesManifestNameEnum = {
  Pages: "pages",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;

export type GenericComponentAttributesManifestNameEnum =
  (typeof GenericComponentAttributesManifestNameEnum)[keyof typeof GenericComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface Impersonation
 */
export interface Impersonation {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user impersonation**
   * @type {string}
   * @memberof Impersonation
   */
  grant_type: ImpersonationGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof Impersonation
   */
  auth_type: ImpersonationAuthTypeEnum;
  /**
   * User nickname, unique and at least 6 alphanumeric chars.
   * @type {string}
   * @memberof Impersonation
   */
  username?: string;
  /**
   * User id, will find over id and ignore username. Fails if register_on_missing=true.
   * @type {string}
   * @memberof Impersonation
   */
  id?: string;
  /**
   *
   * @type {UserImpersonationSettings}
   * @memberof Impersonation
   */
  meta?: UserImpersonationSettings;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof Impersonation
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof Impersonation
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof Impersonation
   */
  scope: ImpersonationScopeEnum;
}

export const ImpersonationGrantTypeEnum = {
  Password: "password",
} as const;

export type ImpersonationGrantTypeEnum =
  (typeof ImpersonationGrantTypeEnum)[keyof typeof ImpersonationGrantTypeEnum];
export const ImpersonationAuthTypeEnum = {
  Impersonate: "impersonate",
} as const;

export type ImpersonationAuthTypeEnum =
  (typeof ImpersonationAuthTypeEnum)[keyof typeof ImpersonationAuthTypeEnum];
export const ImpersonationScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type ImpersonationScopeEnum =
  (typeof ImpersonationScopeEnum)[keyof typeof ImpersonationScopeEnum];

/**
 *
 * @export
 * @interface IntrospectData
 */
export interface IntrospectData {
  /**
   * Access token id
   * @type {number}
   * @memberof IntrospectData
   */
  sub: number;
  /**
   * If the token can be used
   * @type {boolean}
   * @memberof IntrospectData
   */
  active: boolean;
  /**
   * Where this token can be used (organization host)
   * @type {string}
   * @memberof IntrospectData
   */
  aud: string;
  /**
   *
   * @type {ResourceDetails}
   * @memberof IntrospectData
   */
  resource?: ResourceDetails;
}
/**
 *
 * @export
 * @interface IntrospectTokenRequest
 */
export interface IntrospectTokenRequest {
  /**
   *
   * @type {string}
   * @memberof IntrospectTokenRequest
   */
  token: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Locale = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type Locale = (typeof Locale)[keyof typeof Locale];

/**
 *
 * @export
 * @interface Login
 */
export interface Login {
  /**
   * Resource Owner Password Credentials (ROPC) Flow, for **user login**
   * @type {string}
   * @memberof Login
   */
  grant_type: LoginGrantTypeEnum;
  /**
   * Type of ROPC
   * @type {string}
   * @memberof Login
   */
  auth_type: LoginAuthTypeEnum;
  /**
   * User nickname
   * @type {string}
   * @memberof Login
   */
  username: string;
  /**
   * User password
   * @type {string}
   * @memberof Login
   */
  password: string;
  /**
   * OAuth application Client Id
   * @type {string}
   * @memberof Login
   */
  client_id: string;
  /**
   * OAuth application Client Secret
   * @type {string}
   * @memberof Login
   */
  client_secret: string;
  /**
   * Request scopes
   * @type {string}
   * @memberof Login
   */
  scope: LoginScopeEnum;
}

export const LoginGrantTypeEnum = {
  Password: "password",
} as const;

export type LoginGrantTypeEnum =
  (typeof LoginGrantTypeEnum)[keyof typeof LoginGrantTypeEnum];
export const LoginAuthTypeEnum = {
  Login: "login",
} as const;

export type LoginAuthTypeEnum =
  (typeof LoginAuthTypeEnum)[keyof typeof LoginAuthTypeEnum];
export const LoginScopeEnum = {
  Public: "public",
  Spaces: "spaces",
  Proposals: "proposals",
  Meetings: "meetings",
  Debates: "debates",
  Pages: "pages",
  Blogs: "blogs",
  Oauth: "oauth",
} as const;

export type LoginScopeEnum =
  (typeof LoginScopeEnum)[keyof typeof LoginScopeEnum];

/**
 *
 * @export
 * @interface MagicLink
 */
export interface MagicLink {
  /**
   * Magic Token ID
   * @type {string}
   * @memberof MagicLink
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MagicLink
   */
  type: MagicLinkTypeEnum;
  /**
   *
   * @type {MagicLinkAttributes}
   * @memberof MagicLink
   */
  attributes: MagicLinkAttributes;
  /**
   *
   * @type {MagicLinkLinks}
   * @memberof MagicLink
   */
  links: MagicLinkLinks;
}

export const MagicLinkTypeEnum = {
  MagicLink: "magic_link",
} as const;

export type MagicLinkTypeEnum =
  (typeof MagicLinkTypeEnum)[keyof typeof MagicLinkTypeEnum];

/**
 *
 * @export
 * @interface MagicLinkAttributes
 */
export interface MagicLinkAttributes {
  /**
   * Magic Link Token
   * @type {string}
   * @memberof MagicLinkAttributes
   */
  token: string;
  /**
   * Magic Link description
   * @type {string}
   * @memberof MagicLinkAttributes
   */
  label: string;
}
/**
 *
 * @export
 * @interface MagicLinkAttributes1
 */
export interface MagicLinkAttributes1 {
  /**
   * Redirection destination
   * @type {string}
   * @memberof MagicLinkAttributes1
   */
  redirect_url: string;
  /**
   * Magic Link description
   * @type {string}
   * @memberof MagicLinkAttributes1
   */
  label: string;
}
/**
 *
 * @export
 * @interface MagicLinkLinks
 */
export interface MagicLinkLinks {
  /**
   *
   * @type {MagicLinkLinksSelf}
   * @memberof MagicLinkLinks
   */
  self: MagicLinkLinksSelf;
  /**
   *
   * @type {MagicLinkLinksSignIn}
   * @memberof MagicLinkLinks
   */
  sign_in: MagicLinkLinksSignIn;
}
/**
 *
 * @export
 * @interface MagicLinkLinks1
 */
export interface MagicLinkLinks1 {
  /**
   *
   * @type {MagicLinkLinksSignIn}
   * @memberof MagicLinkLinks1
   */
  self: MagicLinkLinksSignIn;
  /**
   *
   * @type {MagicLinkLinksSelf}
   * @memberof MagicLinkLinks1
   */
  magic_link: MagicLinkLinksSelf;
}
/**
 * @type MagicLinkLinksSelf
 * Magic Link Creation
 * @export
 */
export type MagicLinkLinksSelf = ActionURL | ResourceURL;

/**
 * @type MagicLinkLinksSignIn
 * Sign in
 * @export
 */
export type MagicLinkLinksSignIn = ActionURL | ResourceURL;

/**
 *
 * @export
 * @interface MagicLinkRedirect
 */
export interface MagicLinkRedirect {
  /**
   * Magic Token ID
   * @type {string}
   * @memberof MagicLinkRedirect
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MagicLinkRedirect
   */
  type: MagicLinkRedirectTypeEnum;
  /**
   *
   * @type {MagicLinkAttributes1}
   * @memberof MagicLinkRedirect
   */
  attributes: MagicLinkAttributes1;
  /**
   *
   * @type {MagicLinkLinks1}
   * @memberof MagicLinkRedirect
   */
  links: MagicLinkLinks1;
}

export const MagicLinkRedirectTypeEnum = {
  MagicLinkRedirect: "magic_link_redirect",
} as const;

export type MagicLinkRedirectTypeEnum =
  (typeof MagicLinkRedirectTypeEnum)[keyof typeof MagicLinkRedirectTypeEnum];

/**
 *
 * @export
 * @interface MagicLinkRedirectResponse
 */
export interface MagicLinkRedirectResponse {
  /**
   *
   * @type {MagicLinkRedirect}
   * @memberof MagicLinkRedirectResponse
   */
  data: MagicLinkRedirect;
}
/**
 *
 * @export
 * @interface MagicLinkResponse
 */
export interface MagicLinkResponse {
  /**
   *
   * @type {MagicLink}
   * @memberof MagicLinkResponse
   */
  data: MagicLink;
}
/**
 *
 * @export
 * @interface MagickLinkConfigurationPayload
 */
export interface MagickLinkConfigurationPayload {
  /**
   *
   * @type {MagickLinkConfigurationPayloadData}
   * @memberof MagickLinkConfigurationPayload
   */
  data?: MagickLinkConfigurationPayloadData;
}
/**
 * Optional payload to configure the magic link
 * @export
 * @interface MagickLinkConfigurationPayloadData
 */
export interface MagickLinkConfigurationPayloadData {
  /**
   * Redirect url after sign-in
   * @type {string}
   * @memberof MagickLinkConfigurationPayloadData
   */
  redirect_url: string;
}
/**
 *
 * @export
 * @interface MetaForReadRequest
 */
export interface MetaForReadRequest {
  /**
   * Component ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof MetaForReadRequest
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof MetaForReadRequest
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof MetaForReadRequest
   */
  resource_id?: string;
  /**
   * Action HTTP method
   * @type {string}
   * @memberof MetaForReadRequest
   */
  action_method: MetaForReadRequestActionMethodEnum;
}

export const MetaForReadRequestActionMethodEnum = {
  Get: "GET",
} as const;

export type MetaForReadRequestActionMethodEnum =
  (typeof MetaForReadRequestActionMethodEnum)[keyof typeof MetaForReadRequestActionMethodEnum];

/**
 *
 * @export
 * @interface MetaForWriteRequest
 */
export interface MetaForWriteRequest {
  /**
   * Component ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  resource_id?: string;
  /**
   * Action HTTP method
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_method: MetaForWriteRequestActionMethodEnum;
  /**
   * Encoding of the payload
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_enctype: MetaForWriteRequestActionEnctypeEnum;
  /**
   * URL to goes after submitting a valid request
   * @type {string}
   * @memberof MetaForWriteRequest
   */
  action_target?: string;
}

export const MetaForWriteRequestActionMethodEnum = {
  Post: "POST",
  Delete: "DELETE",
  Put: "PUT",
} as const;

export type MetaForWriteRequestActionMethodEnum =
  (typeof MetaForWriteRequestActionMethodEnum)[keyof typeof MetaForWriteRequestActionMethodEnum];
export const MetaForWriteRequestActionEnctypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  MultipartFormData: "multipart/form-data",
} as const;

export type MetaForWriteRequestActionEnctypeEnum =
  (typeof MetaForWriteRequestActionEnctypeEnum)[keyof typeof MetaForWriteRequestActionEnctypeEnum];

/**
 * @type OauthGrantParam
 * @export
 */
export type OauthGrantParam = ClientCredential | Impersonation | Login;

/**
 *
 * @export
 * @interface Organization
 */
export interface Organization {
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  type: OrganizationTypeEnum;
  /**
   *
   * @type {OrganizationAttributes}
   * @memberof Organization
   */
  attributes: OrganizationAttributes;
  /**
   *
   * @type {OrganizationMeta}
   * @memberof Organization
   */
  meta: OrganizationMeta;
}

export const OrganizationTypeEnum = {
  Organization: "organization",
} as const;

export type OrganizationTypeEnum =
  (typeof OrganizationTypeEnum)[keyof typeof OrganizationTypeEnum];

/**
 *
 * @export
 * @interface OrganizationAttributes
 */
export interface OrganizationAttributes {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof OrganizationAttributes
   */
  name: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof OrganizationAttributes
   */
  host: string;
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationAttributes
   */
  available_locales: Array<OrganizationAttributesAvailableLocalesEnum>;
  /**
   * defaut locale for the organization
   * @type {string}
   * @memberof OrganizationAttributes
   */
  default_locale: string;
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationAttributes
   */
  secondary_hosts?: Array<string>;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof OrganizationAttributes
   */
  updated_at: string;
}

export const OrganizationAttributesAvailableLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type OrganizationAttributesAvailableLocalesEnum =
  (typeof OrganizationAttributesAvailableLocalesEnum)[keyof typeof OrganizationAttributesAvailableLocalesEnum];

/**
 *
 * @export
 * @interface OrganizationMeta
 */
export interface OrganizationMeta {
  /**
   *
   * @type {Array<string>}
   * @memberof OrganizationMeta
   */
  locales: Array<OrganizationMetaLocalesEnum>;
}

export const OrganizationMetaLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type OrganizationMetaLocalesEnum =
  (typeof OrganizationMetaLocalesEnum)[keyof typeof OrganizationMetaLocalesEnum];

/**
 *
 * @export
 * @interface OrganizationsResponse
 */
export interface OrganizationsResponse {
  /**
   *
   * @type {Array<Organization>}
   * @memberof OrganizationsResponse
   */
  data: Array<Organization>;
}
/**
 * @type PasswordGrantParam
 * @export
 */
export type PasswordGrantParam = Impersonation | Login;

/**
 *
 * @export
 * @interface Proposal
 */
export interface Proposal {
  /**
   * Proposal Id
   * @type {string}
   * @memberof Proposal
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Proposal
   */
  type: ProposalTypeEnum;
  /**
   *
   * @type {BlogAttributes}
   * @memberof Proposal
   */
  attributes: BlogAttributes;
  /**
   *
   * @type {PropositionMetadata}
   * @memberof Proposal
   */
  meta: PropositionMetadata;
  /**
   *
   * @type {ProposalLinks}
   * @memberof Proposal
   */
  links: ProposalLinks;
  /**
   *
   * @type {ProposalRelationships}
   * @memberof Proposal
   */
  relationships?: ProposalRelationships;
}

export const ProposalTypeEnum = {
  Proposal: "proposal",
} as const;

export type ProposalTypeEnum =
  (typeof ProposalTypeEnum)[keyof typeof ProposalTypeEnum];

/**
 * A proposal component can host proposals from participants, and official proposals (proposals from the organization). This component have many metadatas that explain what are the restrictions regarding proposing, voting, commenting, amending or endorsing.   Features toggles:  - `can_create_proposals`: If participants can create proposals - `can_vote`: If participants can vote - `can_comment`: If participants can comments - .... and some more
 * @export
 * @interface ProposalComponent
 */
export interface ProposalComponent {
  /**
   * Component Id
   * @type {string}
   * @memberof ProposalComponent
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ProposalComponent
   */
  type: ProposalComponentTypeEnum;
  /**
   *
   * @type {ProposalComponentAttributes}
   * @memberof ProposalComponent
   */
  attributes: ProposalComponentAttributes;
  /**
   *
   * @type {ComponentMetadata}
   * @memberof ProposalComponent
   */
  meta: ComponentMetadata;
  /**
   *
   * @type {ComponentLinks}
   * @memberof ProposalComponent
   */
  links: ComponentLinks;
  /**
   *
   * @type {ComponentRelationships}
   * @memberof ProposalComponent
   */
  relationships?: ComponentRelationships;
}

export const ProposalComponentTypeEnum = {
  ProposalComponent: "proposal_component",
} as const;

export type ProposalComponentTypeEnum =
  (typeof ProposalComponentTypeEnum)[keyof typeof ProposalComponentTypeEnum];

/**
 *
 * @export
 * @interface ProposalComponentAttributes
 */
export interface ProposalComponentAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalComponentAttributes
   */
  name: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof ProposalComponentAttributes
   */
  global_announcement?: TranslatedProp;
  /**
   * Associate space class name. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  participatory_space_type: string;
  /**
   * Associate space id. Part of the polymorphic association (participatory_space_type,participatory_space_id)
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  participatory_space_id: string;
  /**
   * Creation date of the component
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  created_at: string;
  /**
   * Last update date of the component
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof ProposalComponentAttributes
   */
  manifest_name: ProposalComponentAttributesManifestNameEnum;
}

export const ProposalComponentAttributesManifestNameEnum = {
  Proposals: "proposals",
} as const;

export type ProposalComponentAttributesManifestNameEnum =
  (typeof ProposalComponentAttributesManifestNameEnum)[keyof typeof ProposalComponentAttributesManifestNameEnum];

/**
 *
 * @export
 * @interface ProposalComponentResponse
 */
export interface ProposalComponentResponse {
  /**
   *
   * @type {ProposalComponent}
   * @memberof ProposalComponentResponse
   */
  data: ProposalComponent;
}
/**
 *
 * @export
 * @interface ProposalComponentsResponse
 */
export interface ProposalComponentsResponse {
  /**
   *
   * @type {Array<ProposalComponent>}
   * @memberof ProposalComponentsResponse
   */
  data: Array<ProposalComponent>;
}
/**
 *
 * @export
 * @interface ProposalLinks
 */
export interface ProposalLinks {
  /**
   *
   * @type {ProposalLinksSelf}
   * @memberof ProposalLinks
   */
  self: ProposalLinksSelf;
  /**
   *
   * @type {ProposalLinksCollection}
   * @memberof ProposalLinks
   */
  collection: ProposalLinksCollection;
  /**
   *
   * @type {ProposalLinksRelated}
   * @memberof ProposalLinks
   */
  related: ProposalLinksRelated;
}
/**
 *
 * @export
 * @interface ProposalLinks1
 */
export interface ProposalLinks1 {
  /**
   *
   * @type {ProposalLinks1Self}
   * @memberof ProposalLinks1
   */
  self: ProposalLinks1Self;
  /**
   *
   * @type {ProposalLinks1Collection}
   * @memberof ProposalLinks1
   */
  collection: ProposalLinks1Collection;
  /**
   *
   * @type {ProposalLinksRelated}
   * @memberof ProposalLinks1
   */
  related: ProposalLinksRelated;
}
/**
 * @type ProposalLinks1Collection
 * Proposal List
 * @export
 */
export type ProposalLinks1Collection = ActionURL | ResourceURL;

/**
 * @type ProposalLinks1Self
 * Draft Proposal Details
 * @export
 */
export type ProposalLinks1Self = ActionURL | ResourceURL;

/**
 * @type ProposalLinksCollection
 * Proposal Lists
 * @export
 */
export type ProposalLinksCollection = ActionURL | ResourceURL;

/**
 * @type ProposalLinksRelated
 * Component Details
 * @export
 */
export type ProposalLinksRelated = ActionURL | ResourceURL;

/**
 * @type ProposalLinksSelf
 * Proposal Detail
 * @export
 */
export type ProposalLinksSelf = ActionURL | ResourceURL;

/**
 *
 * @export
 * @interface ProposalRelationships
 */
export interface ProposalRelationships {
  /**
   *
   * @type {ProposalRelationshipsSpace}
   * @memberof ProposalRelationships
   */
  space: ProposalRelationshipsSpace;
  /**
   *
   * @type {ProposalRelationshipsComponent}
   * @memberof ProposalRelationships
   */
  component: ProposalRelationshipsComponent;
  /**
   *
   * @type {ProposalRelationshipsAuthor}
   * @memberof ProposalRelationships
   */
  author: ProposalRelationshipsAuthor;
  /**
   *
   * @type {ProposalRelationshipsCoauthors}
   * @memberof ProposalRelationships
   */
  coauthors?: ProposalRelationshipsCoauthors;
}
/**
 *
 * @export
 * @interface ProposalRelationships1
 */
export interface ProposalRelationships1 {
  /**
   *
   * @type {ProposalRelationshipsSpace}
   * @memberof ProposalRelationships1
   */
  space: ProposalRelationshipsSpace;
  /**
   *
   * @type {BlogPostRelationshipsComponent}
   * @memberof ProposalRelationships1
   */
  component: BlogPostRelationshipsComponent;
  /**
   *
   * @type {ProposalRelationshipsAuthor}
   * @memberof ProposalRelationships1
   */
  author: ProposalRelationshipsAuthor;
  /**
   *
   * @type {ProposalRelationshipsCoauthors}
   * @memberof ProposalRelationships1
   */
  coauthors?: ProposalRelationshipsCoauthors;
}
/**
 *
 * @export
 * @interface ProposalRelationshipsAuthor
 */
export interface ProposalRelationshipsAuthor {
  /**
   * User Id
   * @type {string}
   * @memberof ProposalRelationshipsAuthor
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ProposalRelationshipsAuthor
   */
  type?: ProposalRelationshipsAuthorTypeEnum;
}

export const ProposalRelationshipsAuthorTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type ProposalRelationshipsAuthorTypeEnum =
  (typeof ProposalRelationshipsAuthorTypeEnum)[keyof typeof ProposalRelationshipsAuthorTypeEnum];

/**
 *
 * @export
 * @interface ProposalRelationshipsCoauthors
 */
export interface ProposalRelationshipsCoauthors {
  /**
   *
   * @type {Array<ProposalRelationshipsCoauthorsDataInner>}
   * @memberof ProposalRelationshipsCoauthors
   */
  data: Array<ProposalRelationshipsCoauthorsDataInner>;
}
/**
 *
 * @export
 * @interface ProposalRelationshipsCoauthorsDataInner
 */
export interface ProposalRelationshipsCoauthorsDataInner {
  /**
   * User Id
   * @type {string}
   * @memberof ProposalRelationshipsCoauthorsDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ProposalRelationshipsCoauthorsDataInner
   */
  type: ProposalRelationshipsCoauthorsDataInnerTypeEnum;
}

export const ProposalRelationshipsCoauthorsDataInnerTypeEnum = {
  User: "user",
  UserGroup: "user_group",
} as const;

export type ProposalRelationshipsCoauthorsDataInnerTypeEnum =
  (typeof ProposalRelationshipsCoauthorsDataInnerTypeEnum)[keyof typeof ProposalRelationshipsCoauthorsDataInnerTypeEnum];

/**
 *
 * @export
 * @interface ProposalRelationshipsComponent
 */
export interface ProposalRelationshipsComponent {
  /**
   *
   * @type {ProposalRelationshipsComponentData}
   * @memberof ProposalRelationshipsComponent
   */
  data: ProposalRelationshipsComponentData;
}
/**
 *
 * @export
 * @interface ProposalRelationshipsComponentData
 */
export interface ProposalRelationshipsComponentData {
  /**
   * Component Id
   * @type {string}
   * @memberof ProposalRelationshipsComponentData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ProposalRelationshipsComponentData
   */
  type: ProposalRelationshipsComponentDataTypeEnum;
}

export const ProposalRelationshipsComponentDataTypeEnum = {
  ProposalComponent: "proposal_component",
} as const;

export type ProposalRelationshipsComponentDataTypeEnum =
  (typeof ProposalRelationshipsComponentDataTypeEnum)[keyof typeof ProposalRelationshipsComponentDataTypeEnum];

/**
 *
 * @export
 * @interface ProposalRelationshipsSpace
 */
export interface ProposalRelationshipsSpace {
  /**
   *
   * @type {ProposalRelationshipsSpaceData}
   * @memberof ProposalRelationshipsSpace
   */
  data: ProposalRelationshipsSpaceData;
}
/**
 *
 * @export
 * @interface ProposalRelationshipsSpaceData
 */
export interface ProposalRelationshipsSpaceData {
  /**
   * Space Id
   * @type {string}
   * @memberof ProposalRelationshipsSpaceData
   */
  id: string;
  /**
   *
   * @type {SpaceType}
   * @memberof ProposalRelationshipsSpaceData
   */
  type: SpaceType;
}

/**
 *
 * @export
 * @interface ProposalResponse
 */
export interface ProposalResponse {
  /**
   *
   * @type {Proposal}
   * @memberof ProposalResponse
   */
  data: Proposal;
}
/**
 *
 * @export
 * @interface ProposalsResponse
 */
export interface ProposalsResponse {
  /**
   *
   * @type {Array<Proposal>}
   * @memberof ProposalsResponse
   */
  data: Array<Proposal>;
}
/**
 *
 * @export
 * @interface PropositionMetadata
 */
export interface PropositionMetadata {
  [key: string]: ComponentMetadataValue | any;

  /**
   * Published blog post?
   * @type {boolean}
   * @memberof PropositionMetadata
   */
  published: boolean;
  /**
   * Scope Id
   * @type {number}
   * @memberof PropositionMetadata
   */
  scope?: number;
  /**
   *
   * @type {PropositionMetadataVoted}
   * @memberof PropositionMetadata
   */
  voted?: PropositionMetadataVoted | null;
}
/**
 *
 * @export
 * @interface PropositionMetadataVoted
 */
export interface PropositionMetadataVoted {
  /**
   * Vote weight
   * @type {number}
   * @memberof PropositionMetadataVoted
   */
  weight: number;
}
/**
 *
 * @export
 * @interface ResourceDetails
 */
export interface ResourceDetails {
  /**
   * resource id
   * @type {string}
   * @memberof ResourceDetails
   */
  id: string;
  /**
   * resource type
   * @type {string}
   * @memberof ResourceDetails
   */
  type: ResourceDetailsTypeEnum;
  /**
   *
   * @type {ResourceDetailsAttributes}
   * @memberof ResourceDetails
   */
  attributes?: ResourceDetailsAttributes;
}

export const ResourceDetailsTypeEnum = {
  User: "user",
} as const;

export type ResourceDetailsTypeEnum =
  (typeof ResourceDetailsTypeEnum)[keyof typeof ResourceDetailsTypeEnum];

/**
 *
 * @export
 * @interface ResourceDetailsAttributes
 */
export interface ResourceDetailsAttributes {
  /**
   * Email
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  email: string;
  /**
   * Last update date
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  updated_at: string;
  /**
   * Creation date
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  created_at: string;
  /**
   * Personal url (social link, website, etc.)
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  personal_url?: string;
  /**
   * Current prefered locale
   * @type {string}
   * @memberof ResourceDetailsAttributes
   */
  locale?: ResourceDetailsAttributesLocaleEnum;
}

export const ResourceDetailsAttributesLocaleEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type ResourceDetailsAttributesLocaleEnum =
  (typeof ResourceDetailsAttributesLocaleEnum)[keyof typeof ResourceDetailsAttributesLocaleEnum];

/**
 *
 * @export
 * @interface ResourceURL
 */
export interface ResourceURL {
  /**
   * Full URL
   * @type {string}
   * @memberof ResourceURL
   */
  href: string;
  /**
   * Page Title
   * @type {string}
   * @memberof ResourceURL
   */
  title: string;
  /**
   * Available locales
   * @type {Array<string>}
   * @memberof ResourceURL
   */
  hreflang?: Array<string>;
  /**
   * JSONSchema URL describing the request
   * @type {string}
   * @memberof ResourceURL
   */
  describedby?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceURL
   */
  rel: ResourceURLRelEnum;
  /**
   *
   * @type {ResourceURLMeta}
   * @memberof ResourceURL
   */
  meta: ResourceURLMeta;
}

export const ResourceURLRelEnum = {
  PublicPage: "public_page",
  Resource: "resource",
} as const;

export type ResourceURLRelEnum =
  (typeof ResourceURLRelEnum)[keyof typeof ResourceURLRelEnum];

/**
 *
 * @export
 * @interface ResourceURLMeta
 */
export interface ResourceURLMeta {
  /**
   * Component ID
   * @type {string}
   * @memberof ResourceURLMeta
   */
  component_id?: string;
  /**
   * Component manifest
   * @type {string}
   * @memberof ResourceURLMeta
   */
  component_manifest?: string;
  /**
   * Space ID
   * @type {string}
   * @memberof ResourceURLMeta
   */
  space_id?: string;
  /**
   * Space Manifest
   * @type {string}
   * @memberof ResourceURLMeta
   */
  space_manifest?: string;
  /**
   * Resource ID
   * @type {string}
   * @memberof ResourceURLMeta
   */
  resource_id?: string;
}
/**
 *
 * @export
 * @interface SetUserDataRequest
 */
export interface SetUserDataRequest {
  /**
   * New value for the extended data at the given path
   * @type {object}
   * @memberof SetUserDataRequest
   */
  data: object;
  /**
   * object path, in dot style, like foo.bar. use \'.\' to update the whole user data
   * @type {string}
   * @memberof SetUserDataRequest
   */
  object_path?: string;
}
/**
 *
 * @export
 * @interface Space
 */
export interface Space {
  /**
   * Space Id
   * @type {string}
   * @memberof Space
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Space
   */
  type: SpaceTypeEnum;
  /**
   *
   * @type {SpaceAttributes}
   * @memberof Space
   */
  attributes: SpaceAttributes;
  /**
   *
   * @type {SpaceRelationships}
   * @memberof Space
   */
  relationships: SpaceRelationships;
  /**
   *
   * @type {SpaceLinks}
   * @memberof Space
   */
  links: SpaceLinks;
}

export const SpaceTypeEnum = {
  Space: "space",
} as const;

export type SpaceTypeEnum = (typeof SpaceTypeEnum)[keyof typeof SpaceTypeEnum];

/**
 *
 * @export
 * @interface SpaceAttributes
 */
export interface SpaceAttributes {
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  title: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  subtitle?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  short_description?: TranslatedProp;
  /**
   *
   * @type {TranslatedProp}
   * @memberof SpaceAttributes
   */
  description?: TranslatedProp;
  /**
   *
   * @type {SpaceManifest}
   * @memberof SpaceAttributes
   */
  manifest_name: SpaceManifest;
  /**
   *
   * @type {string}
   * @memberof SpaceAttributes
   */
  participatory_space_type?: string;
  /**
   * Space visibility
   * @type {string}
   * @memberof SpaceAttributes
   */
  visibility: SpaceAttributesVisibilityEnum;
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof SpaceAttributes
   */
  updated_at: string;
}

export const SpaceAttributesVisibilityEnum = {
  Public: "public",
  Transparent: "transparent",
  Private: "private",
} as const;

export type SpaceAttributesVisibilityEnum =
  (typeof SpaceAttributesVisibilityEnum)[keyof typeof SpaceAttributesVisibilityEnum];

/**
 *
 * @export
 * @interface SpaceLinks
 */
export interface SpaceLinks {
  /**
   *
   * @type {AttachedComponentsLinksSelf}
   * @memberof SpaceLinks
   */
  self: AttachedComponentsLinksSelf;
  /**
   *
   * @type {SpaceLinksRelated}
   * @memberof SpaceLinks
   */
  related: SpaceLinksRelated;
}
/**
 * @type SpaceLinksRelated
 * Organization Detail
 * @export
 */
export type SpaceLinksRelated = ActionURL | ResourceURL;

/**
 *
 * @export
 * @enum {string}
 */

export const SpaceManifest = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceManifest = (typeof SpaceManifest)[keyof typeof SpaceManifest];

/**
 *
 * @export
 * @interface SpaceRelationships
 */
export interface SpaceRelationships {
  /**
   *
   * @type {AttachedComponents}
   * @memberof SpaceRelationships
   */
  components: AttachedComponents;
}
/**
 *
 * @export
 * @interface SpaceResponse
 */
export interface SpaceResponse {
  /**
   *
   * @type {Space}
   * @memberof SpaceResponse
   */
  data: Space;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SpaceType = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;

export type SpaceType = (typeof SpaceType)[keyof typeof SpaceType];

/**
 *
 * @export
 * @interface SpacesResponse
 */
export interface SpacesResponse {
  /**
   *
   * @type {Array<Space>}
   * @memberof SpacesResponse
   */
  data: Array<Space>;
}
/**
 * Hash with translated data, key=locale value=translation
 * @export
 * @interface TranslatedProp
 */
export interface TranslatedProp {
  /**
   * Translation in en
   * @type {string}
   * @memberof TranslatedProp
   */
  en?: string;
  /**
   * Translation in bg
   * @type {string}
   * @memberof TranslatedProp
   */
  bg?: string;
  /**
   * Translation in ar
   * @type {string}
   * @memberof TranslatedProp
   */
  ar?: string;
  /**
   * Translation in ca
   * @type {string}
   * @memberof TranslatedProp
   */
  ca?: string;
  /**
   * Translation in cs
   * @type {string}
   * @memberof TranslatedProp
   */
  cs?: string;
  /**
   * Translation in da
   * @type {string}
   * @memberof TranslatedProp
   */
  da?: string;
  /**
   * Translation in de
   * @type {string}
   * @memberof TranslatedProp
   */
  de?: string;
  /**
   * Translation in el
   * @type {string}
   * @memberof TranslatedProp
   */
  el?: string;
  /**
   * Translation in eo
   * @type {string}
   * @memberof TranslatedProp
   */
  eo?: string;
  /**
   * Translation in es
   * @type {string}
   * @memberof TranslatedProp
   */
  es?: string;
  /**
   * Translation in es-MX
   * @type {string}
   * @memberof TranslatedProp
   */
  "es-MX"?: string;
  /**
   * Translation in es-PY
   * @type {string}
   * @memberof TranslatedProp
   */
  "es-PY"?: string;
  /**
   * Translation in et
   * @type {string}
   * @memberof TranslatedProp
   */
  et?: string;
  /**
   * Translation in eu
   * @type {string}
   * @memberof TranslatedProp
   */
  eu?: string;
  /**
   * Translation in fa
   * @type {string}
   * @memberof TranslatedProp
   */
  fa?: string;
  /**
   * Translation in fi-pl
   * @type {string}
   * @memberof TranslatedProp
   */
  "fi-pl"?: string;
  /**
   * Translation in fi
   * @type {string}
   * @memberof TranslatedProp
   */
  fi?: string;
  /**
   * Translation in fr
   * @type {string}
   * @memberof TranslatedProp
   */
  fr?: string;
  /**
   * Translation in fr-CA
   * @type {string}
   * @memberof TranslatedProp
   */
  "fr-CA"?: string;
  /**
   * Translation in ga
   * @type {string}
   * @memberof TranslatedProp
   */
  ga?: string;
  /**
   * Translation in gl
   * @type {string}
   * @memberof TranslatedProp
   */
  gl?: string;
  /**
   * Translation in hr
   * @type {string}
   * @memberof TranslatedProp
   */
  hr?: string;
  /**
   * Translation in hu
   * @type {string}
   * @memberof TranslatedProp
   */
  hu?: string;
  /**
   * Translation in id
   * @type {string}
   * @memberof TranslatedProp
   */
  id?: string;
  /**
   * Translation in is
   * @type {string}
   * @memberof TranslatedProp
   */
  is?: string;
  /**
   * Translation in it
   * @type {string}
   * @memberof TranslatedProp
   */
  it?: string;
  /**
   * Translation in ja
   * @type {string}
   * @memberof TranslatedProp
   */
  ja?: string;
  /**
   * Translation in ko
   * @type {string}
   * @memberof TranslatedProp
   */
  ko?: string;
  /**
   * Translation in lb
   * @type {string}
   * @memberof TranslatedProp
   */
  lb?: string;
  /**
   * Translation in lt
   * @type {string}
   * @memberof TranslatedProp
   */
  lt?: string;
  /**
   * Translation in lv
   * @type {string}
   * @memberof TranslatedProp
   */
  lv?: string;
  /**
   * Translation in mt
   * @type {string}
   * @memberof TranslatedProp
   */
  mt?: string;
  /**
   * Translation in nl
   * @type {string}
   * @memberof TranslatedProp
   */
  nl?: string;
  /**
   * Translation in no
   * @type {string}
   * @memberof TranslatedProp
   */
  no?: string;
  /**
   * Translation in pl
   * @type {string}
   * @memberof TranslatedProp
   */
  pl?: string;
  /**
   * Translation in pt
   * @type {string}
   * @memberof TranslatedProp
   */
  pt?: string;
  /**
   * Translation in pt-BR
   * @type {string}
   * @memberof TranslatedProp
   */
  "pt-BR"?: string;
  /**
   * Translation in ro
   * @type {string}
   * @memberof TranslatedProp
   */
  ro?: string;
  /**
   * Translation in ru
   * @type {string}
   * @memberof TranslatedProp
   */
  ru?: string;
  /**
   * Translation in sk
   * @type {string}
   * @memberof TranslatedProp
   */
  sk?: string;
  /**
   * Translation in sl
   * @type {string}
   * @memberof TranslatedProp
   */
  sl?: string;
  /**
   * Translation in sr
   * @type {string}
   * @memberof TranslatedProp
   */
  sr?: string;
  /**
   * Translation in sv
   * @type {string}
   * @memberof TranslatedProp
   */
  sv?: string;
  /**
   * Translation in tr
   * @type {string}
   * @memberof TranslatedProp
   */
  tr?: string;
  /**
   * Translation in uk
   * @type {string}
   * @memberof TranslatedProp
   */
  uk?: string;
  /**
   * Translation in vi
   * @type {string}
   * @memberof TranslatedProp
   */
  vi?: string;
  /**
   * Translation in zh-CN
   * @type {string}
   * @memberof TranslatedProp
   */
  "zh-CN"?: string;
  /**
   * Translation in zh-TW
   * @type {string}
   * @memberof TranslatedProp
   */
  "zh-TW"?: string;
}
/**
 *
 * @export
 * @interface UpdateDraftProposalRequest
 */
export interface UpdateDraftProposalRequest {
  /**
   *
   * @type {UpdateDraftProposalRequestData}
   * @memberof UpdateDraftProposalRequest
   */
  data: UpdateDraftProposalRequestData;
}
/**
 * Payload to update in the proposal
 * @export
 * @interface UpdateDraftProposalRequestData
 */
export interface UpdateDraftProposalRequestData {
  /**
   * Title of the draft
   * @type {string}
   * @memberof UpdateDraftProposalRequestData
   */
  title?: string;
  /**
   * Content of the draft
   * @type {string}
   * @memberof UpdateDraftProposalRequestData
   */
  body?: string;
  /**
   * Locale of the draft. default to user locale
   * @type {string}
   * @memberof UpdateDraftProposalRequestData
   */
  locale?: UpdateDraftProposalRequestDataLocaleEnum;
}

export const UpdateDraftProposalRequestDataLocaleEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;

export type UpdateDraftProposalRequestDataLocaleEnum =
  (typeof UpdateDraftProposalRequestDataLocaleEnum)[keyof typeof UpdateDraftProposalRequestDataLocaleEnum];

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  type: UserTypeEnum;
  /**
   *
   * @type {UserMeta}
   * @memberof User
   */
  meta?: UserMeta;
  /**
   *
   * @type {UserRelationships}
   * @memberof User
   */
  relationships?: UserRelationships;
  /**
   *
   * @type {UserAttributes}
   * @memberof User
   */
  attributes: UserAttributes;
}

export const UserTypeEnum = {
  User: "user",
} as const;

export type UserTypeEnum = (typeof UserTypeEnum)[keyof typeof UserTypeEnum];

/**
 *
 * @export
 * @interface UserAttributes
 */
export interface UserAttributes {
  /**
   * User name, use to display the Profile identity. Public
   * @type {string}
   * @memberof UserAttributes
   */
  name: string;
  /**
   * User nickname, unique identifier for the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  nickname: string;
  /**
   * Personal website URL or social link. Public
   * @type {string}
   * @memberof UserAttributes
   */
  personal_url?: string;
  /**
   * Short bio of the user. Public
   * @type {string}
   * @memberof UserAttributes
   */
  about?: string;
  /**
   *
   * @type {Locale}
   * @memberof UserAttributes
   */
  locale: Locale;
  /**
   * Email of the user. Private
   * @type {string}
   * @memberof UserAttributes
   */
  email?: string;
  /**
   * Additional data. Private
   * @type {{ [key: string]: any; }}
   * @memberof UserAttributes
   */
  extended_data: { [key: string]: any };
  /**
   * Creation date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  created_at: string;
  /**
   * Last update date, in ISO8601 format.
   * @type {string}
   * @memberof UserAttributes
   */
  updated_at: string;
}

/**
 *
 * @export
 * @interface UserExtendedDataResponse
 */
export interface UserExtendedDataResponse {
  /**
   * Hash of values attached to a user. These values won\'t be displayed to admins or users, consider this as an internal data payload.
   * @type {{ [key: string]: any; }}
   * @memberof UserExtendedDataResponse
   */
  data: { [key: string]: any };
}
/**
 * Impersonation Settings
 * @export
 * @interface UserImpersonationSettings
 */
export interface UserImpersonationSettings {
  /**
   * Register the user if it does not exists. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  register_on_missing?: boolean;
  /**
   * Accept the TOS on registration, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  accept_tos_on_register?: boolean;
  /**
   * Skip email confirmation on creation, used only if register_on_missing=true. Default: false
   * @type {boolean}
   * @memberof UserImpersonationSettings
   */
  skip_confirmation_on_register?: boolean;
  /**
   * User email to use on registration. used only if register_on_missing=true. Default to <username>@example.org
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  email?: string;
  /**
   * User name. Used only if register_on_missing=true. Default to username
   * @type {string}
   * @memberof UserImpersonationSettings
   */
  name?: string;
}
/**
 *
 * @export
 * @interface UserMeta
 */
export interface UserMeta {
  /**
   * If the user is blocked, and need to be unblocked to signin
   * @type {boolean}
   * @memberof UserMeta
   */
  blocked: boolean;
  /**
   * If the user is locked, and need to click on the mail link to unlock
   * @type {boolean}
   * @memberof UserMeta
   */
  locked: boolean;
}
/**
 *
 * @export
 * @interface UserRelationships
 */
export interface UserRelationships {
  /**
   *
   * @type {UserRelationshipsRoles}
   * @memberof UserRelationships
   */
  roles?: UserRelationshipsRoles;
}
/**
 *
 * @export
 * @interface UserRelationshipsRoles
 */
export interface UserRelationshipsRoles {
  /**
   *
   * @type {Array<UserRelationshipsRolesDataInner>}
   * @memberof UserRelationshipsRoles
   */
  data: Array<UserRelationshipsRolesDataInner>;
}
/**
 *
 * @export
 * @interface UserRelationshipsRolesDataInner
 */
export interface UserRelationshipsRolesDataInner {
  /**
   *
   * @type {string}
   * @memberof UserRelationshipsRolesDataInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UserRelationshipsRolesDataInner
   */
  type: UserRelationshipsRolesDataInnerTypeEnum;
}

export const UserRelationshipsRolesDataInnerTypeEnum = {
  UserRole: "user_role",
} as const;

export type UserRelationshipsRolesDataInnerTypeEnum =
  (typeof UserRelationshipsRolesDataInnerTypeEnum)[keyof typeof UserRelationshipsRolesDataInnerTypeEnum];

/**
 *
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof UsersResponse
   */
  data: Array<User>;
}
/**
 *
 * @export
 * @interface VoteProposalRequest
 */
export interface VoteProposalRequest {
  /**
   *
   * @type {VoteProposalRequestData}
   * @memberof VoteProposalRequest
   */
  data: VoteProposalRequestData;
}
/**
 * Payload to send your vote
 * @export
 * @interface VoteProposalRequestData
 */
export interface VoteProposalRequestData {
  /**
   * Weight for your vote
   * @type {number}
   * @memberof VoteProposalRequestData
   */
  weight: number;
}

/**
 * BlogsApi - axios parameter creator
 * @export
 */
export const BlogsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} postId
     * @param {Array<BlogLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog: async (
      spaceManifest: BlogSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      postId: number,
      locales?: Array<BlogLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("blog", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("blog", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("blog", "componentId", componentId);
      // verify required parameter 'postId' is not null or undefined
      assertParamExists("blog", "postId", postId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/blogs/{post_id}`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          )
          .replace(`{${"post_id"}}`, encodeURIComponent(String(postId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get blog post list
     * @summary Show a blog detail
     * @param {BlogsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<BlogsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs: async (
      spaceManifest: BlogsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<BlogsLocalesEnum>,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("blogs", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("blogs", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("blogs", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/blogs`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BlogsApi - functional programming interface
 * @export
 */
export const BlogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BlogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} postId
     * @param {Array<BlogLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blog(
      spaceManifest: BlogSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      postId: number,
      locales?: Array<BlogLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blog(
        spaceManifest,
        spaceId,
        componentId,
        postId,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blog"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get blog post list
     * @summary Show a blog detail
     * @param {BlogsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<BlogsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blogs(
      spaceManifest: BlogsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<BlogsLocalesEnum>,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blogs(
        spaceManifest,
        spaceId,
        componentId,
        locales,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BlogsApi.blogs"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BlogsApi - factory interface
 * @export
 */
export const BlogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BlogsApiFp(configuration);
  return {
    /**
     * Get blog post details
     * @summary Show a blog detail
     * @param {BlogsApiBlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blog(
      requestParameters: BlogsApiBlogRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogResponse> {
      return localVarFp
        .blog(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.postId,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get blog post list
     * @summary Show a blog detail
     * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blogs(
      requestParameters: BlogsApiBlogsRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BlogsResponse> {
      return localVarFp
        .blogs(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for blog operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogRequest
 */
export interface BlogsApiBlogRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof BlogsApiBlog
   */
  readonly spaceManifest: BlogSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly componentId: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlog
   */
  readonly postId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof BlogsApiBlog
   */
  readonly locales?: Array<BlogLocalesEnum>;
}

/**
 * Request parameters for blogs operation in BlogsApi.
 * @export
 * @interface BlogsApiBlogsRequest
 */
export interface BlogsApiBlogsRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof BlogsApiBlogs
   */
  readonly spaceManifest: BlogsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly componentId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof BlogsApiBlogs
   */
  readonly locales?: Array<BlogsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof BlogsApiBlogs
   */
  readonly perPage?: number;
}

/**
 * BlogsApi - object-oriented interface
 * @export
 * @class BlogsApi
 * @extends {BaseAPI}
 */
export class BlogsApi extends BaseAPI {
  /**
   * Get blog post details
   * @summary Show a blog detail
   * @param {BlogsApiBlogRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blog(
    requestParameters: BlogsApiBlogRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blog(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.postId,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get blog post list
   * @summary Show a blog detail
   * @param {BlogsApiBlogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogsApi
   */
  public blogs(
    requestParameters: BlogsApiBlogsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BlogsApiFp(this.configuration)
      .blogs(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const BlogSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogSpaceManifestEnum =
  (typeof BlogSpaceManifestEnum)[keyof typeof BlogSpaceManifestEnum];
/**
 * @export
 */
export const BlogLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogLocalesEnum =
  (typeof BlogLocalesEnum)[keyof typeof BlogLocalesEnum];
/**
 * @export
 */
export const BlogsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type BlogsSpaceManifestEnum =
  (typeof BlogsSpaceManifestEnum)[keyof typeof BlogsSpaceManifestEnum];
/**
 * @export
 */
export const BlogsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type BlogsLocalesEnum =
  (typeof BlogsLocalesEnum)[keyof typeof BlogsLocalesEnum];

/**
 * ComponentsApi - axios parameter creator
 * @export
 */
export const ComponentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * List or search proposal components of the organization
     * @summary List Proposal Components
     * @param {Array<ProposalComponentsLocalesEnum>} [locales]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponents: async (
      locales?: Array<ProposalComponentsLocalesEnum>,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/components/proposals`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ComponentsApi - functional programming interface
 * @export
 */
export const ComponentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ComponentsApiAxiosParamCreator(configuration);
  return {
    /**
     * List or search proposal components of the organization
     * @summary List Proposal Components
     * @param {Array<ProposalComponentsLocalesEnum>} [locales]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposalComponents(
      locales?: Array<ProposalComponentsLocalesEnum>,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalComponentsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.proposalComponents(
          locales,
          filterParticipatorySpaceIdIn,
          filterParticipatorySpaceIdEq,
          filterParticipatorySpaceTypeIn,
          filterParticipatorySpaceTypeEq,
          filterNameStart,
          filterNameEq,
          filterNameNotEq,
          filterNameMatches,
          page,
          perPage,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ComponentsApi.proposalComponents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ComponentsApi - factory interface
 * @export
 */
export const ComponentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ComponentsApiFp(configuration);
  return {
    /**
     * List or search proposal components of the organization
     * @summary List Proposal Components
     * @param {ComponentsApiProposalComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposalComponents(
      requestParameters: ComponentsApiProposalComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalComponentsResponse> {
      return localVarFp
        .proposalComponents(
          requestParameters.locales,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for proposalComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiProposalComponentsRequest
 */
export interface ComponentsApiProposalComponentsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly locales?: Array<ProposalComponentsLocalesEnum>;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterParticipatorySpaceTypeEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof ComponentsApiProposalComponents
   */
  readonly filterNameMatches?: string;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ComponentsApiProposalComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ComponentsApiProposalComponents
   */
  readonly perPage?: number;
}

/**
 * ComponentsApi - object-oriented interface
 * @export
 * @class ComponentsApi
 * @extends {BaseAPI}
 */
export class ComponentsApi extends BaseAPI {
  /**
   * List or search proposal components of the organization
   * @summary List Proposal Components
   * @param {ComponentsApiProposalComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public proposalComponents(
    requestParameters: ComponentsApiProposalComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ComponentsApiFp(this.configuration)
      .proposalComponents(
        requestParameters.locales,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ProposalComponentsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalComponentsLocalesEnum =
  (typeof ProposalComponentsLocalesEnum)[keyof typeof ProposalComponentsLocalesEnum];

/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      oauthGrantParam: OauthGrantParam,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oauthGrantParam' is not null or undefined
      assertParamExists("createToken", "oauthGrantParam", oauthGrantParam);
      const localVarPath = `/oauth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        oauthGrantParam,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken: async (
      introspectTokenRequest: IntrospectTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'introspectTokenRequest' is not null or undefined
      assertParamExists(
        "introspectToken",
        "introspectTokenRequest",
        introspectTokenRequest,
      );
      const localVarPath = `/oauth/introspect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        introspectTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OauthGrantParam} oauthGrantParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      oauthGrantParam: OauthGrantParam,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(
        oauthGrantParam,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.createToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {IntrospectTokenRequest} introspectTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async introspectToken(
      introspectTokenRequest: IntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntrospectData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.introspectToken(
        introspectTokenRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OAuthApi.introspectToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OAuthApiFp(configuration);
  return {
    /**
     * Create a oauth token for the given scopes
     * @summary Request a OAuth token through Client Credentials
     * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      requestParameters: OAuthApiCreateTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .createToken(requestParameters.oauthGrantParam, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get given oauth token details
     * @summary Introspect a OAuth token
     * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    introspectToken(
      requestParameters: OAuthApiIntrospectTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntrospectData> {
      return localVarFp
        .introspectToken(requestParameters.introspectTokenRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createToken operation in OAuthApi.
 * @export
 * @interface OAuthApiCreateTokenRequest
 */
export interface OAuthApiCreateTokenRequest {
  /**
   *
   * @type {OauthGrantParam}
   * @memberof OAuthApiCreateToken
   */
  readonly oauthGrantParam: OauthGrantParam;
}

/**
 * Request parameters for introspectToken operation in OAuthApi.
 * @export
 * @interface OAuthApiIntrospectTokenRequest
 */
export interface OAuthApiIntrospectTokenRequest {
  /**
   *
   * @type {IntrospectTokenRequest}
   * @memberof OAuthApiIntrospectToken
   */
  readonly introspectTokenRequest: IntrospectTokenRequest;
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
  /**
   * Create a oauth token for the given scopes
   * @summary Request a OAuth token through Client Credentials
   * @param {OAuthApiCreateTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public createToken(
    requestParameters: OAuthApiCreateTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .createToken(requestParameters.oauthGrantParam, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get given oauth token details
   * @summary Introspect a OAuth token
   * @param {OAuthApiIntrospectTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuthApi
   */
  public introspectToken(
    requestParameters: OAuthApiIntrospectTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuthApiFp(this.configuration)
      .introspectToken(requestParameters.introspectTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProposalsApi - axios parameter creator
 * @export
 */
export const ProposalsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {DraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal: async (
      spaceManifest: DraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("draftProposal", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("draftProposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("draftProposal", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Proposal detail
     * @summary Show a proposal detail
     * @param {ProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} proposalId
     * @param {Array<ProposalLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal: async (
      spaceManifest: ProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      proposalId: number,
      locales?: Array<ProposalLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("proposal", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("proposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("proposal", "componentId", componentId);
      // verify required parameter 'proposalId' is not null or undefined
      assertParamExists("proposal", "proposalId", proposalId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/{proposal_id}`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          )
          .replace(
            `{${"proposal_id"}}`,
            encodeURIComponent(String(proposalId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Proposals list
     * @summary Show proposal list
     * @param {ProposalsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<ProposalsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsOrderEnum} [order]
     * @param {ProposalsOrderDirectionEnum} [orderDirection]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals: async (
      spaceManifest: ProposalsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<ProposalsLocalesEnum>,
      page?: number,
      perPage?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightBlank?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("proposals", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("proposals", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("proposals", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (order !== undefined) {
        localVarQueryParameter["order"] = order;
      }

      if (orderDirection !== undefined) {
        localVarQueryParameter["order_direction"] = orderDirection;
      }

      if (filterVotedWeightIn) {
        localVarQueryParameter["filter[voted_weight_in][]"] =
          filterVotedWeightIn;
      }

      if (filterVotedWeightEq !== undefined) {
        localVarQueryParameter["filter[voted_weight_eq]"] = filterVotedWeightEq;
      }

      if (filterVotedWeightBlank !== undefined) {
        localVarQueryParameter["filter[voted_weight_blank]"] =
          filterVotedWeightBlank;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {PublishDraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishDraftProposal: async (
      spaceManifest: PublishDraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("publishDraftProposal", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("publishDraftProposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("publishDraftProposal", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft/publish`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Upsert a draft proposal
     * @param {UpdateDraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {UpdateDraftProposalRequest} updateDraftProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftProposal: async (
      spaceManifest: UpdateDraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      updateDraftProposalRequest: UpdateDraftProposalRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("updateDraftProposal", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("updateDraftProposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("updateDraftProposal", "componentId", componentId);
      // verify required parameter 'updateDraftProposalRequest' is not null or undefined
      assertParamExists(
        "updateDraftProposal",
        "updateDraftProposalRequest",
        updateDraftProposalRequest,
      );
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDraftProposalRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {VoteProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} proposalId
     * @param {VoteProposalRequest} voteProposalRequest
     * @param {Array<VoteProposalLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voteProposal: async (
      spaceManifest: VoteProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      proposalId: number,
      voteProposalRequest: VoteProposalRequest,
      locales?: Array<VoteProposalLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists("voteProposal", "spaceManifest", spaceManifest);
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("voteProposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("voteProposal", "componentId", componentId);
      // verify required parameter 'proposalId' is not null or undefined
      assertParamExists("voteProposal", "proposalId", proposalId);
      // verify required parameter 'voteProposalRequest' is not null or undefined
      assertParamExists(
        "voteProposal",
        "voteProposalRequest",
        voteProposalRequest,
      );
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/{proposal_id}/votes`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          )
          .replace(
            `{${"proposal_id"}}`,
            encodeURIComponent(String(proposalId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        voteProposalRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {WithdrawnDraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnDraftProposal: async (
      spaceManifest: WithdrawnDraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'spaceManifest' is not null or undefined
      assertParamExists(
        "withdrawnDraftProposal",
        "spaceManifest",
        spaceManifest,
      );
      // verify required parameter 'spaceId' is not null or undefined
      assertParamExists("withdrawnDraftProposal", "spaceId", spaceId);
      // verify required parameter 'componentId' is not null or undefined
      assertParamExists("withdrawnDraftProposal", "componentId", componentId);
      const localVarPath =
        `/public/{space_manifest}/{space_id}/{component_id}/proposals/draft`
          .replace(
            `{${"space_manifest"}}`,
            encodeURIComponent(String(spaceManifest)),
          )
          .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)))
          .replace(
            `{${"component_id"}}`,
            encodeURIComponent(String(componentId)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProposalsApi - functional programming interface
 * @export
 */
export const ProposalsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProposalsApiAxiosParamCreator(configuration);
  return {
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {DraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async draftProposal(
      spaceManifest: DraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.draftProposal(
        spaceManifest,
        spaceId,
        componentId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.draftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Proposal detail
     * @summary Show a proposal detail
     * @param {ProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} proposalId
     * @param {Array<ProposalLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposal(
      spaceManifest: ProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      proposalId: number,
      locales?: Array<ProposalLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposal(
        spaceManifest,
        spaceId,
        componentId,
        proposalId,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Proposals list
     * @summary Show proposal list
     * @param {ProposalsSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {Array<ProposalsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {ProposalsOrderEnum} [order]
     * @param {ProposalsOrderDirectionEnum} [orderDirection]
     * @param {Array<string>} [filterVotedWeightIn]
     * @param {string} [filterVotedWeightEq]
     * @param {boolean} [filterVotedWeightBlank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async proposals(
      spaceManifest: ProposalsSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      locales?: Array<ProposalsLocalesEnum>,
      page?: number,
      perPage?: number,
      order?: ProposalsOrderEnum,
      orderDirection?: ProposalsOrderDirectionEnum,
      filterVotedWeightIn?: Array<string>,
      filterVotedWeightEq?: string,
      filterVotedWeightBlank?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.proposals(
        spaceManifest,
        spaceId,
        componentId,
        locales,
        page,
        perPage,
        order,
        orderDirection,
        filterVotedWeightIn,
        filterVotedWeightEq,
        filterVotedWeightBlank,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.proposals"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {PublishDraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishDraftProposal(
      spaceManifest: PublishDraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.publishDraftProposal(
          spaceManifest,
          spaceId,
          componentId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.publishDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Upsert a draft proposal
     * @param {UpdateDraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {UpdateDraftProposalRequest} updateDraftProposalRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDraftProposal(
      spaceManifest: UpdateDraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      updateDraftProposalRequest: UpdateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateDraftProposal(
          spaceManifest,
          spaceId,
          componentId,
          updateDraftProposalRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.updateDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {VoteProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {number} proposalId
     * @param {VoteProposalRequest} voteProposalRequest
     * @param {Array<VoteProposalLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async voteProposal(
      spaceManifest: VoteProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      proposalId: number,
      voteProposalRequest: VoteProposalRequest,
      locales?: Array<VoteProposalLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ProposalResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.voteProposal(
        spaceManifest,
        spaceId,
        componentId,
        proposalId,
        voteProposalRequest,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.voteProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {WithdrawnDraftProposalSpaceManifestEnum} spaceManifest
     * @param {number} spaceId
     * @param {number} componentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async withdrawnDraftProposal(
      spaceManifest: WithdrawnDraftProposalSpaceManifestEnum,
      spaceId: number,
      componentId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DraftProposalResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.withdrawnDraftProposal(
          spaceManifest,
          spaceId,
          componentId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProposalsApi.withdrawnDraftProposal"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProposalsApi - factory interface
 * @export
 */
export const ProposalsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProposalsApiFp(configuration);
  return {
    /**
     * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
     * @summary Display a draft proposal
     * @param {ProposalsApiDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftProposal(
      requestParameters: ProposalsApiDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalResponse> {
      return localVarFp
        .draftProposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Proposal detail
     * @summary Show a proposal detail
     * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposal(
      requestParameters: ProposalsApiProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalResponse> {
      return localVarFp
        .proposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.proposalId,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Proposals list
     * @summary Show proposal list
     * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    proposals(
      requestParameters: ProposalsApiProposalsRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalsResponse> {
      return localVarFp
        .proposals(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.order,
          requestParameters.orderDirection,
          requestParameters.filterVotedWeightIn,
          requestParameters.filterVotedWeightEq,
          requestParameters.filterVotedWeightBlank,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Publish a draft proposal
     * @summary Publish a draft proposal
     * @param {ProposalsApiPublishDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishDraftProposal(
      requestParameters: ProposalsApiPublishDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalResponse> {
      return localVarFp
        .publishDraftProposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
     * @summary Upsert a draft proposal
     * @param {ProposalsApiUpdateDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftProposal(
      requestParameters: ProposalsApiUpdateDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalResponse> {
      return localVarFp
        .updateDraftProposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.updateDraftProposalRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Vote on a proposal
     * @summary Vote
     * @param {ProposalsApiVoteProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voteProposal(
      requestParameters: ProposalsApiVoteProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProposalResponse> {
      return localVarFp
        .voteProposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          requestParameters.proposalId,
          requestParameters.voteProposalRequest,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Withdrawn a draft proposal. This action cannot be undone.
     * @summary Withdrawn a draft proposal
     * @param {ProposalsApiWithdrawnDraftProposalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdrawnDraftProposal(
      requestParameters: ProposalsApiWithdrawnDraftProposalRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DraftProposalResponse> {
      return localVarFp
        .withdrawnDraftProposal(
          requestParameters.spaceManifest,
          requestParameters.spaceId,
          requestParameters.componentId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for draftProposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiDraftProposalRequest
 */
export interface ProposalsApiDraftProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiDraftProposal
   */
  readonly spaceManifest: DraftProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiDraftProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiDraftProposal
   */
  readonly componentId: number;
}

/**
 * Request parameters for proposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalRequest
 */
export interface ProposalsApiProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposal
   */
  readonly spaceManifest: ProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly componentId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposal
   */
  readonly proposalId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ProposalsApiProposal
   */
  readonly locales?: Array<ProposalLocalesEnum>;
}

/**
 * Request parameters for proposals operation in ProposalsApi.
 * @export
 * @interface ProposalsApiProposalsRequest
 */
export interface ProposalsApiProposalsRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiProposals
   */
  readonly spaceManifest: ProposalsSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly componentId: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ProposalsApiProposals
   */
  readonly locales?: Array<ProposalsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ProposalsApiProposals
   */
  readonly perPage?: number;

  /**
   *
   * @type {'published_at' | 'rand'}
   * @memberof ProposalsApiProposals
   */
  readonly order?: ProposalsOrderEnum;

  /**
   *
   * @type {'desc' | 'asc'}
   * @memberof ProposalsApiProposals
   */
  readonly orderDirection?: ProposalsOrderDirectionEnum;

  /**
   *
   * @type {Array<string>}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightEq?: string;

  /**
   *
   * @type {boolean}
   * @memberof ProposalsApiProposals
   */
  readonly filterVotedWeightBlank?: boolean;
}

/**
 * Request parameters for publishDraftProposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiPublishDraftProposalRequest
 */
export interface ProposalsApiPublishDraftProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiPublishDraftProposal
   */
  readonly spaceManifest: PublishDraftProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiPublishDraftProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiPublishDraftProposal
   */
  readonly componentId: number;
}

/**
 * Request parameters for updateDraftProposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiUpdateDraftProposalRequest
 */
export interface ProposalsApiUpdateDraftProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiUpdateDraftProposal
   */
  readonly spaceManifest: UpdateDraftProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiUpdateDraftProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiUpdateDraftProposal
   */
  readonly componentId: number;

  /**
   *
   * @type {UpdateDraftProposalRequest}
   * @memberof ProposalsApiUpdateDraftProposal
   */
  readonly updateDraftProposalRequest: UpdateDraftProposalRequest;
}

/**
 * Request parameters for voteProposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiVoteProposalRequest
 */
export interface ProposalsApiVoteProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiVoteProposal
   */
  readonly spaceManifest: VoteProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiVoteProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiVoteProposal
   */
  readonly componentId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiVoteProposal
   */
  readonly proposalId: number;

  /**
   *
   * @type {VoteProposalRequest}
   * @memberof ProposalsApiVoteProposal
   */
  readonly voteProposalRequest: VoteProposalRequest;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof ProposalsApiVoteProposal
   */
  readonly locales?: Array<VoteProposalLocalesEnum>;
}

/**
 * Request parameters for withdrawnDraftProposal operation in ProposalsApi.
 * @export
 * @interface ProposalsApiWithdrawnDraftProposalRequest
 */
export interface ProposalsApiWithdrawnDraftProposalRequest {
  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof ProposalsApiWithdrawnDraftProposal
   */
  readonly spaceManifest: WithdrawnDraftProposalSpaceManifestEnum;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiWithdrawnDraftProposal
   */
  readonly spaceId: number;

  /**
   *
   * @type {number}
   * @memberof ProposalsApiWithdrawnDraftProposal
   */
  readonly componentId: number;
}

/**
 * ProposalsApi - object-oriented interface
 * @export
 * @class ProposalsApi
 * @extends {BaseAPI}
 */
export class ProposalsApi extends BaseAPI {
  /**
   * Detail a draft proposal. Raise HTTP 404 error if no draft is created for now.
   * @summary Display a draft proposal
   * @param {ProposalsApiDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public draftProposal(
    requestParameters: ProposalsApiDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .draftProposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Proposal detail
   * @summary Show a proposal detail
   * @param {ProposalsApiProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposal(
    requestParameters: ProposalsApiProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.proposalId,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Proposals list
   * @summary Show proposal list
   * @param {ProposalsApiProposalsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public proposals(
    requestParameters: ProposalsApiProposalsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .proposals(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.order,
        requestParameters.orderDirection,
        requestParameters.filterVotedWeightIn,
        requestParameters.filterVotedWeightEq,
        requestParameters.filterVotedWeightBlank,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publish a draft proposal
   * @summary Publish a draft proposal
   * @param {ProposalsApiPublishDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public publishDraftProposal(
    requestParameters: ProposalsApiPublishDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .publishDraftProposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to create or update a draft proposal associated with your application ID. Drafts created via this API are not visible in the Decidim front-end, and drafts created from the Decidim application are not editable through the API. Therefore, any draft you create here is new and tied to your application\'s credentials.  ### Example Request  ```http PUT /public/assemblies/12/2319/proposals/draft Content-Type: application/json Authorization: Bearer YOUR_IMPERSONATION_TOKEN  {   \"title\": \"My valid title\" } ``` ## Access Requirements  * Authentication: This endpoint requires an impersonation token. You must create drafts on behalf of a participant; drafts cannot be created using a service token (credential_token).  ## Error Handling  * Field Errors: Only errors related to the fields you\'re updating will be returned. * Publishable Status: To determine if the draft is publishable, check the data.meta.publishable field in the response.  ### Example response ```json {   \"data\": {     \"id\": \"12345\",     \"type\": \"proposal\",     \"attributes\": {       \"title\": \"My valid title\",       \"body\": null     },     \"meta\": {       \"publishable\": false     }   } } ``` In this example, the title is valid, so the server returns a 200 OK status. However, since the body is blank, meta.publishable is false, indicating that the draft is not yet ready for publication.
   * @summary Upsert a draft proposal
   * @param {ProposalsApiUpdateDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public updateDraftProposal(
    requestParameters: ProposalsApiUpdateDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .updateDraftProposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.updateDraftProposalRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Vote on a proposal
   * @summary Vote
   * @param {ProposalsApiVoteProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public voteProposal(
    requestParameters: ProposalsApiVoteProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .voteProposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        requestParameters.proposalId,
        requestParameters.voteProposalRequest,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Withdrawn a draft proposal. This action cannot be undone.
   * @summary Withdrawn a draft proposal
   * @param {ProposalsApiWithdrawnDraftProposalRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProposalsApi
   */
  public withdrawnDraftProposal(
    requestParameters: ProposalsApiWithdrawnDraftProposalRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProposalsApiFp(this.configuration)
      .withdrawnDraftProposal(
        requestParameters.spaceManifest,
        requestParameters.spaceId,
        requestParameters.componentId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const DraftProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type DraftProposalSpaceManifestEnum =
  (typeof DraftProposalSpaceManifestEnum)[keyof typeof DraftProposalSpaceManifestEnum];
/**
 * @export
 */
export const ProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalSpaceManifestEnum =
  (typeof ProposalSpaceManifestEnum)[keyof typeof ProposalSpaceManifestEnum];
/**
 * @export
 */
export const ProposalLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalLocalesEnum =
  (typeof ProposalLocalesEnum)[keyof typeof ProposalLocalesEnum];
/**
 * @export
 */
export const ProposalsSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type ProposalsSpaceManifestEnum =
  (typeof ProposalsSpaceManifestEnum)[keyof typeof ProposalsSpaceManifestEnum];
/**
 * @export
 */
export const ProposalsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ProposalsLocalesEnum =
  (typeof ProposalsLocalesEnum)[keyof typeof ProposalsLocalesEnum];
/**
 * @export
 */
export const ProposalsOrderEnum = {
  PublishedAt: "published_at",
  Rand: "rand",
} as const;
export type ProposalsOrderEnum =
  (typeof ProposalsOrderEnum)[keyof typeof ProposalsOrderEnum];
/**
 * @export
 */
export const ProposalsOrderDirectionEnum = {
  Desc: "desc",
  Asc: "asc",
} as const;
export type ProposalsOrderDirectionEnum =
  (typeof ProposalsOrderDirectionEnum)[keyof typeof ProposalsOrderDirectionEnum];
/**
 * @export
 */
export const PublishDraftProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type PublishDraftProposalSpaceManifestEnum =
  (typeof PublishDraftProposalSpaceManifestEnum)[keyof typeof PublishDraftProposalSpaceManifestEnum];
/**
 * @export
 */
export const UpdateDraftProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type UpdateDraftProposalSpaceManifestEnum =
  (typeof UpdateDraftProposalSpaceManifestEnum)[keyof typeof UpdateDraftProposalSpaceManifestEnum];
/**
 * @export
 */
export const VoteProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type VoteProposalSpaceManifestEnum =
  (typeof VoteProposalSpaceManifestEnum)[keyof typeof VoteProposalSpaceManifestEnum];
/**
 * @export
 */
export const VoteProposalLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type VoteProposalLocalesEnum =
  (typeof VoteProposalLocalesEnum)[keyof typeof VoteProposalLocalesEnum];
/**
 * @export
 */
export const WithdrawnDraftProposalSpaceManifestEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type WithdrawnDraftProposalSpaceManifestEnum =
  (typeof WithdrawnDraftProposalSpaceManifestEnum)[keyof typeof WithdrawnDraftProposalSpaceManifestEnum];

/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get details of a component
     * @summary Show a Component
     * @param {number} id
     * @param {Array<ComponentLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    component: async (
      id: number,
      locales?: Array<ComponentLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("component", "id", id);
      const localVarPath = `/public/components/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search components of the organization
     * @summary List Components
     * @param {Array<ComponentsLocalesEnum>} [locales]
     * @param {Array<ComponentsFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<ComponentsFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    components: async (
      locales?: Array<ComponentsLocalesEnum>,
      filterManifestNameNotIn?: Array<ComponentsFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<ComponentsFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/components`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterParticipatorySpaceIdIn) {
        localVarQueryParameter["filter[participatory_space_id_in][]"] =
          filterParticipatorySpaceIdIn;
      }

      if (filterParticipatorySpaceIdEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_id_eq]"] =
          filterParticipatorySpaceIdEq;
      }

      if (filterParticipatorySpaceTypeIn) {
        localVarQueryParameter["filter[participatory_space_type_in][]"] =
          filterParticipatorySpaceTypeIn;
      }

      if (filterParticipatorySpaceTypeEq !== undefined) {
        localVarQueryParameter["filter[participatory_space_type_eq]"] =
          filterParticipatorySpaceTypeEq;
      }

      if (filterNameStart !== undefined) {
        localVarQueryParameter["filter[name_start]"] = filterNameStart;
      }

      if (filterNameEq !== undefined) {
        localVarQueryParameter["filter[name_eq]"] = filterNameEq;
      }

      if (filterNameNotEq !== undefined) {
        localVarQueryParameter["filter[name_not_eq]"] = filterNameNotEq;
      }

      if (filterNameMatches !== undefined) {
        localVarQueryParameter["filter[name_matches]"] = filterNameMatches;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get detail of a space given its manifest and id
     * @summary Show Participatory Space
     * @param {number} id
     * @param {SpaceManifestNameEnum} manifestName
     * @param {Array<SpaceLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    space: async (
      id: number,
      manifestName: SpaceManifestNameEnum,
      locales?: Array<SpaceLocalesEnum>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("space", "id", id);
      // verify required parameter 'manifestName' is not null or undefined
      assertParamExists("space", "manifestName", manifestName);
      const localVarPath = `/public/{manifest_name}/{id}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(
          `{${"manifest_name"}}`,
          encodeURIComponent(String(manifestName)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary List Participatory Spaces
     * @param {Array<SpacesLocalesEnum>} [locales]
     * @param {Array<SpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleNotStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {string} [filterTitleDoesNotMatch]
     * @param {SpacesFilterTitlePresentEnum} [filterTitlePresent]
     * @param {boolean} [filterTitleBlank]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    spaces: async (
      locales?: Array<SpacesLocalesEnum>,
      filterManifestNameNotIn?: Array<SpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SpacesFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleNotStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleDoesNotMatch?: string,
      filterTitlePresent?: SpacesFilterTitlePresentEnum,
      filterTitleBlank?: boolean,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/spaces`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (filterManifestNameNotIn) {
        localVarQueryParameter["filter[manifest_name_not_in][]"] =
          filterManifestNameNotIn;
      }

      if (filterManifestNameIn) {
        localVarQueryParameter["filter[manifest_name_in][]"] =
          filterManifestNameIn;
      }

      if (filterManifestNameEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_eq]"] =
          filterManifestNameEq;
      }

      if (filterManifestNameNotEq !== undefined) {
        localVarQueryParameter["filter[manifest_name_not_eq]"] =
          filterManifestNameNotEq;
      }

      if (filterTitleNotIn) {
        localVarQueryParameter["filter[title_not_in][]"] = filterTitleNotIn;
      }

      if (filterTitleIn) {
        localVarQueryParameter["filter[title_in][]"] = filterTitleIn;
      }

      if (filterTitleStart !== undefined) {
        localVarQueryParameter["filter[title_start]"] = filterTitleStart;
      }

      if (filterTitleNotStart !== undefined) {
        localVarQueryParameter["filter[title_not_start]"] = filterTitleNotStart;
      }

      if (filterTitleEq !== undefined) {
        localVarQueryParameter["filter[title_eq]"] = filterTitleEq;
      }

      if (filterTitleNotEq !== undefined) {
        localVarQueryParameter["filter[title_not_eq]"] = filterTitleNotEq;
      }

      if (filterTitleMatches !== undefined) {
        localVarQueryParameter["filter[title_matches]"] = filterTitleMatches;
      }

      if (filterTitleDoesNotMatch !== undefined) {
        localVarQueryParameter["filter[title_does_not_match]"] =
          filterTitleDoesNotMatch;
      }

      if (filterTitlePresent !== undefined) {
        localVarQueryParameter["filter[title_present]"] = filterTitlePresent;
      }

      if (filterTitleBlank !== undefined) {
        localVarQueryParameter["filter[title_blank]"] = filterTitleBlank;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration);
  return {
    /**
     * Get details of a component
     * @summary Show a Component
     * @param {number} id
     * @param {Array<ComponentLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async component(
      id: number,
      locales?: Array<ComponentLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ComponentResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.component(
        id,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.component"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search components of the organization
     * @summary List Components
     * @param {Array<ComponentsLocalesEnum>} [locales]
     * @param {Array<ComponentsFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<ComponentsFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterParticipatorySpaceIdIn]
     * @param {string} [filterParticipatorySpaceIdEq]
     * @param {Array<string>} [filterParticipatorySpaceTypeIn]
     * @param {string} [filterParticipatorySpaceTypeEq]
     * @param {string} [filterNameStart]
     * @param {string} [filterNameEq]
     * @param {string} [filterNameNotEq]
     * @param {string} [filterNameMatches]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async components(
      locales?: Array<ComponentsLocalesEnum>,
      filterManifestNameNotIn?: Array<ComponentsFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<ComponentsFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterParticipatorySpaceIdIn?: Array<string>,
      filterParticipatorySpaceIdEq?: string,
      filterParticipatorySpaceTypeIn?: Array<string>,
      filterParticipatorySpaceTypeEq?: string,
      filterNameStart?: string,
      filterNameEq?: string,
      filterNameNotEq?: string,
      filterNameMatches?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ComponentsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.components(
        locales,
        filterManifestNameNotIn,
        filterManifestNameIn,
        filterManifestNameEq,
        filterManifestNameNotEq,
        filterParticipatorySpaceIdIn,
        filterParticipatorySpaceIdEq,
        filterParticipatorySpaceTypeIn,
        filterParticipatorySpaceTypeEq,
        filterNameStart,
        filterNameEq,
        filterNameNotEq,
        filterNameMatches,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.components"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get detail of a space given its manifest and id
     * @summary Show Participatory Space
     * @param {number} id
     * @param {SpaceManifestNameEnum} manifestName
     * @param {Array<SpaceLocalesEnum>} [locales]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async space(
      id: number,
      manifestName: SpaceManifestNameEnum,
      locales?: Array<SpaceLocalesEnum>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpaceResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.space(
        id,
        manifestName,
        locales,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.space"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary List Participatory Spaces
     * @param {Array<SpacesLocalesEnum>} [locales]
     * @param {Array<SpacesFilterManifestNameNotInEnum>} [filterManifestNameNotIn]
     * @param {Array<SpacesFilterManifestNameInEnum>} [filterManifestNameIn]
     * @param {string} [filterManifestNameEq]
     * @param {string} [filterManifestNameNotEq]
     * @param {Array<string>} [filterTitleNotIn]
     * @param {Array<string>} [filterTitleIn]
     * @param {string} [filterTitleStart]
     * @param {string} [filterTitleNotStart]
     * @param {string} [filterTitleEq]
     * @param {string} [filterTitleNotEq]
     * @param {string} [filterTitleMatches]
     * @param {string} [filterTitleDoesNotMatch]
     * @param {SpacesFilterTitlePresentEnum} [filterTitlePresent]
     * @param {boolean} [filterTitleBlank]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async spaces(
      locales?: Array<SpacesLocalesEnum>,
      filterManifestNameNotIn?: Array<SpacesFilterManifestNameNotInEnum>,
      filterManifestNameIn?: Array<SpacesFilterManifestNameInEnum>,
      filterManifestNameEq?: string,
      filterManifestNameNotEq?: string,
      filterTitleNotIn?: Array<string>,
      filterTitleIn?: Array<string>,
      filterTitleStart?: string,
      filterTitleNotStart?: string,
      filterTitleEq?: string,
      filterTitleNotEq?: string,
      filterTitleMatches?: string,
      filterTitleDoesNotMatch?: string,
      filterTitlePresent?: SpacesFilterTitlePresentEnum,
      filterTitleBlank?: boolean,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpacesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.spaces(
        locales,
        filterManifestNameNotIn,
        filterManifestNameIn,
        filterManifestNameEq,
        filterManifestNameNotEq,
        filterTitleNotIn,
        filterTitleIn,
        filterTitleStart,
        filterTitleNotStart,
        filterTitleEq,
        filterTitleNotEq,
        filterTitleMatches,
        filterTitleDoesNotMatch,
        filterTitlePresent,
        filterTitleBlank,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PublicApi.spaces"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PublicApiFp(configuration);
  return {
    /**
     * Get details of a component
     * @summary Show a Component
     * @param {PublicApiComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    component(
      requestParameters: PublicApiComponentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComponentResponse> {
      return localVarFp
        .component(requestParameters.id, requestParameters.locales, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search components of the organization
     * @summary List Components
     * @param {PublicApiComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    components(
      requestParameters: PublicApiComponentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComponentsResponse> {
      return localVarFp
        .components(
          requestParameters.locales,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterParticipatorySpaceIdIn,
          requestParameters.filterParticipatorySpaceIdEq,
          requestParameters.filterParticipatorySpaceTypeIn,
          requestParameters.filterParticipatorySpaceTypeEq,
          requestParameters.filterNameStart,
          requestParameters.filterNameEq,
          requestParameters.filterNameNotEq,
          requestParameters.filterNameMatches,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get detail of a space given its manifest and id
     * @summary Show Participatory Space
     * @param {PublicApiSpaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    space(
      requestParameters: PublicApiSpaceRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpaceResponse> {
      return localVarFp
        .space(
          requestParameters.id,
          requestParameters.manifestName,
          requestParameters.locales,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
     * @summary List Participatory Spaces
     * @param {PublicApiSpacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    spaces(
      requestParameters: PublicApiSpacesRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SpacesResponse> {
      return localVarFp
        .spaces(
          requestParameters.locales,
          requestParameters.filterManifestNameNotIn,
          requestParameters.filterManifestNameIn,
          requestParameters.filterManifestNameEq,
          requestParameters.filterManifestNameNotEq,
          requestParameters.filterTitleNotIn,
          requestParameters.filterTitleIn,
          requestParameters.filterTitleStart,
          requestParameters.filterTitleNotStart,
          requestParameters.filterTitleEq,
          requestParameters.filterTitleNotEq,
          requestParameters.filterTitleMatches,
          requestParameters.filterTitleDoesNotMatch,
          requestParameters.filterTitlePresent,
          requestParameters.filterTitleBlank,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for component operation in PublicApi.
 * @export
 * @interface PublicApiComponentRequest
 */
export interface PublicApiComponentRequest {
  /**
   *
   * @type {number}
   * @memberof PublicApiComponent
   */
  readonly id: number;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiComponent
   */
  readonly locales?: Array<ComponentLocalesEnum>;
}

/**
 * Request parameters for components operation in PublicApi.
 * @export
 * @interface PublicApiComponentsRequest
 */
export interface PublicApiComponentsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiComponents
   */
  readonly locales?: Array<ComponentsLocalesEnum>;

  /**
   *
   * @type {Array<'pages' | 'proposals' | 'meetings' | 'budgets' | 'surveys' | 'accountability' | 'debates' | 'sortitions' | 'blogs' | 'awesome_map' | 'awesome_iframe'>}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameNotIn?: Array<ComponentsFilterManifestNameNotInEnum>;

  /**
   *
   * @type {Array<'pages' | 'proposals' | 'meetings' | 'budgets' | 'surveys' | 'accountability' | 'debates' | 'sortitions' | 'blogs' | 'awesome_map' | 'awesome_iframe'>}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameIn?: Array<ComponentsFilterManifestNameInEnum>;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterManifestNameNotEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceIdIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceIdEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceTypeIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterParticipatorySpaceTypeEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameStart?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiComponents
   */
  readonly filterNameMatches?: string;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof PublicApiComponents
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof PublicApiComponents
   */
  readonly perPage?: number;
}

/**
 * Request parameters for space operation in PublicApi.
 * @export
 * @interface PublicApiSpaceRequest
 */
export interface PublicApiSpaceRequest {
  /**
   *
   * @type {number}
   * @memberof PublicApiSpace
   */
  readonly id: number;

  /**
   *
   * @type {'participatory_processes' | 'assemblies'}
   * @memberof PublicApiSpace
   */
  readonly manifestName: SpaceManifestNameEnum;

  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiSpace
   */
  readonly locales?: Array<SpaceLocalesEnum>;
}

/**
 * Request parameters for spaces operation in PublicApi.
 * @export
 * @interface PublicApiSpacesRequest
 */
export interface PublicApiSpacesRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof PublicApiSpaces
   */
  readonly locales?: Array<SpacesLocalesEnum>;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameNotIn?: Array<SpacesFilterManifestNameNotInEnum>;

  /**
   *
   * @type {Array<'participatory_processes' | 'assemblies'>}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameIn?: Array<SpacesFilterManifestNameInEnum>;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterManifestNameNotEq?: string;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleStart?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleNotStart?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleMatches?: string;

  /**
   *
   * @type {string}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleDoesNotMatch?: string;

  /**
   *
   * @type {'1' | '0'}
   * @memberof PublicApiSpaces
   */
  readonly filterTitlePresent?: SpacesFilterTitlePresentEnum;

  /**
   *
   * @type {boolean}
   * @memberof PublicApiSpaces
   */
  readonly filterTitleBlank?: boolean;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof PublicApiSpaces
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof PublicApiSpaces
   */
  readonly perPage?: number;
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
  /**
   * Get details of a component
   * @summary Show a Component
   * @param {PublicApiComponentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public component(
    requestParameters: PublicApiComponentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .component(requestParameters.id, requestParameters.locales, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search components of the organization
   * @summary List Components
   * @param {PublicApiComponentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public components(
    requestParameters: PublicApiComponentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .components(
        requestParameters.locales,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterParticipatorySpaceIdIn,
        requestParameters.filterParticipatorySpaceIdEq,
        requestParameters.filterParticipatorySpaceTypeIn,
        requestParameters.filterParticipatorySpaceTypeEq,
        requestParameters.filterNameStart,
        requestParameters.filterNameEq,
        requestParameters.filterNameNotEq,
        requestParameters.filterNameMatches,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get detail of a space given its manifest and id
   * @summary Show Participatory Space
   * @param {PublicApiSpaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public space(
    requestParameters: PublicApiSpaceRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .space(
        requestParameters.id,
        requestParameters.manifestName,
        requestParameters.locales,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search spaces of the organization. Can be processes, assemblies, or any other registred participatory space.
   * @summary List Participatory Spaces
   * @param {PublicApiSpacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public spaces(
    requestParameters: PublicApiSpacesRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .spaces(
        requestParameters.locales,
        requestParameters.filterManifestNameNotIn,
        requestParameters.filterManifestNameIn,
        requestParameters.filterManifestNameEq,
        requestParameters.filterManifestNameNotEq,
        requestParameters.filterTitleNotIn,
        requestParameters.filterTitleIn,
        requestParameters.filterTitleStart,
        requestParameters.filterTitleNotStart,
        requestParameters.filterTitleEq,
        requestParameters.filterTitleNotEq,
        requestParameters.filterTitleMatches,
        requestParameters.filterTitleDoesNotMatch,
        requestParameters.filterTitlePresent,
        requestParameters.filterTitleBlank,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ComponentLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ComponentLocalesEnum =
  (typeof ComponentLocalesEnum)[keyof typeof ComponentLocalesEnum];
/**
 * @export
 */
export const ComponentsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type ComponentsLocalesEnum =
  (typeof ComponentsLocalesEnum)[keyof typeof ComponentsLocalesEnum];
/**
 * @export
 */
export const ComponentsFilterManifestNameNotInEnum = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;
export type ComponentsFilterManifestNameNotInEnum =
  (typeof ComponentsFilterManifestNameNotInEnum)[keyof typeof ComponentsFilterManifestNameNotInEnum];
/**
 * @export
 */
export const ComponentsFilterManifestNameInEnum = {
  Pages: "pages",
  Proposals: "proposals",
  Meetings: "meetings",
  Budgets: "budgets",
  Surveys: "surveys",
  Accountability: "accountability",
  Debates: "debates",
  Sortitions: "sortitions",
  Blogs: "blogs",
  AwesomeMap: "awesome_map",
  AwesomeIframe: "awesome_iframe",
} as const;
export type ComponentsFilterManifestNameInEnum =
  (typeof ComponentsFilterManifestNameInEnum)[keyof typeof ComponentsFilterManifestNameInEnum];
/**
 * @export
 */
export const SpaceManifestNameEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SpaceManifestNameEnum =
  (typeof SpaceManifestNameEnum)[keyof typeof SpaceManifestNameEnum];
/**
 * @export
 */
export const SpaceLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type SpaceLocalesEnum =
  (typeof SpaceLocalesEnum)[keyof typeof SpaceLocalesEnum];
/**
 * @export
 */
export const SpacesLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type SpacesLocalesEnum =
  (typeof SpacesLocalesEnum)[keyof typeof SpacesLocalesEnum];
/**
 * @export
 */
export const SpacesFilterManifestNameNotInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SpacesFilterManifestNameNotInEnum =
  (typeof SpacesFilterManifestNameNotInEnum)[keyof typeof SpacesFilterManifestNameNotInEnum];
/**
 * @export
 */
export const SpacesFilterManifestNameInEnum = {
  ParticipatoryProcesses: "participatory_processes",
  Assemblies: "assemblies",
} as const;
export type SpacesFilterManifestNameInEnum =
  (typeof SpacesFilterManifestNameInEnum)[keyof typeof SpacesFilterManifestNameInEnum];
/**
 * @export
 */
export const SpacesFilterTitlePresentEnum = {
  _1: "1",
  _0: "0",
} as const;
export type SpacesFilterTitlePresentEnum =
  (typeof SpacesFilterTitlePresentEnum)[keyof typeof SpacesFilterTitlePresentEnum];

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {Array<OrganizationsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations: async (
      locales?: Array<OrganizationsLocalesEnum>,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/organizations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (locales) {
        localVarQueryParameter["locales[]"] = locales;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {number} userId
     * @param {SetUserDataRequest} setUserDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData: async (
      userId: number,
      setUserDataRequest: SetUserDataRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("setUserData", "userId", userId);
      // verify required parameter 'setUserDataRequest' is not null or undefined
      assertParamExists(
        "setUserData",
        "setUserDataRequest",
        setUserDataRequest,
      );
      const localVarPath = `/system/users/{user_id}/extended_data`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUserDataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData: async (
      objectPath: string,
      userId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'objectPath' is not null or undefined
      assertParamExists("userData", "objectPath", objectPath);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("userData", "userId", userId);
      const localVarPath = `/system/users/{user_id}/extended_data`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (objectPath !== undefined) {
        localVarQueryParameter["object_path"] = objectPath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameNotStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {string} [filterNicknameDoesNotMatch]
     * @param {UsersFilterNicknamePresentEnum} [filterNicknamePresent]
     * @param {boolean} [filterNicknameBlank]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users: async (
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameNotStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameDoesNotMatch?: string,
      filterNicknamePresent?: UsersFilterNicknamePresentEnum,
      filterNicknameBlank?: boolean,
      filterExtendedDataCont?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication credentialFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["per_page"] = perPage;
      }

      if (filterNicknameNotIn) {
        localVarQueryParameter["filter[nickname_not_in][]"] =
          filterNicknameNotIn;
      }

      if (filterNicknameIn) {
        localVarQueryParameter["filter[nickname_in][]"] = filterNicknameIn;
      }

      if (filterNicknameStart !== undefined) {
        localVarQueryParameter["filter[nickname_start]"] = filterNicknameStart;
      }

      if (filterNicknameNotStart !== undefined) {
        localVarQueryParameter["filter[nickname_not_start]"] =
          filterNicknameNotStart;
      }

      if (filterNicknameEq !== undefined) {
        localVarQueryParameter["filter[nickname_eq]"] = filterNicknameEq;
      }

      if (filterNicknameNotEq !== undefined) {
        localVarQueryParameter["filter[nickname_not_eq]"] = filterNicknameNotEq;
      }

      if (filterNicknameMatches !== undefined) {
        localVarQueryParameter["filter[nickname_matches]"] =
          filterNicknameMatches;
      }

      if (filterNicknameDoesNotMatch !== undefined) {
        localVarQueryParameter["filter[nickname_does_not_match]"] =
          filterNicknameDoesNotMatch;
      }

      if (filterNicknamePresent !== undefined) {
        localVarQueryParameter["filter[nickname_present]"] =
          filterNicknamePresent;
      }

      if (filterNicknameBlank !== undefined) {
        localVarQueryParameter["filter[nickname_blank]"] = filterNicknameBlank;
      }

      if (filterExtendedDataCont !== undefined) {
        localVarQueryParameter["filter[extended_data_cont]"] =
          filterExtendedDataCont;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration);
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {Array<OrganizationsLocalesEnum>} [locales]
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async organizations(
      locales?: Array<OrganizationsLocalesEnum>,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrganizationsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.organizations(
        locales,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.organizations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {number} userId
     * @param {SetUserDataRequest} setUserDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserData(
      userId: number,
      setUserDataRequest: SetUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserData(
        userId,
        setUserDataRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.setUserData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {string} objectPath
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userData(
      objectPath: string,
      userId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userData(
        objectPath,
        userId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.userData"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [filterNicknameNotIn]
     * @param {Array<string>} [filterNicknameIn]
     * @param {string} [filterNicknameStart]
     * @param {string} [filterNicknameNotStart]
     * @param {string} [filterNicknameEq]
     * @param {string} [filterNicknameNotEq]
     * @param {string} [filterNicknameMatches]
     * @param {string} [filterNicknameDoesNotMatch]
     * @param {UsersFilterNicknamePresentEnum} [filterNicknamePresent]
     * @param {boolean} [filterNicknameBlank]
     * @param {string} [filterExtendedDataCont] Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async users(
      page?: number,
      perPage?: number,
      filterNicknameNotIn?: Array<string>,
      filterNicknameIn?: Array<string>,
      filterNicknameStart?: string,
      filterNicknameNotStart?: string,
      filterNicknameEq?: string,
      filterNicknameNotEq?: string,
      filterNicknameMatches?: string,
      filterNicknameDoesNotMatch?: string,
      filterNicknamePresent?: UsersFilterNicknamePresentEnum,
      filterNicknameBlank?: boolean,
      filterExtendedDataCont?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.users(
        page,
        perPage,
        filterNicknameNotIn,
        filterNicknameIn,
        filterNicknameStart,
        filterNicknameNotStart,
        filterNicknameEq,
        filterNicknameNotEq,
        filterNicknameMatches,
        filterNicknameDoesNotMatch,
        filterNicknamePresent,
        filterNicknameBlank,
        filterExtendedDataCont,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SystemApi.users"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration);
  return {
    /**
     * List available organizations
     * @summary List available organizations
     * @param {SystemApiOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organizations(
      requestParameters: SystemApiOrganizationsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OrganizationsResponse> {
      return localVarFp
        .organizations(
          requestParameters.locales,
          requestParameters.page,
          requestParameters.perPage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
     * @summary Update user extended data
     * @param {SystemApiSetUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserData(
      requestParameters: SystemApiSetUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .setUserData(
          requestParameters.userId,
          requestParameters.setUserDataRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch user extended data
     * @summary Get user extended data
     * @param {SystemApiUserDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userData(
      requestParameters: SystemApiUserDataRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .userData(
          requestParameters.objectPath,
          requestParameters.userId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List or search users of the organization
     * @summary List available Users
     * @param {SystemApiUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    users(
      requestParameters: SystemApiUsersRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UsersResponse> {
      return localVarFp
        .users(
          requestParameters.page,
          requestParameters.perPage,
          requestParameters.filterNicknameNotIn,
          requestParameters.filterNicknameIn,
          requestParameters.filterNicknameStart,
          requestParameters.filterNicknameNotStart,
          requestParameters.filterNicknameEq,
          requestParameters.filterNicknameNotEq,
          requestParameters.filterNicknameMatches,
          requestParameters.filterNicknameDoesNotMatch,
          requestParameters.filterNicknamePresent,
          requestParameters.filterNicknameBlank,
          requestParameters.filterExtendedDataCont,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for organizations operation in SystemApi.
 * @export
 * @interface SystemApiOrganizationsRequest
 */
export interface SystemApiOrganizationsRequest {
  /**
   *
   * @type {Array<'en' | 'bg' | 'ar' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'eo' | 'es' | 'es-MX' | 'es-PY' | 'et' | 'eu' | 'fa' | 'fi-pl' | 'fi' | 'fr' | 'fr-CA' | 'ga' | 'gl' | 'hr' | 'hu' | 'id' | 'is' | 'it' | 'ja' | 'ko' | 'lb' | 'lt' | 'lv' | 'mt' | 'nl' | 'no' | 'pl' | 'pt' | 'pt-BR' | 'ro' | 'ru' | 'sk' | 'sl' | 'sr' | 'sv' | 'tr' | 'uk' | 'vi' | 'zh-CN' | 'zh-TW'>}
   * @memberof SystemApiOrganizations
   */
  readonly locales?: Array<OrganizationsLocalesEnum>;

  /**
   * Page number for pagination
   * @type {number}
   * @memberof SystemApiOrganizations
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof SystemApiOrganizations
   */
  readonly perPage?: number;
}

/**
 * Request parameters for setUserData operation in SystemApi.
 * @export
 * @interface SystemApiSetUserDataRequest
 */
export interface SystemApiSetUserDataRequest {
  /**
   *
   * @type {number}
   * @memberof SystemApiSetUserData
   */
  readonly userId: number;

  /**
   *
   * @type {SetUserDataRequest}
   * @memberof SystemApiSetUserData
   */
  readonly setUserDataRequest: SetUserDataRequest;
}

/**
 * Request parameters for userData operation in SystemApi.
 * @export
 * @interface SystemApiUserDataRequest
 */
export interface SystemApiUserDataRequest {
  /**
   *
   * @type {string}
   * @memberof SystemApiUserData
   */
  readonly objectPath: string;

  /**
   *
   * @type {number}
   * @memberof SystemApiUserData
   */
  readonly userId: number;
}

/**
 * Request parameters for users operation in SystemApi.
 * @export
 * @interface SystemApiUsersRequest
 */
export interface SystemApiUsersRequest {
  /**
   * Page number for pagination
   * @type {number}
   * @memberof SystemApiUsers
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof SystemApiUsers
   */
  readonly perPage?: number;

  /**
   *
   * @type {Array<string>}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameNotIn?: Array<string>;

  /**
   *
   * @type {Array<string>}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameIn?: Array<string>;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameStart?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameNotStart?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameEq?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameNotEq?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameMatches?: string;

  /**
   *
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameDoesNotMatch?: string;

  /**
   *
   * @type {'1' | '0'}
   * @memberof SystemApiUsers
   */
  readonly filterNicknamePresent?: UsersFilterNicknamePresentEnum;

  /**
   *
   * @type {boolean}
   * @memberof SystemApiUsers
   */
  readonly filterNicknameBlank?: boolean;

  /**
   * Search on user extended_data. use the format: &#x60;\&quot;&lt;key&gt;\&quot;:&lt;space&gt;\&quot;&lt;value&gt;\&quot;&#x60;
   * @type {string}
   * @memberof SystemApiUsers
   */
  readonly filterExtendedDataCont?: string;
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   * List available organizations
   * @summary List available organizations
   * @param {SystemApiOrganizationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public organizations(
    requestParameters: SystemApiOrganizationsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .organizations(
        requestParameters.locales,
        requestParameters.page,
        requestParameters.perPage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The extended_data feature allows you to update a hash with recursive merging. Use the body payload with these keys:  1. `data`: The value or hash you want to update. 2. `object_path`: The dot-style path to the key (e.g., access.this.key).  **Root path**<br /> To update data from root of the hash, use `object_path=\".\"`.  Example: ```   body={\"data\": {\"name\": \"Jane\"}, \"object_path\": \"personnal\"} ``` This recursively merges data into the hash without removing existing keys.  **Merge some data**<br /> Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"}   } ``` Patch payload: ```json   {     \"data\": {       \"name\": \"Jane\"     },     \"object_path\": \"personnal\"   } ``` Result: ```   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ```  **Create new Paths**<br /> Paths are created as needed. Exemple: ```json   body = {\"data\": {\"external_user_id\": 12}, \"object_path\": \"data-store.my-app.foo\"} ``` Result: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\"},     \"data-store\": {\"my-app\": {\"foo\": {\"external_user_id\": 12}}}   } ``` Alternatively: ```   body = {\"data\": 12, \"object_path\": \"data-store.my-app.foo.external_user_id\"} ```  **Remove a key**<br /> Set a key to null or an empty value to remove it.  Example: Initial hash: ```json   {     \"personnal\": {\"birthday\": \"1989-05-18\", \"name\": \"Jane\"}   } ``` Patch: ```json   body = {\"data\": {\"birthday\": \"\"}, \"object_path\": \"personnal\"} ```  Result: ``` {   \"personnal\": {\"name\": \"Jane\"} } ```  **Return Value**<br /> The update request returns the updated value at the specified path.
   * @summary Update user extended data
   * @param {SystemApiSetUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public setUserData(
    requestParameters: SystemApiSetUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .setUserData(
        requestParameters.userId,
        requestParameters.setUserDataRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch user extended data
   * @summary Get user extended data
   * @param {SystemApiUserDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public userData(
    requestParameters: SystemApiUserDataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .userData(requestParameters.objectPath, requestParameters.userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List or search users of the organization
   * @summary List available Users
   * @param {SystemApiUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public users(
    requestParameters: SystemApiUsersRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .users(
        requestParameters.page,
        requestParameters.perPage,
        requestParameters.filterNicknameNotIn,
        requestParameters.filterNicknameIn,
        requestParameters.filterNicknameStart,
        requestParameters.filterNicknameNotStart,
        requestParameters.filterNicknameEq,
        requestParameters.filterNicknameNotEq,
        requestParameters.filterNicknameMatches,
        requestParameters.filterNicknameDoesNotMatch,
        requestParameters.filterNicknamePresent,
        requestParameters.filterNicknameBlank,
        requestParameters.filterExtendedDataCont,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const OrganizationsLocalesEnum = {
  En: "en",
  Bg: "bg",
  Ar: "ar",
  Ca: "ca",
  Cs: "cs",
  Da: "da",
  De: "de",
  El: "el",
  Eo: "eo",
  Es: "es",
  EsMx: "es-MX",
  EsPy: "es-PY",
  Et: "et",
  Eu: "eu",
  Fa: "fa",
  FiPl: "fi-pl",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  Ga: "ga",
  Gl: "gl",
  Hr: "hr",
  Hu: "hu",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ko: "ko",
  Lb: "lb",
  Lt: "lt",
  Lv: "lv",
  Mt: "mt",
  Nl: "nl",
  No: "no",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  Sr: "sr",
  Sv: "sv",
  Tr: "tr",
  Uk: "uk",
  Vi: "vi",
  ZhCn: "zh-CN",
  ZhTw: "zh-TW",
} as const;
export type OrganizationsLocalesEnum =
  (typeof OrganizationsLocalesEnum)[keyof typeof OrganizationsLocalesEnum];
/**
 * @export
 */
export const UsersFilterNicknamePresentEnum = {
  _1: "1",
  _0: "0",
} as const;
export type UsersFilterNicknamePresentEnum =
  (typeof UsersFilterNicknamePresentEnum)[keyof typeof UsersFilterNicknamePresentEnum];

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {MagickLinkConfigurationPayload} [magickLinkConfigurationPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink: async (
      magickLinkConfigurationPayload?: MagickLinkConfigurationPayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/me/magic-links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        magickLinkConfigurationPayload,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Challenge given token, open and a session and redirect
     * @summary Use a magic-lick
     * @param {string} magicToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    magicLinkSignin: async (
      magicToken: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'magicToken' is not null or undefined
      assertParamExists("magicLinkSignin", "magicToken", magicToken);
      const localVarPath = `/me/magic-links/{magic_token}`.replace(
        `{${"magic_token"}}`,
        encodeURIComponent(String(magicToken)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication resourceOwnerFlowBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {MagickLinkConfigurationPayload} [magickLinkConfigurationPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateMagicLink(
      magickLinkConfigurationPayload?: MagickLinkConfigurationPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MagicLinkResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateMagicLink(
          magickLinkConfigurationPayload,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.generateMagicLink"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Challenge given token, open and a session and redirect
     * @summary Use a magic-lick
     * @param {string} magicToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async magicLinkSignin(
      magicToken: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.magicLinkSignin(
        magicToken,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.magicLinkSignin"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
     * @summary Create a magic-lick
     * @param {UsersApiGenerateMagicLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink(
      requestParameters: UsersApiGenerateMagicLinkRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MagicLinkResponse> {
      return localVarFp
        .generateMagicLink(
          requestParameters.magickLinkConfigurationPayload,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Challenge given token, open and a session and redirect
     * @summary Use a magic-lick
     * @param {UsersApiMagicLinkSigninRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    magicLinkSignin(
      requestParameters: UsersApiMagicLinkSigninRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .magicLinkSignin(requestParameters.magicToken, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for generateMagicLink operation in UsersApi.
 * @export
 * @interface UsersApiGenerateMagicLinkRequest
 */
export interface UsersApiGenerateMagicLinkRequest {
  /**
   *
   * @type {MagickLinkConfigurationPayload}
   * @memberof UsersApiGenerateMagicLink
   */
  readonly magickLinkConfigurationPayload?: MagickLinkConfigurationPayload;
}

/**
 * Request parameters for magicLinkSignin operation in UsersApi.
 * @export
 * @interface UsersApiMagicLinkSigninRequest
 */
export interface UsersApiMagicLinkSigninRequest {
  /**
   *
   * @type {string}
   * @memberof UsersApiMagicLinkSignin
   */
  readonly magicToken: string;
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Generates a uniq magic link, valid for 5minutes. If the user follow this link, it will be signed in automatically
   * @summary Create a magic-lick
   * @param {UsersApiGenerateMagicLinkRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public generateMagicLink(
    requestParameters: UsersApiGenerateMagicLinkRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .generateMagicLink(
        requestParameters.magickLinkConfigurationPayload,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Challenge given token, open and a session and redirect
   * @summary Use a magic-lick
   * @param {UsersApiMagicLinkSigninRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public magicLinkSignin(
    requestParameters: UsersApiMagicLinkSigninRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .magicLinkSignin(requestParameters.magicToken, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
